{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(require(\"@firebase/app\")) : \"function\" == typeof define && define.amd ? define([\"@firebase/app\"], e) : e(t.firebase);\n}(this, function (t) {\n  \"use strict\";\n\n  try {\n    (function () {\n      var e;\n      t = t && t.hasOwnProperty(\"default\") ? t.default : t, function (t) {\n        t[t.DEBUG = 0] = \"DEBUG\", t[t.VERBOSE = 1] = \"VERBOSE\", t[t.INFO = 2] = \"INFO\", t[t.WARN = 3] = \"WARN\", t[t.ERROR = 4] = \"ERROR\", t[t.SILENT = 5] = \"SILENT\";\n      }(e || (e = {}));\n\n      var n = e.INFO,\n          r = function r(t, n) {\n        for (var r = [], i = 2; i < arguments.length; i++) {\n          r[i - 2] = arguments[i];\n        }\n\n        if (!(n < t.logLevel)) {\n          var o = new Date().toISOString();\n\n          switch (n) {\n            case e.DEBUG:\n            case e.VERBOSE:\n              console.log.apply(console, [\"[\" + o + \"]  \" + t.name + \":\"].concat(r));\n              break;\n\n            case e.INFO:\n              console.info.apply(console, [\"[\" + o + \"]  \" + t.name + \":\"].concat(r));\n              break;\n\n            case e.WARN:\n              console.warn.apply(console, [\"[\" + o + \"]  \" + t.name + \":\"].concat(r));\n              break;\n\n            case e.ERROR:\n              console.error.apply(console, [\"[\" + o + \"]  \" + t.name + \":\"].concat(r));\n              break;\n\n            default:\n              throw new Error(\"Attempted to log a message with an invalid logType (value: \" + n + \")\");\n          }\n        }\n      },\n          i = function () {\n        function t(t) {\n          this.name = t, this._logLevel = n, this._logHandler = r;\n        }\n\n        return Object.defineProperty(t.prototype, \"logLevel\", {\n          get: function get() {\n            return this._logLevel;\n          },\n          set: function set(t) {\n            if (!(t in e)) throw new TypeError(\"Invalid value assigned to `logLevel`\");\n            this._logLevel = t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"logHandler\", {\n          get: function get() {\n            return this._logHandler;\n          },\n          set: function set(t) {\n            if (\"function\" != typeof t) throw new TypeError(\"Value assigned to `logHandler` must be a function\");\n            this._logHandler = t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.debug = function () {\n          for (var t = [], n = 0; n < arguments.length; n++) {\n            t[n] = arguments[n];\n          }\n\n          this._logHandler.apply(this, [this, e.DEBUG].concat(t));\n        }, t.prototype.log = function () {\n          for (var t = [], n = 0; n < arguments.length; n++) {\n            t[n] = arguments[n];\n          }\n\n          this._logHandler.apply(this, [this, e.VERBOSE].concat(t));\n        }, t.prototype.info = function () {\n          for (var t = [], n = 0; n < arguments.length; n++) {\n            t[n] = arguments[n];\n          }\n\n          this._logHandler.apply(this, [this, e.INFO].concat(t));\n        }, t.prototype.warn = function () {\n          for (var t = [], n = 0; n < arguments.length; n++) {\n            t[n] = arguments[n];\n          }\n\n          this._logHandler.apply(this, [this, e.WARN].concat(t));\n        }, t.prototype.error = function () {\n          for (var t = [], n = 0; n < arguments.length; n++) {\n            t[n] = arguments[n];\n          }\n\n          this._logHandler.apply(this, [this, e.ERROR].concat(t));\n        }, t;\n      }(),\n          o = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var n in e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n      };\n\n      function s(t, e) {\n        function n() {\n          this.constructor = t;\n        }\n\n        o(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n());\n      }\n\n      function a(t, e, n, r) {\n        return new (n || (n = Promise))(function (i, o) {\n          function s(t) {\n            try {\n              u(r.next(t));\n            } catch (t) {\n              o(t);\n            }\n          }\n\n          function a(t) {\n            try {\n              u(r.throw(t));\n            } catch (t) {\n              o(t);\n            }\n          }\n\n          function u(t) {\n            t.done ? i(t.value) : new n(function (e) {\n              e(t.value);\n            }).then(s, a);\n          }\n\n          u((r = r.apply(t, e || [])).next());\n        });\n      }\n\n      function u(t, e) {\n        var n,\n            r,\n            i,\n            o,\n            s = {\n          label: 0,\n          sent: function sent() {\n            if (1 & i[0]) throw i[1];\n            return i[1];\n          },\n          trys: [],\n          ops: []\n        };\n        return o = {\n          next: a(0),\n          throw: a(1),\n          return: a(2)\n        }, \"function\" == typeof Symbol && (o[Symbol.iterator] = function () {\n          return this;\n        }), o;\n\n        function a(o) {\n          return function (a) {\n            return function (o) {\n              if (n) throw new TypeError(\"Generator is already executing.\");\n\n              for (; s;) {\n                try {\n                  if (n = 1, r && (i = r[2 & o[0] ? \"return\" : o[0] ? \"throw\" : \"next\"]) && !(i = i.call(r, o[1])).done) return i;\n\n                  switch (r = 0, i && (o = [0, i.value]), o[0]) {\n                    case 0:\n                    case 1:\n                      i = o;\n                      break;\n\n                    case 4:\n                      return s.label++, {\n                        value: o[1],\n                        done: !1\n                      };\n\n                    case 5:\n                      s.label++, r = o[1], o = [0];\n                      continue;\n\n                    case 7:\n                      o = s.ops.pop(), s.trys.pop();\n                      continue;\n\n                    default:\n                      if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {\n                        s = 0;\n                        continue;\n                      }\n\n                      if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {\n                        s.label = o[1];\n                        break;\n                      }\n\n                      if (6 === o[0] && s.label < i[1]) {\n                        s.label = i[1], i = o;\n                        break;\n                      }\n\n                      if (i && s.label < i[2]) {\n                        s.label = i[2], s.ops.push(o);\n                        break;\n                      }\n\n                      i[2] && s.ops.pop(), s.trys.pop();\n                      continue;\n                  }\n\n                  o = e.call(t, s);\n                } catch (t) {\n                  o = [6, t], r = 0;\n                } finally {\n                  n = i = 0;\n                }\n              }\n\n              if (5 & o[0]) throw o[1];\n              return {\n                value: o[0] ? o[1] : void 0,\n                done: !0\n              };\n            }([o, a]);\n          };\n        }\n      }\n\n      var c,\n          h = \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {},\n          l = l || {},\n          f = h;\n\n      function d(t) {\n        return \"string\" == typeof t;\n      }\n\n      function p(t, e) {\n        t = t.split(\".\"), e = e || f;\n\n        for (var n = 0; n < t.length; n++) {\n          if (null == (e = e[t[n]])) return null;\n        }\n\n        return e;\n      }\n\n      function m() {}\n\n      function y(t) {\n        var e = typeof t;\n\n        if (\"object\" == e) {\n          if (!t) return \"null\";\n          if (t instanceof Array) return \"array\";\n          if (t instanceof Object) return e;\n          var n = Object.prototype.toString.call(t);\n          if (\"[object Window]\" == n) return \"object\";\n          if (\"[object Array]\" == n || \"number\" == typeof t.length && void 0 !== t.splice && void 0 !== t.propertyIsEnumerable && !t.propertyIsEnumerable(\"splice\")) return \"array\";\n          if (\"[object Function]\" == n || void 0 !== t.call && void 0 !== t.propertyIsEnumerable && !t.propertyIsEnumerable(\"call\")) return \"function\";\n        } else if (\"function\" == e && void 0 === t.call) return \"object\";\n\n        return e;\n      }\n\n      function g(t) {\n        return \"array\" == y(t);\n      }\n\n      function v(t) {\n        var e = y(t);\n        return \"array\" == e || \"object\" == e && \"number\" == typeof t.length;\n      }\n\n      function b(t) {\n        return \"function\" == y(t);\n      }\n\n      function w(t) {\n        var e = typeof t;\n        return \"object\" == e && null != t || \"function\" == e;\n      }\n\n      var E = \"closure_uid_\" + (1e9 * Math.random() >>> 0),\n          S = 0;\n\n      function T(t, e, n) {\n        return t.call.apply(t.bind, arguments);\n      }\n\n      function I(t, e, n) {\n        if (!t) throw Error();\n\n        if (2 < arguments.length) {\n          var r = Array.prototype.slice.call(arguments, 2);\n          return function () {\n            var n = Array.prototype.slice.call(arguments);\n            return Array.prototype.unshift.apply(n, r), t.apply(e, n);\n          };\n        }\n\n        return function () {\n          return t.apply(e, arguments);\n        };\n      }\n\n      function C(t, e, n) {\n        return (C = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf(\"native code\") ? T : I).apply(null, arguments);\n      }\n\n      function D(t, e) {\n        var n = Array.prototype.slice.call(arguments, 1);\n        return function () {\n          var e = n.slice();\n          return e.push.apply(e, arguments), t.apply(this, e);\n        };\n      }\n\n      var N = Date.now || function () {\n        return +new Date();\n      };\n\n      function A(t, e) {\n        function n() {}\n\n        n.prototype = e.prototype, t.L = e.prototype, t.prototype = new n(), t.prototype.constructor = t, t.mh = function (t, n, r) {\n          for (var i = Array(arguments.length - 2), o = 2; o < arguments.length; o++) {\n            i[o - 2] = arguments[o];\n          }\n\n          return e.prototype[n].apply(t, i);\n        };\n      }\n\n      function k(t) {\n        if (Error.captureStackTrace) Error.captureStackTrace(this, k);else {\n          var e = Error().stack;\n          e && (this.stack = e);\n        }\n        t && (this.message = String(t));\n      }\n\n      function R(t, e) {\n        for (var n = \"\", r = (t = t.split(\"%s\")).length - 1, i = 0; i < r; i++) {\n          n += t[i] + (i < e.length ? e[i] : \"%s\");\n        }\n\n        k.call(this, n + t[r]);\n      }\n\n      function M() {\n        0 != O && (_[this[E] || (this[E] = ++S)] = this), this.Ka = this.Ka, this.Qa = this.Qa;\n      }\n\n      A(k, Error), k.prototype.name = \"CustomError\", A(R, k), R.prototype.name = \"AssertionError\";\n      var O = 0,\n          _ = {};\n      M.prototype.Ka = !1, M.prototype.bb = function () {\n        if (!this.Ka && (this.Ka = !0, this.F(), 0 != O)) {\n          var t = this[E] || (this[E] = ++S);\n          if (0 != O && this.Qa && 0 < this.Qa.length) throw Error(this + \" did not empty its onDisposeCallbacks queue. This probably means it overrode dispose() or disposeInternal() without calling the superclass' method.\");\n          delete _[t];\n        }\n      }, M.prototype.F = function () {\n        if (this.Qa) for (; this.Qa.length;) {\n          this.Qa.shift()();\n        }\n      };\n      var P = Array.prototype.indexOf ? function (t, e) {\n        return Array.prototype.indexOf.call(t, e, void 0);\n      } : function (t, e) {\n        if (d(t)) return d(e) && 1 == e.length ? t.indexOf(e, 0) : -1;\n\n        for (var n = 0; n < t.length; n++) {\n          if (n in t && t[n] === e) return n;\n        }\n\n        return -1;\n      },\n          L = Array.prototype.lastIndexOf ? function (t, e) {\n        return Array.prototype.lastIndexOf.call(t, e, t.length - 1);\n      } : function (t, e) {\n        var n = t.length - 1;\n        if (0 > n && (n = Math.max(0, t.length + n)), d(t)) return d(e) && 1 == e.length ? t.lastIndexOf(e, n) : -1;\n\n        for (; 0 <= n; n--) {\n          if (n in t && t[n] === e) return n;\n        }\n\n        return -1;\n      },\n          x = Array.prototype.forEach ? function (t, e, n) {\n        Array.prototype.forEach.call(t, e, n);\n      } : function (t, e, n) {\n        for (var r = t.length, i = d(t) ? t.split(\"\") : t, o = 0; o < r; o++) {\n          o in i && e.call(n, i[o], o, t);\n        }\n      },\n          q = Array.prototype.some ? function (t, e) {\n        return Array.prototype.some.call(t, e, void 0);\n      } : function (t, e) {\n        for (var n = t.length, r = d(t) ? t.split(\"\") : t, i = 0; i < n; i++) {\n          if (i in r && e.call(void 0, r[i], i, t)) return !0;\n        }\n\n        return !1;\n      };\n\n      function F(t) {\n        if (!g(t)) for (var e = t.length - 1; 0 <= e; e--) {\n          delete t[e];\n        }\n        t.length = 0;\n      }\n\n      function B(t, e) {\n        var n;\n        return (n = 0 <= (e = P(t, e))) && Array.prototype.splice.call(t, e, 1), n;\n      }\n\n      function U(t) {\n        return Array.prototype.concat.apply([], arguments);\n      }\n\n      function V(t) {\n        var e = t.length;\n\n        if (0 < e) {\n          for (var n = Array(e), r = 0; r < e; r++) {\n            n[r] = t[r];\n          }\n\n          return n;\n        }\n\n        return [];\n      }\n\n      function Q(t) {\n        return /^[\\s\\xa0]*$/.test(t);\n      }\n\n      var K,\n          W = String.prototype.trim ? function (t) {\n        return t.trim();\n      } : function (t) {\n        return /^[\\s\\xa0]*([\\s\\S]*?)[\\s\\xa0]*$/.exec(t)[1];\n      };\n\n      function j(t, e) {\n        return t < e ? -1 : t > e ? 1 : 0;\n      }\n\n      t: {\n        var z = f.navigator;\n\n        if (z) {\n          var G = z.userAgent;\n\n          if (G) {\n            K = G;\n            break t;\n          }\n        }\n\n        K = \"\";\n      }\n\n      function H(t) {\n        return -1 != K.indexOf(t);\n      }\n\n      function X(t, e, n) {\n        for (var r in t) {\n          e.call(n, t[r], r, t);\n        }\n      }\n\n      function Y(t) {\n        var e,\n            n = [],\n            r = 0;\n\n        for (e in t) {\n          n[r++] = t[e];\n        }\n\n        return n;\n      }\n\n      function J(t) {\n        var e,\n            n = [],\n            r = 0;\n\n        for (e in t) {\n          n[r++] = e;\n        }\n\n        return n;\n      }\n\n      function Z(t) {\n        var e,\n            n = {};\n\n        for (e in t) {\n          n[e] = t[e];\n        }\n\n        return n;\n      }\n\n      var $ = \"constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf\".split(\" \");\n\n      function tt(t, e) {\n        for (var n, r, i = 1; i < arguments.length; i++) {\n          for (n in r = arguments[i]) {\n            t[n] = r[n];\n          }\n\n          for (var o = 0; o < $.length; o++) {\n            n = $[o], Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n          }\n        }\n      }\n\n      function et(t) {\n        return et[\" \"](t), t;\n      }\n\n      et[\" \"] = m;\n      var nt,\n          rt,\n          it = H(\"Opera\"),\n          ot = H(\"Trident\") || H(\"MSIE\"),\n          st = H(\"Edge\"),\n          at = st || ot,\n          ut = H(\"Gecko\") && !(-1 != K.toLowerCase().indexOf(\"webkit\") && !H(\"Edge\")) && !(H(\"Trident\") || H(\"MSIE\")) && !H(\"Edge\"),\n          ct = -1 != K.toLowerCase().indexOf(\"webkit\") && !H(\"Edge\");\n\n      function ht() {\n        var t = f.document;\n        return t ? t.documentMode : void 0;\n      }\n\n      t: {\n        var lt = \"\",\n            ft = (rt = K, ut ? /rv:([^\\);]+)(\\)|;)/.exec(rt) : st ? /Edge\\/([\\d\\.]+)/.exec(rt) : ot ? /\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/.exec(rt) : ct ? /WebKit\\/(\\S+)/.exec(rt) : it ? /(?:Version)[ \\/]?(\\S+)/.exec(rt) : void 0);\n\n        if (ft && (lt = ft ? ft[1] : \"\"), ot) {\n          var dt = ht();\n\n          if (null != dt && dt > parseFloat(lt)) {\n            nt = String(dt);\n            break t;\n          }\n        }\n\n        nt = lt;\n      }\n\n      var pt,\n          mt = {};\n\n      function yt(t) {\n        return function (t, e) {\n          var n = mt;\n          return Object.prototype.hasOwnProperty.call(n, t) ? n[t] : n[t] = e(t);\n        }(t, function () {\n          for (var e = 0, n = W(String(nt)).split(\".\"), r = W(String(t)).split(\".\"), i = Math.max(n.length, r.length), o = 0; 0 == e && o < i; o++) {\n            var s = n[o] || \"\",\n                a = r[o] || \"\";\n\n            do {\n              if (s = /(\\d*)(\\D*)(.*)/.exec(s) || [\"\", \"\", \"\", \"\"], a = /(\\d*)(\\D*)(.*)/.exec(a) || [\"\", \"\", \"\", \"\"], 0 == s[0].length && 0 == a[0].length) break;\n              e = j(0 == s[1].length ? 0 : parseInt(s[1], 10), 0 == a[1].length ? 0 : parseInt(a[1], 10)) || j(0 == s[2].length, 0 == a[2].length) || j(s[2], a[2]), s = s[3], a = a[3];\n            } while (0 == e);\n          }\n\n          return 0 <= e;\n        });\n      }\n\n      var gt = f.document;\n      pt = gt && ot ? ht() || (\"CSS1Compat\" == gt.compatMode ? parseInt(nt, 10) : 5) : void 0;\n\n      var vt = Object.freeze || function (t) {\n        return t;\n      },\n          bt = !ot || 9 <= Number(pt),\n          wt = ot && !yt(\"9\"),\n          Et = function () {\n        if (!f.addEventListener || !Object.defineProperty) return !1;\n        var t = !1,\n            e = Object.defineProperty({}, \"passive\", {\n          get: function get() {\n            t = !0;\n          }\n        });\n\n        try {\n          f.addEventListener(\"test\", m, e), f.removeEventListener(\"test\", m, e);\n        } catch (t) {}\n\n        return t;\n      }();\n\n      function St(t, e) {\n        this.type = t, this.currentTarget = this.target = e, this.defaultPrevented = this.Ea = !1, this.Be = !0;\n      }\n\n      function Tt(t, e) {\n        St.call(this, t ? t.type : \"\"), this.relatedTarget = this.currentTarget = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = this.offsetY = this.offsetX = 0, this.key = \"\", this.charCode = this.keyCode = 0, this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.state = null, this.pointerId = 0, this.pointerType = \"\", this.fb = null, t && this.Kf(t, e);\n      }\n\n      St.prototype.stopPropagation = function () {\n        this.Ea = !0;\n      }, St.prototype.preventDefault = function () {\n        this.defaultPrevented = !0, this.Be = !1;\n      }, A(Tt, St);\n      var It = vt({\n        2: \"touch\",\n        3: \"pen\",\n        4: \"mouse\"\n      });\n      Tt.prototype.Kf = function (t, e) {\n        var n = this.type = t.type,\n            r = t.changedTouches ? t.changedTouches[0] : null;\n\n        if (this.target = t.target || t.srcElement, this.currentTarget = e, e = t.relatedTarget) {\n          if (ut) {\n            t: {\n              try {\n                et(e.nodeName);\n                var i = !0;\n                break t;\n              } catch (t) {}\n\n              i = !1;\n            }\n\n            i || (e = null);\n          }\n        } else \"mouseover\" == n ? e = t.fromElement : \"mouseout\" == n && (e = t.toElement);\n\n        this.relatedTarget = e, null === r ? (this.offsetX = ct || void 0 !== t.offsetX ? t.offsetX : t.layerX, this.offsetY = ct || void 0 !== t.offsetY ? t.offsetY : t.layerY, this.clientX = void 0 !== t.clientX ? t.clientX : t.pageX, this.clientY = void 0 !== t.clientY ? t.clientY : t.pageY, this.screenX = t.screenX || 0, this.screenY = t.screenY || 0) : (this.clientX = void 0 !== r.clientX ? r.clientX : r.pageX, this.clientY = void 0 !== r.clientY ? r.clientY : r.pageY, this.screenX = r.screenX || 0, this.screenY = r.screenY || 0), this.button = t.button, this.keyCode = t.keyCode || 0, this.key = t.key || \"\", this.charCode = t.charCode || (\"keypress\" == n ? t.keyCode : 0), this.ctrlKey = t.ctrlKey, this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.metaKey = t.metaKey, this.pointerId = t.pointerId || 0, this.pointerType = d(t.pointerType) ? t.pointerType : It[t.pointerType] || \"\", this.state = t.state, this.fb = t, t.defaultPrevented && this.preventDefault();\n      }, Tt.prototype.stopPropagation = function () {\n        Tt.L.stopPropagation.call(this), this.fb.stopPropagation ? this.fb.stopPropagation() : this.fb.cancelBubble = !0;\n      }, Tt.prototype.preventDefault = function () {\n        Tt.L.preventDefault.call(this);\n        var t = this.fb;\n        if (t.preventDefault) t.preventDefault();else if (t.returnValue = !1, wt) try {\n          (t.ctrlKey || 112 <= t.keyCode && 123 >= t.keyCode) && (t.keyCode = -1);\n        } catch (t) {}\n      };\n      var Ct = \"closure_listenable_\" + (1e6 * Math.random() | 0);\n\n      function Dt(t) {\n        return !(!t || !t[Ct]);\n      }\n\n      var Nt = 0;\n\n      function At(t, e, n, r, i) {\n        this.listener = t, this.proxy = null, this.src = e, this.type = n, this.capture = !!r, this.Ob = i, this.key = ++Nt, this.Sa = this.Eb = !1;\n      }\n\n      function kt(t) {\n        this.src = t, this.J = {}, this.xb = 0;\n      }\n\n      function Rt(t, e, n, r) {\n        for (var i = 0; i < t.length; ++i) {\n          var o = t[i];\n          if (!o.Sa && o.listener == e && o.capture == !!n && o.Ob == r) return i;\n        }\n\n        return -1;\n      }\n\n      At.prototype.Vb = function () {\n        this.Sa = !0, this.Ob = this.src = this.proxy = this.listener = null;\n      }, (c = kt.prototype).add = function (t, e, n, r, i) {\n        var o = t.toString();\n        (t = this.J[o]) || (t = this.J[o] = [], this.xb++);\n        var s = Rt(t, e, r, i);\n        return -1 < s ? (e = t[s], n || (e.Eb = !1)) : ((e = new At(e, this.src, o, !!r, i)).Eb = n, t.push(e)), e;\n      }, c.remove = function (t, e, n, r) {\n        if (!((t = t.toString()) in this.J)) return !1;\n        var i = this.J[t];\n        return -1 < (e = Rt(i, e, n, r)) && (i[e].Vb(), Array.prototype.splice.call(i, e, 1), 0 == i.length && (delete this.J[t], this.xb--), !0);\n      }, c.ye = function (t) {\n        var e = t.type;\n        e in this.J && B(this.J[e], t) && (t.Vb(), 0 == this.J[e].length && (delete this.J[e], this.xb--));\n      }, c.pb = function (t) {\n        var e;\n\n        for (e in t = t && t.toString(), this.J) {\n          if (!t || e == t) {\n            for (var n = this.J[e], r = 0; r < n.length; r++) {\n              n[r].Vb();\n            }\n\n            delete this.J[e], this.xb--;\n          }\n        }\n      }, c.jb = function (t, e, n, r) {\n        var i = -1;\n        return (t = this.J[t.toString()]) && (i = Rt(t, e, n, r)), -1 < i ? t[i] : null;\n      };\n      var Mt = \"closure_lm_\" + (1e6 * Math.random() | 0),\n          Ot = {};\n\n      function _t(t, e, n, r, i) {\n        if (r && r.once) return Lt(t, e, n, r, i);\n\n        if (g(e)) {\n          for (var o = 0; o < e.length; o++) {\n            _t(t, e[o], n, r, i);\n          }\n\n          return null;\n        }\n\n        return n = Kt(n), Dt(t) ? t.nb(e, n, w(r) ? !!r.capture : !!r, i) : Pt(t, e, n, !1, r, i);\n      }\n\n      function Pt(t, e, n, r, i, o) {\n        if (!e) throw Error(\"Invalid event type\");\n        var s = w(i) ? !!i.capture : !!i,\n            a = Vt(t);\n        if (a || (t[Mt] = a = new kt(t)), (n = a.add(e, n, r, s, o)).proxy) return n;\n        if (r = function () {\n          var t = Ut,\n              e = bt ? function (n) {\n            return t.call(e.src, e.listener, n);\n          } : function (n) {\n            if (!(n = t.call(e.src, e.listener, n))) return n;\n          };\n          return e;\n        }(), n.proxy = r, r.src = t, r.listener = n, t.addEventListener) Et || (i = s), void 0 === i && (i = !1), t.addEventListener(e.toString(), r, i);else if (t.attachEvent) t.attachEvent(qt(e.toString()), r);else {\n          if (!t.addListener || !t.removeListener) throw Error(\"addEventListener and attachEvent are unavailable.\");\n          t.addListener(r);\n        }\n        return n;\n      }\n\n      function Lt(t, e, n, r, i) {\n        if (g(e)) {\n          for (var o = 0; o < e.length; o++) {\n            Lt(t, e[o], n, r, i);\n          }\n\n          return null;\n        }\n\n        return n = Kt(n), Dt(t) ? t.Oc(e, n, w(r) ? !!r.capture : !!r, i) : Pt(t, e, n, !0, r, i);\n      }\n\n      function xt(t) {\n        if (\"number\" != typeof t && t && !t.Sa) {\n          var e = t.src;\n          if (Dt(e)) e.Le(t);else {\n            var n = t.type,\n                r = t.proxy;\n            e.removeEventListener ? e.removeEventListener(n, r, t.capture) : e.detachEvent ? e.detachEvent(qt(n), r) : e.addListener && e.removeListener && e.removeListener(r), (n = Vt(e)) ? (n.ye(t), 0 == n.xb && (n.src = null, e[Mt] = null)) : t.Vb();\n          }\n        }\n      }\n\n      function qt(t) {\n        return t in Ot ? Ot[t] : Ot[t] = \"on\" + t;\n      }\n\n      function Ft(t, e, n, r) {\n        var i = !0;\n        if ((t = Vt(t)) && (e = t.J[e.toString()])) for (e = e.concat(), t = 0; t < e.length; t++) {\n          var o = e[t];\n          o && o.capture == n && !o.Sa && (o = Bt(o, r), i = i && !1 !== o);\n        }\n        return i;\n      }\n\n      function Bt(t, e) {\n        var n = t.listener,\n            r = t.Ob || t.src;\n        return t.Eb && xt(t), n.call(r, e);\n      }\n\n      function Ut(t, e) {\n        if (t.Sa) return !0;\n\n        if (!bt) {\n          var n = e || p(\"window.event\");\n          e = new Tt(n, this);\n          var r = !0;\n\n          if (!(0 > n.keyCode || void 0 != n.returnValue)) {\n            t: {\n              var i = !1;\n              if (0 == n.keyCode) try {\n                n.keyCode = -1;\n                break t;\n              } catch (t) {\n                i = !0;\n              }\n              (i || void 0 == n.returnValue) && (n.returnValue = !0);\n            }\n\n            for (n = [], i = e.currentTarget; i; i = i.parentNode) {\n              n.push(i);\n            }\n\n            for (t = t.type, i = n.length - 1; !e.Ea && 0 <= i; i--) {\n              e.currentTarget = n[i];\n              var o = Ft(n[i], t, !0, e);\n              r = r && o;\n            }\n\n            for (i = 0; !e.Ea && i < n.length; i++) {\n              e.currentTarget = n[i], o = Ft(n[i], t, !1, e), r = r && o;\n            }\n          }\n\n          return r;\n        }\n\n        return Bt(t, new Tt(e, this));\n      }\n\n      function Vt(t) {\n        return (t = t[Mt]) instanceof kt ? t : null;\n      }\n\n      var Qt = \"__closure_events_fn_\" + (1e9 * Math.random() >>> 0);\n\n      function Kt(t) {\n        return b(t) ? t : (t[Qt] || (t[Qt] = function (e) {\n          return t.handleEvent(e);\n        }), t[Qt]);\n      }\n\n      function Wt() {\n        M.call(this), this.ka = new kt(this), this.Pe = this, this.Uc = null;\n      }\n\n      A(Wt, M), Wt.prototype[Ct] = !0, (c = Wt.prototype).addEventListener = function (t, e, n, r) {\n        _t(this, t, e, n, r);\n      }, c.removeEventListener = function (t, e, n, r) {\n        !function t(e, n, r, i, o) {\n          if (g(n)) for (var s = 0; s < n.length; s++) {\n            t(e, n[s], r, i, o);\n          } else i = w(i) ? !!i.capture : !!i, r = Kt(r), Dt(e) ? e.ed(n, r, i, o) : e && (e = Vt(e)) && (n = e.jb(n, r, i, o)) && xt(n);\n        }(this, t, e, n, r);\n      }, c.dispatchEvent = function (t) {\n        var e,\n            n = this.Uc;\n        if (n) for (e = []; n; n = n.Uc) {\n          e.push(n);\n        }\n        n = this.Pe;\n        var r = t.type || t;\n        if (d(t)) t = new St(t, n);else if (t instanceof St) t.target = t.target || n;else {\n          var i = t;\n          tt(t = new St(r, n), i);\n        }\n        if (i = !0, e) for (var o = e.length - 1; !t.Ea && 0 <= o; o--) {\n          var s = t.currentTarget = e[o];\n          i = s.Lb(r, !0, t) && i;\n        }\n        if (t.Ea || (i = (s = t.currentTarget = n).Lb(r, !0, t) && i, t.Ea || (i = s.Lb(r, !1, t) && i)), e) for (o = 0; !t.Ea && o < e.length; o++) {\n          i = (s = t.currentTarget = e[o]).Lb(r, !1, t) && i;\n        }\n        return i;\n      }, c.F = function () {\n        Wt.L.F.call(this), this.pg(), this.Uc = null;\n      }, c.nb = function (t, e, n, r) {\n        return this.ka.add(String(t), e, !1, n, r);\n      }, c.Oc = function (t, e, n, r) {\n        return this.ka.add(String(t), e, !0, n, r);\n      }, c.ed = function (t, e, n, r) {\n        this.ka.remove(String(t), e, n, r);\n      }, c.Le = function (t) {\n        this.ka.ye(t);\n      }, c.pg = function () {\n        this.ka && this.ka.pb(void 0);\n      }, c.Lb = function (t, e, n) {\n        if (!(t = this.ka.J[String(t)])) return !0;\n        t = t.concat();\n\n        for (var r = !0, i = 0; i < t.length; ++i) {\n          var o = t[i];\n\n          if (o && !o.Sa && o.capture == e) {\n            var s = o.listener,\n                a = o.Ob || o.src;\n            o.Eb && this.Le(o), r = !1 !== s.call(a, n) && r;\n          }\n        }\n\n        return r && 0 != n.Be;\n      }, c.jb = function (t, e, n, r) {\n        return this.ka.jb(String(t), e, n, r);\n      };\n      var jt = f.JSON.stringify;\n\n      function zt(t, e) {\n        this.Sf = 100, this.ef = t, this.ug = e, this.Zb = 0, this.Pb = null;\n      }\n\n      function Gt() {\n        this.lc = this.Va = null;\n      }\n\n      zt.prototype.get = function () {\n        if (0 < this.Zb) {\n          this.Zb--;\n          var t = this.Pb;\n          this.Pb = t.next, t.next = null;\n        } else t = this.ef();\n\n        return t;\n      }, zt.prototype.put = function (t) {\n        this.ug(t), this.Zb < this.Sf && (this.Zb++, t.next = this.Pb, this.Pb = t);\n      };\n      var Ht,\n          Xt,\n          Yt = new zt(function () {\n        return new Jt();\n      }, function (t) {\n        t.reset();\n      });\n\n      function Jt() {\n        this.next = this.scope = this.Gc = null;\n      }\n\n      function Zt(t) {\n        f.setTimeout(function () {\n          throw t;\n        }, 0);\n      }\n\n      function $t() {\n        if (f.Promise && f.Promise.resolve) {\n          var t = f.Promise.resolve(void 0);\n\n          Xt = function Xt() {\n            t.then(ne);\n          };\n        } else Xt = function Xt() {\n          var t = ne;\n          !b(f.setImmediate) || f.Window && f.Window.prototype && !H(\"Edge\") && f.Window.prototype.setImmediate == f.setImmediate ? (Ht || (Ht = function () {\n            var t = f.MessageChannel;\n\n            if (void 0 === t && \"undefined\" != typeof window && window.postMessage && window.addEventListener && !H(\"Presto\") && (t = function t() {\n              var t = document.createElement(\"IFRAME\");\n              t.style.display = \"none\", t.src = \"\", document.documentElement.appendChild(t);\n              var e = t.contentWindow;\n              (t = e.document).open(), t.write(\"\"), t.close();\n              var n = \"callImmediate\" + Math.random(),\n                  r = \"file:\" == e.location.protocol ? \"*\" : e.location.protocol + \"//\" + e.location.host;\n              t = C(function (t) {\n                \"*\" != r && t.origin != r || t.data != n || this.port1.onmessage();\n              }, this), e.addEventListener(\"message\", t, !1), this.port1 = {}, this.port2 = {\n                postMessage: function postMessage() {\n                  e.postMessage(n, r);\n                }\n              };\n            }), void 0 !== t && !H(\"Trident\") && !H(\"MSIE\")) {\n              var e = new t(),\n                  n = {},\n                  r = n;\n              return e.port1.onmessage = function () {\n                if (void 0 !== n.next) {\n                  var t = (n = n.next).rd;\n                  n.rd = null, t();\n                }\n              }, function (t) {\n                r.next = {\n                  rd: t\n                }, r = r.next, e.port2.postMessage(0);\n              };\n            }\n\n            return \"undefined\" != typeof document && \"onreadystatechange\" in document.createElement(\"SCRIPT\") ? function (t) {\n              var e = document.createElement(\"SCRIPT\");\n              e.onreadystatechange = function () {\n                e.onreadystatechange = null, e.parentNode.removeChild(e), e = null, t(), t = null;\n              }, document.documentElement.appendChild(e);\n            } : function (t) {\n              f.setTimeout(t, 0);\n            };\n          }()), Ht(t)) : f.setImmediate(t);\n        };\n      }\n\n      Gt.prototype.add = function (t, e) {\n        var n = this.Af();\n        n.set(t, e), this.lc ? this.lc.next = n : this.Va = n, this.lc = n;\n      }, Gt.prototype.remove = function () {\n        var t = null;\n        return this.Va && (t = this.Va, this.Va = this.Va.next, this.Va || (this.lc = null), t.next = null), t;\n      }, Gt.prototype.wg = function (t) {\n        Yt.put(t);\n      }, Gt.prototype.Af = function () {\n        return Yt.get();\n      }, Jt.prototype.set = function (t, e) {\n        this.Gc = t, this.scope = e, this.next = null;\n      }, Jt.prototype.reset = function () {\n        this.next = this.scope = this.Gc = null;\n      };\n      var te = !1,\n          ee = new Gt();\n\n      function ne() {\n        for (var t; t = ee.remove();) {\n          try {\n            t.Gc.call(t.scope);\n          } catch (t) {\n            Zt(t);\n          }\n\n          ee.wg(t);\n        }\n\n        te = !1;\n      }\n\n      function re(t, e) {\n        Wt.call(this), this.Na = t || 1, this.wb = e || f, this.nd = C(this.Rg, this), this.ie = N();\n      }\n\n      function ie(t, e, n) {\n        if (b(t)) n && (t = C(t, n));else {\n          if (!t || \"function\" != typeof t.handleEvent) throw Error(\"Invalid listener argument\");\n          t = C(t.handleEvent, t);\n        }\n        return 2147483647 < Number(e) ? -1 : f.setTimeout(t, e || 0);\n      }\n\n      function oe(t, e, n) {\n        M.call(this), this.Uf = null != n ? C(t, n) : t, this.Na = e, this.Xe = C(this.fg, this), this.qc = [];\n      }\n\n      function se(t) {\n        M.call(this), this.i = t, this.o = {};\n      }\n\n      A(re, Wt), (c = re.prototype).enabled = !1, c.B = null, c.setInterval = function (t) {\n        this.Na = t, this.B && this.enabled ? (this.stop(), this.start()) : this.B && this.stop();\n      }, c.Rg = function () {\n        if (this.enabled) {\n          var t = N() - this.ie;\n          0 < t && t < .8 * this.Na ? this.B = this.wb.setTimeout(this.nd, this.Na - t) : (this.B && (this.wb.clearTimeout(this.B), this.B = null), this.ff(), this.enabled && (this.stop(), this.start()));\n        }\n      }, c.ff = function () {\n        this.dispatchEvent(\"tick\");\n      }, c.start = function () {\n        this.enabled = !0, this.B || (this.B = this.wb.setTimeout(this.nd, this.Na), this.ie = N());\n      }, c.stop = function () {\n        this.enabled = !1, this.B && (this.wb.clearTimeout(this.B), this.B = null);\n      }, c.F = function () {\n        re.L.F.call(this), this.stop(), delete this.wb;\n      }, A(oe, M), (c = oe.prototype).Ta = !1, c.ob = 0, c.B = null, c.mf = function (t) {\n        this.qc = arguments, this.B || this.ob ? this.Ta = !0 : this.Cc();\n      }, c.stop = function () {\n        this.B && (f.clearTimeout(this.B), this.B = null, this.Ta = !1, this.qc = []);\n      }, c.pause = function () {\n        this.ob++;\n      }, c.resume = function () {\n        this.ob--, this.ob || !this.Ta || this.B || (this.Ta = !1, this.Cc());\n      }, c.F = function () {\n        oe.L.F.call(this), this.stop();\n      }, c.fg = function () {\n        this.B = null, this.Ta && !this.ob && (this.Ta = !1, this.Cc());\n      }, c.Cc = function () {\n        this.B = ie(this.Xe, this.Na), this.Uf.apply(null, this.qc);\n      }, A(se, M);\n      var ae = [];\n\n      function ue(t, e, n) {\n        this.reset(t, e, n, void 0, void 0);\n      }\n\n      function ce(t) {\n        this.pe = t, this.Zd = this.uc = this.mb = this.$b = null;\n      }\n\n      function he(t, e) {\n        this.name = t, this.value = e;\n      }\n\n      (c = se.prototype).nb = function (t, e, n, r) {\n        return this.Tf(t, e, n, r);\n      }, c.Tf = function (t, e, n, r) {\n        g(e) || (e && (ae[0] = e.toString()), e = ae);\n\n        for (var i = 0; i < e.length; i++) {\n          var o = _t(t, e[i], n || this.handleEvent, r || !1, this.i || this);\n\n          if (!o) break;\n          this.o[o.key] = o;\n        }\n\n        return this;\n      }, c.Oc = function (t, e, n, r) {\n        return this.je(t, e, n, r);\n      }, c.je = function (t, e, n, r, i) {\n        if (g(e)) for (var o = 0; o < e.length; o++) {\n          this.je(t, e[o], n, r, i);\n        } else {\n          if (!(t = Lt(t, e, n || this.handleEvent, r, i || this.i || this))) return this;\n          this.o[t.key] = t;\n        }\n        return this;\n      }, c.ed = function (t, e, n, r, i) {\n        if (g(e)) for (var o = 0; o < e.length; o++) {\n          this.ed(t, e[o], n, r, i);\n        } else n = n || this.handleEvent, r = w(r) ? !!r.capture : !!r, i = i || this.i || this, n = Kt(n), r = !!r, (e = Dt(t) ? t.jb(e, n, r, i) : t && (t = Vt(t)) ? t.jb(e, n, r, i) : null) && (xt(e), delete this.o[e.key]);\n      }, c.pb = function () {\n        X(this.o, function (t, e) {\n          this.o.hasOwnProperty(e) && xt(t);\n        }, this), this.o = {};\n      }, c.F = function () {\n        se.L.F.call(this), this.pb();\n      }, c.handleEvent = function () {\n        throw Error(\"EventHandler.handleEvent not implemented\");\n      }, ue.prototype.Md = null, ue.prototype.reset = function (t, e, n, r, i) {\n        this.mb = t, delete this.Md;\n      }, ue.prototype.Bg = function (t) {\n        this.Md = t;\n      }, ue.prototype.Ge = function (t) {\n        this.mb = t;\n      }, he.prototype.toString = function () {\n        return this.name;\n      };\n      var le = new he(\"SEVERE\", 1e3),\n          fe = new he(\"WARNING\", 900),\n          de = new he(\"INFO\", 800),\n          pe = new he(\"CONFIG\", 700),\n          me = new he(\"FINE\", 500);\n      (c = ce.prototype).getName = function () {\n        return this.pe;\n      }, c.getParent = function () {\n        return this.$b;\n      }, c.pf = function () {\n        return this.uc || (this.uc = {}), this.uc;\n      }, c.Ge = function (t) {\n        this.mb = t;\n      }, c.Qd = function () {\n        return this.mb ? this.mb : this.$b ? this.$b.Qd() : (function (t, e) {\n          throw new R(\"Failure\" + (t ? \": \" + t : \"\"), Array.prototype.slice.call(arguments, 1));\n        }(\"Root logger has no level set.\"), null);\n      }, c.Pf = function (t) {\n        return t.value >= this.Qd().value;\n      }, c.log = function (t, e, n) {\n        this.Pf(t) && (b(e) && (e = e()), this.gf(this.uf(t, e, n)));\n      }, c.uf = function (t, e, n) {\n        return t = new ue(t, String(e), this.pe), n && t.Bg(n), t;\n      }, c.ca = function (t, e) {\n        this.log(le, t, e);\n      }, c.T = function (t, e) {\n        this.log(fe, t, e);\n      }, c.info = function (t, e) {\n        this.log(de, t, e);\n      }, c.lf = function (t) {\n        this.log(me, t, void 0);\n      }, c.gf = function (t) {\n        for (var e = this; e;) {\n          e.We(t), e = e.getParent();\n        }\n      }, c.We = function (t) {\n        if (this.Zd) for (var e, n = 0; e = this.Zd[n]; n++) {\n          e(t);\n        }\n      }, c.Fg = function (t) {\n        this.$b = t;\n      }, c.Qe = function (t, e) {\n        this.pf()[t] = e;\n      };\n      var ye = {},\n          ge = null;\n\n      function ve(t) {\n        var e;\n\n        if (ge || (ge = new ce(\"\"), ye[\"\"] = ge, ge.Ge(pe)), !(e = ye[t])) {\n          e = new ce(t);\n          var n = t.lastIndexOf(\".\"),\n              r = t.substr(n + 1);\n          (n = ve(t.substr(0, n))).Qe(r, e), e.Fg(n), ye[t] = e;\n        }\n\n        return e;\n      }\n\n      function be(t, e) {\n        t && t.info(e, void 0);\n      }\n\n      function we(t, e) {\n        t && t.lf(e);\n      }\n\n      function Ee() {\n        this.s = ve(\"goog.labs.net.webChannel.WebChannelDebug\"), this.Wc = !0;\n      }\n\n      (c = Ee.prototype).Id = function () {\n        this.Wc = !1;\n      }, c.Tg = function (t, e, n, r, i) {\n        var o = this;\n        this.info(function () {\n          return \"XMLHTTP REQ (\" + n + \") [attempt \" + r + \"]: \" + t + \"\\n\" + e + \"\\n\" + o.Xf(i);\n        });\n      }, c.Ug = function (t, e, n, r, i, o) {\n        this.info(function () {\n          return \"XMLHTTP RESP (\" + n + \") [ attempt \" + r + \"]: \" + t + \"\\n\" + e + \"\\n\" + i + \" \" + o;\n        });\n      }, c.Wa = function (t, e, n) {\n        var r = this;\n        this.info(function () {\n          return \"XMLHTTP TEXT (\" + t + \"): \" + r.ng(e) + (n ? \" \" + n : \"\");\n        });\n      }, c.Sg = function (t) {\n        this.info(function () {\n          return \"TIMEOUT: \" + t;\n        });\n      }, c.debug = function (t) {\n        we(this.s, t);\n      }, c.cb = function (t, e) {\n        var n = this.s;\n        n && n.ca(e || \"Exception\", t);\n      }, c.info = function (t) {\n        be(this.s, t);\n      }, c.T = function (t) {\n        var e = this.s;\n        e && e.T(t, void 0);\n      }, c.ca = function (t) {\n        var e = this.s;\n        e && e.ca(t, void 0);\n      }, c.ng = function (t) {\n        if (!this.Wc) return t;\n        if (!t) return null;\n\n        try {\n          var e = JSON.parse(t);\n          if (e) for (var n = 0; n < e.length; n++) {\n            g(e[n]) && this.Wf(e[n]);\n          }\n          return jt(e);\n        } catch (e) {\n          return this.debug(\"Exception parsing expected JS array - probably was not JS\"), t;\n        }\n      }, c.Wf = function (t) {\n        if (!(2 > t.length || (t = t[1], !g(t) || 1 > t.length))) {\n          var e = t[0];\n          if (\"noop\" != e && \"stop\" != e && \"close\" != e) for (e = 1; e < t.length; e++) {\n            t[e] = \"\";\n          }\n        }\n      }, c.Xf = function (t) {\n        if (!this.Wc) return t;\n        if (!t) return null;\n        var e = \"\";\n        t = t.split(\"&\");\n\n        for (var n = 0; n < t.length; n++) {\n          var r = t[n].split(\"=\");\n\n          if (1 < r.length) {\n            var i = r[0];\n            r = r[1];\n            var o = i.split(\"_\");\n            e = 2 <= o.length && \"type\" == o[1] ? e + (i + \"=\") + r + \"&\" : e + (i + \"=redacted&\");\n          }\n        }\n\n        return e;\n      };\n      var Se = new Wt();\n\n      function Te(t) {\n        St.call(this, \"serverreachability\", t);\n      }\n\n      function Ie(t) {\n        Se.dispatchEvent(new Te(Se, t));\n      }\n\n      function Ce(t, e) {\n        St.call(this, \"statevent\", t), this.stat = e;\n      }\n\n      function De(t) {\n        Se.dispatchEvent(new Ce(Se, t));\n      }\n\n      function Ne(t, e, n) {\n        St.call(this, \"timingevent\", t), this.size = e, this.rtt = n;\n      }\n\n      function Ae(t, e) {\n        if (!b(t)) throw Error(\"Fn must not be null and must be a function\");\n        return f.setTimeout(function () {\n          t();\n        }, e);\n      }\n\n      A(Te, St), A(Ce, St), A(Ne, St);\n      var ke = {\n        NO_ERROR: 0,\n        Vg: 1,\n        bh: 2,\n        ah: 3,\n        Yg: 4,\n        $g: 5,\n        dh: 6,\n        Ne: 7,\n        TIMEOUT: 8,\n        gh: 9\n      },\n          Re = {\n        Xg: \"complete\",\n        kh: \"success\",\n        Oe: \"error\",\n        Ne: \"abort\",\n        ih: \"ready\",\n        jh: \"readystatechange\",\n        TIMEOUT: \"timeout\",\n        eh: \"incrementaldata\",\n        hh: \"progress\",\n        Zg: \"downloadprogress\",\n        lh: \"uploadprogress\"\n      };\n\n      function Me() {}\n\n      function Oe() {}\n\n      Me.prototype.pd = null, Me.prototype.Vd = function () {\n        return this.pd || (this.pd = this.Mf());\n      };\n\n      var _e,\n          Pe = {\n        OPEN: \"a\",\n        Wg: \"b\",\n        Oe: \"c\",\n        fh: \"d\"\n      };\n\n      function Le() {\n        St.call(this, \"d\");\n      }\n\n      function xe() {\n        St.call(this, \"c\");\n      }\n\n      function qe() {}\n\n      function Fe(t, e, n, r, i) {\n        this.b = t, this.a = e, this.ra = n, this.R = r, this.Xc = i || 1, this.Fc = new se(this), this.Ua = Be, t = at ? 125 : void 0, this.Vc = new re(t), this.A = null, this.S = !1, this.Da = this.pa = this.ua = this.ic = this.qb = this.hd = this.Ga = null, this.ba = [], this.h = null, this.Bb = 0, this.I = this.Fa = null, this.w = -1, this.Za = !1, this.Ra = 0, this.ac = null, this.lb = this.Ed = this.yc = !1;\n      }\n\n      A(Le, St), A(xe, St), A(qe, Me), qe.prototype.Dd = function () {\n        var t = this.Wd();\n        return t ? new ActiveXObject(t) : new XMLHttpRequest();\n      }, qe.prototype.Mf = function () {\n        var t = {};\n        return this.Wd() && (t[0] = !0, t[1] = !0), t;\n      }, qe.prototype.Wd = function () {\n        if (!this.be && \"undefined\" == typeof XMLHttpRequest && \"undefined\" != typeof ActiveXObject) {\n          for (var t = [\"MSXML2.XMLHTTP.6.0\", \"MSXML2.XMLHTTP.3.0\", \"MSXML2.XMLHTTP\", \"Microsoft.XMLHTTP\"], e = 0; e < t.length; e++) {\n            var n = t[e];\n\n            try {\n              return new ActiveXObject(n), this.be = n;\n            } catch (t) {}\n          }\n\n          throw Error(\"Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed\");\n        }\n\n        return this.be;\n      }, _e = new qe();\n      var Be = 45e3;\n      var Ue = {},\n          Ve = {};\n\n      function Qe(t) {\n        if (t.H && \"function\" == typeof t.H) return t.H();\n        if (d(t)) return t.split(\"\");\n\n        if (v(t)) {\n          for (var e = [], n = t.length, r = 0; r < n; r++) {\n            e.push(t[r]);\n          }\n\n          return e;\n        }\n\n        return Y(t);\n      }\n\n      function Ke(t, e, n) {\n        if (t.forEach && \"function\" == typeof t.forEach) t.forEach(e, n);else if (v(t) || d(t)) x(t, e, n);else {\n          if (t.W && \"function\" == typeof t.W) var r = t.W();else if (t.H && \"function\" == typeof t.H) r = void 0;else if (v(t) || d(t)) {\n            r = [];\n\n            for (var i = t.length, o = 0; o < i; o++) {\n              r.push(o);\n            }\n          } else r = J(t);\n          o = (i = Qe(t)).length;\n\n          for (var s = 0; s < o; s++) {\n            e.call(n, i[s], r && r[s], t);\n          }\n        }\n      }\n\n      function We(t, e) {\n        this.D = {}, this.o = [], this.j = 0;\n        var n = arguments.length;\n\n        if (1 < n) {\n          if (n % 2) throw Error(\"Uneven number of arguments\");\n\n          for (var r = 0; r < n; r += 2) {\n            this.set(arguments[r], arguments[r + 1]);\n          }\n        } else t && this.addAll(t);\n      }\n\n      function je(t, e) {\n        return Object.prototype.hasOwnProperty.call(t, e);\n      }\n\n      (c = Fe.prototype).ga = function (t) {\n        this.A = t;\n      }, c.setTimeout = function (t) {\n        this.Ua = t;\n      }, c.He = function (t) {\n        this.Ra = t;\n      }, c.Gg = function (t) {\n        this.ba = t;\n      }, c.la = function () {\n        return this.ba;\n      }, c.kd = function (t, e) {\n        this.ic = 1, this.ua = t.clone().Ub(), this.Da = e, this.yc = !0, this.Ce(null);\n      }, c.jd = function (t, e, n) {\n        this.ic = 1, this.ua = t.clone().Ub(), this.Da = null, this.yc = e, this.Ce(n);\n      }, c.Ce = function (t) {\n        this.qb = N(), this.eb(), this.pa = this.ua.clone(), this.pa.dc(\"t\", this.Xc), this.Bb = 0, this.h = this.b.Jb(this.b.fc() ? t : null), 0 < this.Ra && (this.ac = new oe(C(this.Me, this, this.h), this.Ra)), this.Fc.nb(this.h, \"readystatechange\", this.mg), t = this.A ? Z(this.A) : {}, this.Da ? (this.Fa || (this.Fa = \"POST\"), t[\"Content-Type\"] = \"application/x-www-form-urlencoded\", this.h.send(this.pa, this.Fa, this.Da, t)) : (this.Fa = \"GET\", this.h.send(this.pa, this.Fa, null, t)), Ie(1), this.a.Tg(this.Fa, this.pa, this.R, this.Xc, this.Da);\n      }, c.mg = function (t) {\n        t = t.target;\n        var e = this.ac;\n        e && 3 == t.ma() ? (this.a.debug(\"Throttling readystatechange.\"), e.mf()) : this.Me(t);\n      }, c.Me = function (t) {\n        try {\n          t == this.h ? this.hg() : this.a.T(\"Called back with an unexpected xmlhttp\");\n        } catch (t) {\n          if (this.a.debug(\"Failed call to OnXmlHttpReadyStateChanged_\"), this.h && this.h.ya()) {\n            var e = this;\n            this.a.cb(t, function () {\n              return \"ResponseText: \" + e.h.ya();\n            });\n          } else this.a.cb(t, \"No response text\");\n        }\n      }, c.hg = function () {\n        var t = this.h.ma(),\n            e = this.h.Ud(),\n            n = this.h.za();\n\n        if (!(3 > t || 3 == t && !at && !this.h.ya())) {\n          this.Za || 4 != t || 7 == e || Ie(8 == e || 0 >= n ? 3 : 2), this.Fb();\n          var r = this.h.za();\n\n          if (this.w = r, !(e = this.h.ya())) {\n            var i = this;\n            this.a.debug(function () {\n              return \"No response text for uri \" + i.pa + \" status \" + r;\n            });\n          }\n\n          if (this.S = 200 == r, this.a.Ug(this.Fa, this.pa, this.R, this.Xc, t, r), this.S) {\n            if (this.Ig()) {\n              if (!(n = this.sf())) return this.S = !1, this.I = 3, De(12), this.a.T(\"XMLHTTP Missing X_HTTP_INITIAL_RESPONSE (\" + this.R + \")\"), this.Ia(), void this.Kb();\n              this.a.Wa(this.R, n, \"Initial handshake response via X-HTTP-Initial-Response\"), this.lb = !0, this.Yc(n);\n            }\n\n            this.yc ? (this.Fd(t, e), at && this.S && 3 == t && this.Ng()) : (this.a.Wa(this.R, e, null), this.Yc(e)), 4 == t && this.Ia(), this.S && !this.Za && (4 == t ? this.b.Tc(this) : (this.S = !1, this.eb()));\n          } else 400 == r && 0 < e.indexOf(\"Unknown SID\") ? (this.I = 3, De(12), this.a.T(\"XMLHTTP Unknown SID (\" + this.R + \")\")) : (this.I = 0, De(13), this.a.T(\"XMLHTTP Bad status \" + r + \" (\" + this.R + \")\")), this.Ia(), this.Kb();\n        }\n      }, c.Ig = function () {\n        return this.Ed && !this.lb;\n      }, c.sf = function () {\n        if (this.h) {\n          var t = this.h.kb(\"X-HTTP-Initial-Response\");\n          if (t && !Q(t)) return t;\n        }\n\n        return null;\n      }, c.Ag = function () {\n        this.Ed = !0;\n      }, c.Fd = function (t, e) {\n        for (var n = !0; !this.Za && this.Bb < e.length;) {\n          var r = this.vf(e);\n\n          if (r == Ve) {\n            4 == t && (this.I = 4, De(14), n = !1), this.a.Wa(this.R, null, \"[Incomplete Response]\");\n            break;\n          }\n\n          if (r == Ue) {\n            this.I = 4, De(15), this.a.Wa(this.R, e, \"[Invalid Chunk]\"), n = !1;\n            break;\n          }\n\n          this.a.Wa(this.R, r, null), this.Yc(r);\n        }\n\n        4 == t && 0 == e.length && (this.I = 1, De(16), n = !1), this.S = this.S && n, n || (this.a.Wa(this.R, e, \"[Invalid Chunked Response]\"), this.Ia(), this.Kb());\n      }, c.kg = function () {\n        if (this.h) {\n          var t = this.h.ma(),\n              e = this.h.ya();\n          this.Bb < e.length && (this.Fb(), this.Fd(t, e), this.S && 4 != t && this.eb());\n        }\n      }, c.Ng = function () {\n        this.Fc.nb(this.Vc, \"tick\", this.kg), this.Vc.start();\n      }, c.vf = function (t) {\n        var e = this.Bb,\n            n = t.indexOf(\"\\n\", e);\n        return -1 == n ? Ve : (e = Number(t.substring(e, n)), isNaN(e) ? Ue : (n += 1) + e > t.length ? Ve : (t = t.substr(n, e), this.Bb = n + e, t));\n      }, c.yg = function (t) {\n        this.ic = 2, this.ua = t.clone().Ub(), t = !1, f.navigator && f.navigator.sendBeacon && (t = f.navigator.sendBeacon(this.ua.toString(), \"\")), !t && f.Image && (new Image().src = this.ua, t = !0), t || (this.h = this.b.Jb(null), this.h.send(this.ua)), this.qb = N(), this.eb();\n      }, c.cancel = function () {\n        this.Za = !0, this.Ia();\n      }, c.tg = function (t) {\n        t && this.setTimeout(t), this.Ga && (this.Fb(), this.eb());\n      }, c.eb = function () {\n        this.hd = N() + this.Ua, this.Ke(this.Ua);\n      }, c.Ke = function (t) {\n        if (null != this.Ga) throw Error(\"WatchDog timer not null\");\n        this.Ga = Ae(C(this.gg, this), t);\n      }, c.Fb = function () {\n        this.Ga && (f.clearTimeout(this.Ga), this.Ga = null);\n      }, c.gg = function () {\n        this.Ga = null;\n        var t = N();\n        0 <= t - this.hd ? this.Df() : (this.a.T(\"WatchDog timer called too early\"), this.Ke(this.hd - t));\n      }, c.Df = function () {\n        this.S && this.a.ca(\"Received watchdog timeout even though request loaded successfully\"), this.a.Sg(this.pa), 2 != this.ic && (Ie(3), De(17)), this.Ia(), this.I = 2, this.Kb();\n      }, c.Kb = function () {\n        this.b.de() || this.Za || this.b.Tc(this);\n      }, c.Ia = function () {\n        this.Fb();\n        var t = this.ac;\n        t && \"function\" == typeof t.bb && t.bb(), this.ac = null, this.Vc.stop(), this.Fc.pb(), this.h && (t = this.h, this.h = null, t.abort(), t.bb());\n      }, c.Hc = function () {\n        return this.I;\n      }, c.Yc = function (t) {\n        try {\n          this.b.ue(this, t), Ie(4);\n        } catch (t) {\n          this.a.cb(t, \"Error in httprequest callback\");\n        }\n      }, (c = We.prototype).C = function () {\n        return this.j;\n      }, c.H = function () {\n        this.wc();\n\n        for (var t = [], e = 0; e < this.o.length; e++) {\n          t.push(this.D[this.o[e]]);\n        }\n\n        return t;\n      }, c.W = function () {\n        return this.wc(), this.o.concat();\n      }, c.va = function (t) {\n        return je(this.D, t);\n      }, c.X = function () {\n        return 0 == this.j;\n      }, c.clear = function () {\n        this.D = {}, this.j = this.o.length = 0;\n      }, c.remove = function (t) {\n        return !!je(this.D, t) && (delete this.D[t], this.j--, this.o.length > 2 * this.j && this.wc(), !0);\n      }, c.wc = function () {\n        if (this.j != this.o.length) {\n          for (var t = 0, e = 0; t < this.o.length;) {\n            var n = this.o[t];\n            je(this.D, n) && (this.o[e++] = n), t++;\n          }\n\n          this.o.length = e;\n        }\n\n        if (this.j != this.o.length) {\n          var r = {};\n\n          for (e = t = 0; t < this.o.length;) {\n            je(r, n = this.o[t]) || (this.o[e++] = n, r[n] = 1), t++;\n          }\n\n          this.o.length = e;\n        }\n      }, c.get = function (t, e) {\n        return je(this.D, t) ? this.D[t] : e;\n      }, c.set = function (t, e) {\n        je(this.D, t) || (this.j++, this.o.push(t)), this.D[t] = e;\n      }, c.addAll = function (t) {\n        if (t instanceof We) for (var e = t.W(), n = 0; n < e.length; n++) {\n          this.set(e[n], t.get(e[n]));\n        } else for (e in t) {\n          this.set(e, t[e]);\n        }\n      }, c.forEach = function (t, e) {\n        for (var n = this.W(), r = 0; r < n.length; r++) {\n          var i = n[r],\n              o = this.get(i);\n          t.call(e, o, i, this);\n        }\n      }, c.clone = function () {\n        return new We(this);\n      };\n      var ze = /^(?:([^:/?#.]+):)?(?:\\/\\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$/;\n\n      function Ge(t, e) {\n        var n;\n        this.xa = this.zb = this.qa = \"\", this.Ca = null, this.ib = this.K = \"\", this.O = this.Qf = !1, t instanceof Ge ? (this.O = void 0 !== e ? e : t.O, this.tb(t.qa), this.cd(t.zb), this.rb(t.xa), this.sb(t.Ca), this.ec(t.K), this.bd(t.P.clone()), this.$c(t.ib)) : t && (n = String(t).match(ze)) ? (this.O = !!e, this.tb(n[1] || \"\", !0), this.cd(n[2] || \"\", !0), this.rb(n[3] || \"\", !0), this.sb(n[4]), this.ec(n[5] || \"\", !0), this.bd(n[6] || \"\", !0), this.$c(n[7] || \"\", !0)) : (this.O = !!e, this.P = new nn(null, this.O));\n      }\n\n      function He(t, e) {\n        return t ? e ? decodeURI(t.replace(/%25/g, \"%2525\")) : decodeURIComponent(t) : \"\";\n      }\n\n      function Xe(t, e, n) {\n        return d(t) ? (t = encodeURI(t).replace(e, Ye), n && (t = t.replace(/%25([0-9a-fA-F]{2})/g, \"%$1\")), t) : null;\n      }\n\n      function Ye(t) {\n        return \"%\" + ((t = t.charCodeAt(0)) >> 4 & 15).toString(16) + (15 & t).toString(16);\n      }\n\n      (c = Ge.prototype).toString = function () {\n        var t = [],\n            e = this.qa;\n        e && t.push(Xe(e, Je, !0), \":\");\n        var n = this.xa;\n        return (n || \"file\" == e) && (t.push(\"//\"), (e = this.zb) && t.push(Xe(e, Je, !0), \"@\"), t.push(encodeURIComponent(String(n)).replace(/%25([0-9a-fA-F]{2})/g, \"%$1\")), null != (n = this.Ca) && t.push(\":\", String(n))), (n = this.K) && (this.Ic() && \"/\" != n.charAt(0) && t.push(\"/\"), t.push(Xe(n, \"/\" == n.charAt(0) ? $e : Ze, !0))), (n = this.Rd()) && t.push(\"?\", n), (n = this.ib) && t.push(\"#\", Xe(n, en)), t.join(\"\");\n      }, c.resolve = function (t) {\n        var e = this.clone(),\n            n = t.Hf();\n        n ? e.tb(t.qa) : n = t.If(), n ? e.cd(t.zb) : n = t.Ic(), n ? e.rb(t.xa) : n = t.Ff();\n        var r = t.K;\n        if (n) e.sb(t.Ca);else if (n = t.ae()) {\n          if (\"/\" != r.charAt(0)) if (this.Ic() && !this.ae()) r = \"/\" + r;else {\n            var i = e.K.lastIndexOf(\"/\");\n            -1 != i && (r = e.K.substr(0, i + 1) + r);\n          }\n          if (\"..\" == (i = r) || \".\" == i) r = \"\";else if (-1 != i.indexOf(\"./\") || -1 != i.indexOf(\"/.\")) {\n            r = 0 == i.lastIndexOf(\"/\", 0), i = i.split(\"/\");\n\n            for (var o = [], s = 0; s < i.length;) {\n              var a = i[s++];\n              \".\" == a ? r && s == i.length && o.push(\"\") : \"..\" == a ? ((1 < o.length || 1 == o.length && \"\" != o[0]) && o.pop(), r && s == i.length && o.push(\"\")) : (o.push(a), r = !0);\n            }\n\n            r = o.join(\"/\");\n          } else r = i;\n        }\n        return n ? e.ec(r) : n = t.Gf(), n ? e.bd(t.P.clone()) : n = t.Ef(), n && e.$c(t.ib), e;\n      }, c.clone = function () {\n        return new Ge(this);\n      }, c.tb = function (t, e) {\n        this.U(), (this.qa = e ? He(t, !0) : t) && (this.qa = this.qa.replace(/:$/, \"\"));\n      }, c.Hf = function () {\n        return !!this.qa;\n      }, c.cd = function (t, e) {\n        this.U(), this.zb = e ? He(t) : t;\n      }, c.If = function () {\n        return !!this.zb;\n      }, c.rb = function (t, e) {\n        this.U(), this.xa = e ? He(t, !0) : t;\n      }, c.Ic = function () {\n        return !!this.xa;\n      }, c.sb = function (t) {\n        if (this.U(), t) {\n          if (t = Number(t), isNaN(t) || 0 > t) throw Error(\"Bad port number \" + t);\n          this.Ca = t;\n        } else this.Ca = null;\n      }, c.Ff = function () {\n        return null != this.Ca;\n      }, c.ec = function (t, e) {\n        this.U(), this.K = e ? He(t, !0) : t;\n      }, c.ae = function () {\n        return !!this.K;\n      }, c.Gf = function () {\n        return \"\" !== this.P.toString();\n      }, c.bd = function (t, e) {\n        this.U(), t instanceof nn ? (this.P = t, this.P.ad(this.O)) : (e || (t = Xe(t, tn)), this.P = new nn(t, this.O));\n      }, c.Rd = function () {\n        return this.P.toString();\n      }, c.getQuery = function () {\n        return this.Rd();\n      }, c.l = function (t, e) {\n        this.U(), this.P.set(t, e);\n      }, c.dc = function (t, e) {\n        this.U(), g(e) || (e = [String(e)]), this.P.Ie(t, e);\n      }, c.$c = function (t, e) {\n        this.U(), this.ib = e ? He(t) : t;\n      }, c.Ef = function () {\n        return !!this.ib;\n      }, c.Ub = function () {\n        return this.U(), this.l(\"zx\", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ N()).toString(36)), this;\n      }, c.removeParameter = function (t) {\n        return this.U(), this.P.remove(t), this;\n      }, c.U = function () {\n        if (this.Qf) throw Error(\"Tried to modify a read-only Uri\");\n      }, c.ad = function (t) {\n        this.O = t, this.P && this.P.ad(t);\n      };\n      var Je = /[#\\/\\?@]/g,\n          Ze = /[#\\?:]/g,\n          $e = /[#\\?]/g,\n          tn = /[#\\?@]/g,\n          en = /#/g;\n\n      function nn(t, e) {\n        this.j = this.m = null, this.ja = t || null, this.O = !!e;\n      }\n\n      function rn(t, e) {\n        this.b = t, this.a = e, this.f = this.A = null, this.bc = !1, this.K = null, this.w = -1, this.Ad = this.na = null;\n      }\n\n      function on(t) {\n        this.D = new We(), t && this.addAll(t);\n      }\n\n      function sn(t) {\n        var e = typeof t;\n        return \"object\" == e && t || \"function\" == e ? \"o\" + (t[E] || (t[E] = ++S)) : e.substr(0, 1) + t;\n      }\n\n      function an(t) {\n        this.me = t || un, f.PerformanceNavigationTiming ? t = 0 < (t = f.performance.getEntriesByType(\"navigation\")).length && (\"hq\" == t[0].nextHopProtocol || \"h2\" == t[0].nextHopProtocol) : t = !!(f.vc && f.vc.ke && f.vc.ke() && f.vc.ke().nh), this.Xb = t ? this.me : 1, this.v = null, 1 < this.Xb && (this.v = new on()), this.f = null, this.ba = [];\n      }\n\n      (c = nn.prototype).$ = function () {\n        if (!this.m && (this.m = new We(), this.j = 0, this.ja)) {\n          var t = this;\n          !function (t, e) {\n            if (t) {\n              t = t.split(\"&\");\n\n              for (var n = 0; n < t.length; n++) {\n                var r = t[n].indexOf(\"=\"),\n                    i = null;\n\n                if (0 <= r) {\n                  var o = t[n].substring(0, r);\n                  i = t[n].substring(r + 1);\n                } else o = t[n];\n\n                e(o, i ? decodeURIComponent(i.replace(/\\+/g, \" \")) : \"\");\n              }\n            }\n          }(this.ja, function (e, n) {\n            t.add(decodeURIComponent(e.replace(/\\+/g, \" \")), n);\n          });\n        }\n      }, c.C = function () {\n        return this.$(), this.j;\n      }, c.add = function (t, e) {\n        this.$(), this.Oa(), t = this.Ma(t);\n        var n = this.m.get(t);\n        return n || this.m.set(t, n = []), n.push(e), this.j += 1, this;\n      }, c.remove = function (t) {\n        return this.$(), t = this.Ma(t), !!this.m.va(t) && (this.Oa(), this.j -= this.m.get(t).length, this.m.remove(t));\n      }, c.clear = function () {\n        this.Oa(), this.m = null, this.j = 0;\n      }, c.X = function () {\n        return this.$(), 0 == this.j;\n      }, c.va = function (t) {\n        return this.$(), t = this.Ma(t), this.m.va(t);\n      }, c.forEach = function (t, e) {\n        this.$(), this.m.forEach(function (n, r) {\n          x(n, function (n) {\n            t.call(e, n, r, this);\n          }, this);\n        }, this);\n      }, c.W = function () {\n        this.$();\n\n        for (var t = this.m.H(), e = this.m.W(), n = [], r = 0; r < e.length; r++) {\n          for (var i = t[r], o = 0; o < i.length; o++) {\n            n.push(e[r]);\n          }\n        }\n\n        return n;\n      }, c.H = function (t) {\n        this.$();\n        var e = [];\n        if (d(t)) this.va(t) && (e = U(e, this.m.get(this.Ma(t))));else {\n          t = this.m.H();\n\n          for (var n = 0; n < t.length; n++) {\n            e = U(e, t[n]);\n          }\n        }\n        return e;\n      }, c.set = function (t, e) {\n        return this.$(), this.Oa(), t = this.Ma(t), this.va(t) && (this.j -= this.m.get(t).length), this.m.set(t, [e]), this.j += 1, this;\n      }, c.get = function (t, e) {\n        return t && 0 < (t = this.H(t)).length ? String(t[0]) : e;\n      }, c.Ie = function (t, e) {\n        this.remove(t), 0 < e.length && (this.Oa(), this.m.set(this.Ma(t), V(e)), this.j += e.length);\n      }, c.toString = function () {\n        if (this.ja) return this.ja;\n        if (!this.m) return \"\";\n\n        for (var t = [], e = this.m.W(), n = 0; n < e.length; n++) {\n          var r = e[n],\n              i = encodeURIComponent(String(r));\n          r = this.H(r);\n\n          for (var o = 0; o < r.length; o++) {\n            var s = i;\n            \"\" !== r[o] && (s += \"=\" + encodeURIComponent(String(r[o]))), t.push(s);\n          }\n        }\n\n        return this.ja = t.join(\"&\");\n      }, c.Oa = function () {\n        this.ja = null;\n      }, c.clone = function () {\n        var t = new nn();\n        return t.ja = this.ja, this.m && (t.m = this.m.clone(), t.j = this.j), t;\n      }, c.Ma = function (t) {\n        return t = String(t), this.O && (t = t.toLowerCase()), t;\n      }, c.ad = function (t) {\n        t && !this.O && (this.$(), this.Oa(), this.m.forEach(function (t, e) {\n          var n = e.toLowerCase();\n          e != n && (this.remove(e), this.Ie(n, t));\n        }, this)), this.O = t;\n      }, c.extend = function (t) {\n        for (var e = 0; e < arguments.length; e++) {\n          Ke(arguments[e], function (t, e) {\n            this.add(e, t);\n          }, this);\n        }\n      }, A(function () {}, function () {}), (c = rn.prototype).g = null, c.ga = function (t) {\n        this.A = t;\n      }, c.connect = function (t) {\n        this.K = t, t = this.b.Sd(this.K), De(3);\n        var e = this.b.Ib.$d;\n        null != e ? (this.na = this.b.$a(e[0]), this.g = 1, this.xd()) : (t.dc(\"MODE\", \"init\"), !this.b.ta && this.b.aa && t.dc(\"X-HTTP-Session-Id\", this.b.aa), this.f = new Fe(this, this.a, void 0, void 0, void 0), this.f.ga(this.A), this.f.jd(t, !1, null), this.g = 0);\n      }, c.xd = function () {\n        this.a.debug(\"TestConnection: starting stage 2\");\n        var t = this.b.Ib.od;\n        if (null != t) this.a.debug(function () {\n          return \"Buffered\";\n        }), De(4), t ? (De(10), this.b.ub(this, !1)) : (De(11), this.b.ub(this, !0));else {\n          this.f = new Fe(this, this.a, void 0, void 0, void 0), this.f.ga(this.A);\n          var e = this.b.Pd(this.na, this.K);\n          De(4), e.dc(\"TYPE\", \"xmlhttp\");\n          var n = this.b.aa,\n              r = this.b.Kc;\n          n && r && e.l(n, r), this.f.jd(e, !1, this.na);\n        }\n      }, c.Jb = function (t) {\n        return this.b.Jb(t);\n      }, c.abort = function () {\n        this.f && (this.f.cancel(), this.f = null), this.w = -1;\n      }, c.de = function () {\n        return !1;\n      }, c.ue = function (t, e) {\n        if (this.w = t.w, 0 == this.g) {\n          if (this.a.debug(\"TestConnection: Got data for stage 1\"), this.pc(t), e) {\n            try {\n              var n = this.b.kc.zc(e);\n            } catch (t) {\n              return this.a.cb(t), void this.b.dd(this);\n            }\n\n            this.na = this.b.$a(n[0]);\n          } else this.a.debug(\"TestConnection: Null responseText\"), this.b.dd(this);\n        } else 1 == this.g && (this.bc ? De(6) : \"11111\" == e ? (De(5), this.bc = !0, this.Ze() && (this.w = 200, this.f.cancel(), this.a.debug(\"Test connection succeeded; using streaming connection\"), De(11), this.b.ub(this, !0))) : (De(7), this.bc = !1));\n      }, c.Tc = function () {\n        this.w = this.f.w, this.f.S ? 0 == this.g ? (this.g = 1, this.a.debug(\"TestConnection: request complete for initial check\"), this.xd()) : 1 == this.g && (this.a.debug(\"TestConnection: request complete for stage 2\"), this.bc ? (this.a.debug(\"Test connection succeeded; using streaming connection\"), De(11), this.b.ub(this, !0)) : (this.a.debug(\"Test connection failed; not using streaming\"), De(10), this.b.ub(this, !1))) : (this.a.debug(\"TestConnection: request failed, in state \" + this.g), 0 == this.g ? De(8) : 1 == this.g && De(9), this.b.dd(this));\n      }, c.pc = function (t) {\n        if (!this.b.ta && (t = t.h)) {\n          var e = t.kb(\"X-Client-Wire-Protocol\");\n          this.Ad = e || null, this.b.aa && ((t = t.kb(\"X-HTTP-Session-Id\")) ? this.b.Fe(t) : this.a.T(\"Missing X_HTTP_SESSION_ID in the handshake response\"));\n        }\n      }, c.fc = function () {\n        return this.b.fc();\n      }, c.Ba = function () {\n        return this.b.Ba();\n      }, c.Ze = function () {\n        return !ot || 10 <= Number(pt);\n      }, (c = on.prototype).C = function () {\n        return this.D.C();\n      }, c.add = function (t) {\n        this.D.set(sn(t), t);\n      }, c.addAll = function (t) {\n        for (var e = (t = Qe(t)).length, n = 0; n < e; n++) {\n          this.add(t[n]);\n        }\n      }, c.pb = function (t) {\n        for (var e = (t = Qe(t)).length, n = 0; n < e; n++) {\n          this.remove(t[n]);\n        }\n      }, c.remove = function (t) {\n        return this.D.remove(sn(t));\n      }, c.clear = function () {\n        this.D.clear();\n      }, c.X = function () {\n        return this.D.X();\n      }, c.contains = function (t) {\n        return this.D.va(sn(t));\n      }, c.H = function () {\n        return this.D.H();\n      }, c.clone = function () {\n        return new on(this);\n      };\n      var un = 10;\n\n      function cn() {\n        this.xg = this.rg = void 0;\n      }\n\n      function hn() {\n        this.jg = new cn();\n      }\n\n      function ln(t, e, n, r, i) {\n        try {\n          t.debug(n), e.onload = null, e.onerror = null, e.onabort = null, e.ontimeout = null, i(r);\n        } catch (e) {\n          t.cb(e);\n        }\n      }\n\n      (c = an.prototype).ld = function (t) {\n        this.v || -1 == t.indexOf(\"spdy\") && -1 == t.indexOf(\"quic\") && -1 == t.indexOf(\"h2\") || (this.Xb = this.me, this.v = new on(), this.f && (this.oc(this.f), this.f = null));\n      }, c.ee = function () {\n        return !!this.f || !!this.v && this.v.C() >= this.Xb;\n      }, c.xf = function () {\n        return this.f ? 1 : this.v ? this.v.C() : 0;\n      }, c.Jc = function (t) {\n        return this.f ? this.f == t : !!this.v && this.v.contains(t);\n      }, c.oc = function (t) {\n        this.v ? this.v.add(t) : this.f = t;\n      }, c.ze = function (t) {\n        this.f && this.f == t ? this.f = null : this.v && this.v.contains(t) && this.v.remove(t);\n      }, c.cancel = function () {\n        this.ba = this.la(), this.f ? (this.f.cancel(), this.f = null) : this.v && !this.v.X() && (x(this.v.H(), function (t) {\n          t.cancel();\n        }), this.v.clear());\n      }, c.la = function () {\n        if (null != this.f) return this.ba.concat(this.f.la());\n\n        if (null != this.v && !this.v.X()) {\n          var t = this.ba;\n          return x(this.v.H(), function (e) {\n            t = t.concat(e.la());\n          }), t;\n        }\n\n        return V(this.ba);\n      }, c.Re = function (t) {\n        this.ba = this.ba.concat(t);\n      }, c.$e = function () {\n        this.ba.length = 0;\n      }, cn.prototype.stringify = function (t) {\n        return f.JSON.stringify(t, this.rg);\n      }, cn.prototype.parse = function (t) {\n        return f.JSON.parse(t, this.xg);\n      }, hn.prototype.hf = function (t, e, n) {\n        var r = n || \"\";\n\n        try {\n          Ke(t, function (t, n) {\n            var i = t;\n            w(t) && (i = jt(t)), e.push(r + n + \"=\" + encodeURIComponent(i));\n          });\n        } catch (t) {\n          throw e.push(r + \"type=\" + encodeURIComponent(\"_badmap\")), t;\n        }\n      }, hn.prototype.jf = function (t, e, n) {\n        for (var r = -1;;) {\n          var i = [\"count=\" + e];\n          -1 == r ? 0 < e ? (r = t[0].Pc, i.push(\"ofs=\" + r)) : r = 0 : i.push(\"ofs=\" + r);\n\n          for (var o = !0, s = 0; s < e; s++) {\n            var a = t[s].Pc,\n                u = t[s].map;\n            if (0 > (a -= r)) r = Math.max(0, t[s].Pc - 100), o = !1;else try {\n              this.hf(u, i, \"req\" + a + \"_\");\n            } catch (t) {\n              n && n(u);\n            }\n          }\n\n          if (o) return i.join(\"&\");\n        }\n      }, hn.prototype.zc = function (t) {\n        return this.jg.parse(t);\n      };\n      var fn = f.JSON.parse;\n\n      function dn(t) {\n        Wt.call(this), this.headers = new We(), this.Xa = t || null, this.ha = !1, this.mc = this.c = null, this.ge = this.Tb = \"\", this.Pa = 0, this.I = \"\", this.Aa = this.Lc = this.Qb = this.Ec = !1, this.vb = 0, this.hc = null, this.Ae = pn, this.jc = this.lg = this.Ab = !1;\n      }\n\n      A(dn, Wt);\n      var pn = \"\";\n      dn.prototype.s = ve(\"goog.net.XhrIo\");\n      var mn = /^https?$/i,\n          yn = [\"POST\", \"PUT\"];\n\n      function gn(t) {\n        return \"content-type\" == t.toLowerCase();\n      }\n\n      function vn(t, e) {\n        return {\n          type: e,\n          lengthComputable: t.lengthComputable,\n          loaded: t.loaded,\n          total: t.total\n        };\n      }\n\n      function bn(t, e, n) {\n        t: {\n          for (r in n) {\n            var r = !1;\n            break t;\n          }\n\n          r = !0;\n        }\n\n        if (r) return t;\n\n        if (n = function (t) {\n          var e = \"\";\n          return X(t, function (t, n) {\n            e += n, e += \":\", e += t, e += \"\\r\\n\";\n          }), e;\n        }(n), d(t)) {\n          if (e = encodeURIComponent(String(e)), e += n = null != n ? \"=\" + encodeURIComponent(String(n)) : \"\") {\n            if (0 > (n = t.indexOf(\"#\")) && (n = t.length), 0 > (r = t.indexOf(\"?\")) || r > n) {\n              r = n;\n              var i = \"\";\n            } else i = t.substring(r + 1, n);\n\n            n = (t = [t.substr(0, r), i, t.substr(n)])[1], t[1] = e ? n ? n + \"&\" + e : e : n, t = t[0] + (t[1] ? \"?\" + t[1] : \"\") + t[2];\n          }\n\n          return t;\n        }\n\n        return t.l(e, n), t;\n      }\n\n      function wn(t) {\n        this.Bd = 22, this.De = 0, this.M = [], this.a = new Ee(), this.Ib = new function () {\n          this.od = this.$d = null;\n        }(), this.na = this.md = this.hb = this.K = this.u = this.Kc = this.aa = this.gb = this.N = this.Rb = this.A = null, this.Te = !0, this.ag = this.Yb = 0, this.kf = !!p(\"internalChannelParams.failFast\", t), this.fd = this.Ja = this.wa = this.ia = this.ea = this.i = null, this.Se = !0, this.w = this.he = this.Sb = -1, this.rc = this.Ha = this.La = 0, this.Ve = p(\"internalChannelParams.baseRetryDelayMs\", t) || 5e3, this.vg = p(\"internalChannelParams.retryDelaySeedMs\", t) || 1e4, this.nf = p(\"internalChannelParams.forwardChannelMaxRetries\", t) || 2, this.Od = p(\"internalChannelParams.forwardChannelRequestTimeoutMs\", t) || 2e4, this.Xa = t && t.oh || void 0, this.Db = void 0, this.Ra = 0, this.gc = t && t.supportsCrossDomainXhr || !1, this.ra = \"\", this.G = new an(t && t.concurrentRequestLimit), this.kc = new hn(), this.ta = !t || void 0 === t.backgroundChannelTest || t.backgroundChannelTest, (this.Nd = t && t.fastHandshake || !1) && !this.ta && (this.a.T(\"Force backgroundChannelTest when fastHandshake is enabled.\"), this.ta = !0), t && t.Id && this.a.Id();\n      }\n\n      function En() {}\n\n      function Sn() {\n        if (ot && !(10 <= Number(pt))) throw Error(\"Environmental error: no available transport.\");\n      }\n\n      function Tn(t, e) {\n        Wt.call(this), this.b = new wn(e), this.yb = t, this.Qg = e && e.testUrl ? e.testUrl : function (t) {\n          for (var e = arguments[0], n = 1; n < arguments.length; n++) {\n            var r,\n                i = arguments[n];\n            0 == i.lastIndexOf(\"/\", 0) ? e = i : ((r = \"\" == e) || (r = 0 <= (r = e.length - 1) && e.indexOf(\"/\", r) == r), e = r ? e + i : e + \"/\" + i);\n          }\n\n          return e;\n        }(this.yb, \"test\"), this.s = ve(\"goog.labs.net.webChannel.WebChannelBaseTransport\"), this.Rc = e && e.messageUrlParams || null, t = e && e.messageHeaders || null, e && e.clientProtocolHeaderRequired && (t ? t[\"X-Client-Protocol\"] = \"webchannel\" : t = {\n          \"X-Client-Protocol\": \"webchannel\"\n        }), this.b.ga(t), t = e && e.initMessageHeaders || null, e && e.messageContentType && (t ? t[\"X-WebChannel-Content-Type\"] = e.messageContentType : t = {\n          \"X-WebChannel-Content-Type\": e.messageContentType\n        }), e && e.zd && (t ? t[\"X-WebChannel-Client-Profile\"] = e.zd : t = {\n          \"X-WebChannel-Client-Profile\": e.zd\n        }), this.b.Eg(t), (t = e && e.httpHeadersOverwriteParam) && !Q(t) && this.b.Cg(t), this.Og = e && e.supportsCrossDomainXhr || !1, this.zg = e && e.sendRawJson || !1, (e = e && e.httpSessionIdParam) && !Q(e) && (this.b.Dg(e), null !== (t = this.Rc) && e in t && (e in (t = this.Rc) && delete t[e], (t = this.s) && t.T(\"Ignore httpSessionIdParam also specified with messageUrlParams: \" + e, void 0))), this.vd = new Dn(this);\n      }\n\n      function In(t) {\n        Le.call(this);\n        var e = t.__sm__;\n\n        if (e) {\n          t: {\n            for (var n in e) {\n              t = n;\n              break t;\n            }\n\n            t = void 0;\n          }\n\n          (this.ne = t) && (t = this.ne, e = null !== e && t in e ? e[t] : void 0), this.data = e;\n        } else this.data = t;\n      }\n\n      function Cn(t) {\n        xe.call(this), this.status = 1, this.errorCode = t;\n      }\n\n      function Dn(t) {\n        this.b = t;\n      }\n\n      (c = dn.prototype).Je = function (t) {\n        this.Ab = t;\n      }, c.send = function (t, e, n, r) {\n        if (this.c) throw Error(\"[goog.net.XhrIo] Object is active with another request=\" + this.Tb + \"; newUri=\" + t);\n        e = e ? e.toUpperCase() : \"GET\", this.Tb = t, this.I = \"\", this.Pa = 0, this.ge = e, this.Ec = !1, this.ha = !0, this.c = this.df(), this.mc = this.Xa ? this.Xa.Vd() : _e.Vd(), this.c.onreadystatechange = C(this.te, this), this.lg && \"onprogress\" in this.c && (this.c.onprogress = C(function (t) {\n          this.re(t, !0);\n        }, this), this.c.upload && (this.c.upload.onprogress = C(this.re, this)));\n\n        try {\n          we(this.s, this.da(\"Opening Xhr\")), this.Lc = !0, this.c.open(e, String(t), !0), this.Lc = !1;\n        } catch (t) {\n          return we(this.s, this.da(\"Error opening Xhr: \" + t.message)), void this.Ld(t);\n        }\n\n        t = n || \"\";\n        var i = this.headers.clone();\n        r && Ke(r, function (t, e) {\n          i.set(e, t);\n        }), r = function (t) {\n          t: {\n            for (var e = gn, n = t.length, r = d(t) ? t.split(\"\") : t, i = 0; i < n; i++) {\n              if (i in r && e.call(void 0, r[i], i, t)) {\n                e = i;\n                break t;\n              }\n            }\n\n            e = -1;\n          }\n\n          return 0 > e ? null : d(t) ? t.charAt(e) : t[e];\n        }(i.W()), n = f.FormData && t instanceof f.FormData, !(0 <= P(yn, e)) || r || n || i.set(\"Content-Type\", \"application/x-www-form-urlencoded;charset=utf-8\"), i.forEach(function (t, e) {\n          this.c.setRequestHeader(e, t);\n        }, this), this.Ae && (this.c.responseType = this.Ae), \"withCredentials\" in this.c && this.c.withCredentials !== this.Ab && (this.c.withCredentials = this.Ab);\n\n        try {\n          this.yd(), 0 < this.vb && (this.jc = function (t) {\n            return ot && yt(9) && \"number\" == typeof t.timeout && void 0 !== t.ontimeout;\n          }(this.c), we(this.s, this.da(\"Will abort after \" + this.vb + \"ms if incomplete, xhr2 \" + this.jc)), this.jc ? (this.c.timeout = this.vb, this.c.ontimeout = C(this.Ua, this)) : this.hc = ie(this.Ua, this.vb, this)), we(this.s, this.da(\"Sending request\")), this.Qb = !0, this.c.send(t), this.Qb = !1;\n        } catch (t) {\n          we(this.s, this.da(\"Send error: \" + t.message)), this.Ld(t);\n        }\n      }, c.df = function () {\n        return this.Xa ? this.Xa.Dd() : _e.Dd();\n      }, c.Ua = function () {\n        void 0 !== l && this.c && (this.I = \"Timed out after \" + this.vb + \"ms, aborting\", this.Pa = 8, we(this.s, this.da(this.I)), this.dispatchEvent(\"timeout\"), this.abort(8));\n      }, c.Ld = function (t) {\n        this.ha = !1, this.c && (this.Aa = !0, this.c.abort(), this.Aa = !1), this.I = t, this.Pa = 5, this.Jd(), this.Gb();\n      }, c.Jd = function () {\n        this.Ec || (this.Ec = !0, this.dispatchEvent(\"complete\"), this.dispatchEvent(\"error\"));\n      }, c.abort = function (t) {\n        this.c && this.ha && (we(this.s, this.da(\"Aborting\")), this.ha = !1, this.Aa = !0, this.c.abort(), this.Aa = !1, this.Pa = t || 7, this.dispatchEvent(\"complete\"), this.dispatchEvent(\"abort\"), this.Gb());\n      }, c.F = function () {\n        this.c && (this.ha && (this.ha = !1, this.Aa = !0, this.c.abort(), this.Aa = !1), this.Gb(!0)), dn.L.F.call(this);\n      }, c.te = function () {\n        this.Ka || (this.Lc || this.Qb || this.Aa ? this.se() : this.eg());\n      }, c.eg = function () {\n        this.se();\n      }, c.se = function () {\n        if (this.ha && void 0 !== l) if (this.mc[1] && 4 == this.ma() && 2 == this.za()) we(this.s, this.da(\"Local request error detected and ignored\"));else if (this.Qb && 4 == this.ma()) ie(this.te, 0, this);else if (this.dispatchEvent(\"readystatechange\"), this.Mc()) {\n          we(this.s, this.da(\"Request complete\")), this.ha = !1;\n\n          try {\n            this.Rf() ? (this.dispatchEvent(\"complete\"), this.dispatchEvent(\"success\")) : (this.Pa = 6, this.I = this.Yd() + \" [\" + this.za() + \"]\", this.Jd());\n          } finally {\n            this.Gb();\n          }\n        }\n      }, c.re = function (t, e) {\n        this.dispatchEvent(vn(t, \"progress\")), this.dispatchEvent(vn(t, e ? \"downloadprogress\" : \"uploadprogress\"));\n      }, c.Gb = function (t) {\n        if (this.c) {\n          this.yd();\n          var e = this.c,\n              n = this.mc[0] ? m : null;\n          this.mc = this.c = null, t || this.dispatchEvent(\"ready\");\n\n          try {\n            e.onreadystatechange = n;\n          } catch (e) {\n            (t = this.s) && t.ca(\"Problem encountered resetting onreadystatechange: \" + e.message, void 0);\n          }\n        }\n      }, c.yd = function () {\n        this.c && this.jc && (this.c.ontimeout = null), this.hc && (f.clearTimeout(this.hc), this.hc = null);\n      }, c.Ba = function () {\n        return !!this.c;\n      }, c.Mc = function () {\n        return 4 == this.ma();\n      }, c.Rf = function () {\n        var t = this.za();\n\n        t: switch (t) {\n          case 200:\n          case 201:\n          case 202:\n          case 204:\n          case 206:\n          case 304:\n          case 1223:\n            var e = !0;\n            break t;\n\n          default:\n            e = !1;\n        }\n\n        return e || 0 === t && !this.Of();\n      }, c.Of = function () {\n        var t = String(this.Tb).match(ze)[1] || null;\n        return !t && f.self && f.self.location && (t = (t = f.self.location.protocol).substr(0, t.length - 1)), mn.test(t ? t.toLowerCase() : \"\");\n      }, c.ma = function () {\n        return this.c ? this.c.readyState : 0;\n      }, c.za = function () {\n        try {\n          return 2 < this.ma() ? this.c.status : -1;\n        } catch (t) {\n          return -1;\n        }\n      }, c.Yd = function () {\n        try {\n          return 2 < this.ma() ? this.c.statusText : \"\";\n        } catch (t) {\n          return we(this.s, \"Can not get status: \" + t.message), \"\";\n        }\n      }, c.ya = function () {\n        try {\n          return this.c ? this.c.responseText : \"\";\n        } catch (t) {\n          return we(this.s, \"Can not get responseText: \" + t.message), \"\";\n        }\n      }, c.yf = function (t) {\n        if (this.c) {\n          var e = this.c.responseText;\n          return t && 0 == e.indexOf(t) && (e = e.substring(t.length)), fn(e);\n        }\n      }, c.getResponseHeader = function (t) {\n        if (this.c && this.Mc()) return null === (t = this.c.getResponseHeader(t)) ? void 0 : t;\n      }, c.getAllResponseHeaders = function () {\n        return this.c && this.Mc() && this.c.getAllResponseHeaders() || \"\";\n      }, c.kb = function (t) {\n        return this.c ? this.c.getResponseHeader(t) : null;\n      }, c.Ud = function () {\n        return this.Pa;\n      }, c.Hc = function () {\n        return d(this.I) ? this.I : String(this.I);\n      }, c.da = function (t) {\n        return t + \" [\" + this.ge + \" \" + this.Tb + \" \" + this.za() + \"]\";\n      }, (c = wn.prototype).tc = 8, c.g = 1, c.connect = function (t, e, n, r, i) {\n        this.a.debug(\"connect()\"), De(0), this.K = e, this.gb = n || {}, r && void 0 !== i && (this.gb.OSID = r, this.gb.OAID = i), this.ta && (this.a.debug(\"connect() bypassed channel-test.\"), this.Ib.$d = [], this.Ib.od = !1), this.bf(t);\n      }, c.disconnect = function () {\n        if (this.a.debug(\"disconnect()\"), this.qd(), 3 == this.g) {\n          var t = this.Yb++,\n              e = this.hb.clone();\n          e.l(\"SID\", this.ra), e.l(\"RID\", t), e.l(\"TYPE\", \"terminate\"), this.Ya(e), new Fe(this, this.a, this.ra, t, void 0).yg(e);\n        }\n\n        this.qe();\n      }, c.bf = function (t) {\n        this.a.debug(\"connectTest_()\"), this.Ja = new rn(this, this.a), null === this.N && this.Ja.ga(this.A);\n        var e = t;\n        this.N && this.A && (e = bn(t, this.N, this.A)), this.Ja.connect(e);\n      }, c.af = function () {\n        this.a.debug(\"connectChannel_()\"), this.hb = this.Sd(this.K), this.Dc();\n      }, c.qd = function () {\n        this.Ja && (this.Ja.abort(), this.Ja = null), this.u && (this.u.cancel(), this.u = null), this.ia && (f.clearTimeout(this.ia), this.ia = null), this.Hb(), this.G.cancel(), this.ea && (f.clearTimeout(this.ea), this.ea = null);\n      }, c.ga = function (t) {\n        this.A = t;\n      }, c.Eg = function (t) {\n        this.Rb = t;\n      }, c.Cg = function (t) {\n        this.N = t;\n      }, c.Dg = function (t) {\n        this.aa = t;\n      }, c.Fe = function (t) {\n        this.Kc = t;\n      }, c.He = function (t) {\n        this.Ra = t;\n      }, c.Hg = function () {\n        this.gc = !0;\n      }, c.Ee = function (t) {\n        this.i = t;\n      }, c.Nf = function () {\n        return !this.fd;\n      }, c.Zc = function (t) {\n        1e3 == this.M.length && this.a.ca(function () {\n          return \"Already have 1000 queued maps upon queueing \" + jt(t);\n        }), this.M.push(new function (t, e) {\n          this.Pc = t, this.map = e, this.context = null;\n        }(this.ag++, t)), 3 == this.g && this.Dc();\n      }, c.qf = function () {\n        return this.kf ? 0 : this.nf;\n      }, c.de = function () {\n        return 0 == this.g;\n      }, c.getState = function () {\n        return this.g;\n      }, c.Dc = function () {\n        this.G.ee() || this.ea || (this.ea = Ae(C(this.we, this), 0), this.La = 0);\n      }, c.Yf = function (t) {\n        return this.G.xf() >= this.G.Xb - (this.ea ? 1 : 0) ? (this.a.ca(\"Unexpected retry request is scheduled.\"), !1) : this.ea ? (this.a.debug(\"Use the retry request that is already scheduled.\"), this.M = t.la().concat(this.M), !0) : !(1 == this.g || 2 == this.g || this.La >= this.qf()) && (this.a.debug(\"Going to retry POST\"), this.ea = Ae(C(this.we, this, t), this.Xd(this.La)), this.La++, !0);\n      }, c.we = function (t) {\n        this.ea = null, this.Mg(t);\n      }, c.Mg = function (t) {\n        this.a.debug(\"startForwardChannel_\"), 1 == this.g ? t ? this.a.ca(\"Not supposed to retry the open\") : (this.ig(), this.g = 2) : 3 == this.g && (t ? this.le(t) : 0 == this.M.length ? this.a.debug(\"startForwardChannel_ returned: nothing to send\") : this.G.ee() ? this.a.ca(\"startForwardChannel_ returned: connection already in progress\") : (this.le(), this.a.debug(\"startForwardChannel_ finished, sent request\")));\n      }, c.ig = function () {\n        this.a.debug(\"open_()\"), this.Yb = Math.floor(1e5 * Math.random());\n        var t = this.Yb++,\n            e = new Fe(this, this.a, \"\", t, void 0),\n            n = this.A;\n        this.Rb && (n ? tt(n = Z(n), this.Rb) : n = this.Rb), null === this.N && e.ga(n);\n        var r = this.Hd(e),\n            i = this.hb.clone();\n        i.l(\"RID\", t), 0 < this.Bd && i.l(\"CVER\", this.Bd), this.ta && this.aa && i.l(\"X-HTTP-Session-Id\", this.aa), this.Ya(i), this.N && n && bn(i, this.N, n), this.G.oc(e), this.Nd ? (i.l(\"$req\", r), i.l(\"SID\", \"null\"), e.Ag(), e.kd(i, null)) : e.kd(i, r);\n      }, c.le = function (t) {\n        var e = t ? t.R : this.Yb++,\n            n = this.hb.clone();\n        n.l(\"SID\", this.ra), n.l(\"RID\", e), n.l(\"AID\", this.Sb), this.Ya(n), this.N && this.A && bn(n, this.N, this.A), e = new Fe(this, this.a, this.ra, e, this.La + 1), null === this.N && e.ga(this.A), t && this.sg(t), t = this.Hd(e), e.setTimeout(Math.round(.5 * this.Od) + Math.round(.5 * this.Od * Math.random())), this.G.oc(e), e.kd(n, t);\n      }, c.Ya = function (t) {\n        this.i && Ke({}, function (e, n) {\n          t.l(n, e);\n        });\n      }, c.Hd = function (t) {\n        var e = Math.min(this.M.length, 1e3),\n            n = this.i ? C(this.i.Ue, this.i, this) : null;\n        return n = this.kc.jf(this.M, e, n), t.Gg(this.M.splice(0, e)), n;\n      }, c.sg = function (t) {\n        this.M = t.la().concat(this.M);\n      }, c.Kd = function () {\n        if (!this.u && !this.ia) {\n          this.rc = 1;\n          var t = this.ve;\n          Xt || $t(), te || (Xt(), te = !0), ee.add(t, this), this.Ha = 0;\n        }\n      }, c.Qc = function () {\n        return this.u || this.ia ? (this.a.ca(\"Request already in progress\"), !1) : !(3 <= this.Ha) && (this.a.debug(\"Going to retry GET\"), this.rc++, this.ia = Ae(C(this.ve, this), this.Xd(this.Ha)), this.Ha++, !0);\n      }, c.ve = function () {\n        this.ia = null, this.Kg();\n      }, c.Kg = function () {\n        this.a.debug(\"Creating new HttpRequest\"), this.u = new Fe(this, this.a, this.ra, \"rpc\", this.rc), null === this.N && this.u.ga(this.A), this.u.He(this.Ra);\n        var t = this.md.clone();\n        t.l(\"RID\", \"rpc\"), t.l(\"SID\", this.ra), t.l(\"CI\", this.fd ? \"0\" : \"1\"), t.l(\"AID\", this.Sb), this.Ya(t), t.l(\"TYPE\", \"xmlhttp\"), this.N && this.A && bn(t, this.N, this.A), this.Db && this.u.setTimeout(this.Db), this.u.jd(t, !0, this.na), this.a.debug(\"New Request created\");\n      }, c.ub = function (t, e) {\n        this.a.debug(\"Test Connection Finished\");\n        var n = t.Ad;\n        n && this.G.ld(n), this.fd = this.Se && e, this.w = t.w, this.af();\n      }, c.dd = function (t) {\n        this.a.debug(\"Test Connection Failed\"), this.w = t.w, this.sa(2);\n      }, c.ue = function (t, e) {\n        if (0 != this.g && (this.u == t || this.G.Jc(t))) if (this.w = t.w, !t.lb && this.G.Jc(t) && 3 == this.g) {\n          try {\n            var n = this.kc.zc(e);\n          } catch (t) {\n            n = null;\n          }\n\n          g(n) && 3 == n.length ? this.Cf(n, t) : (this.a.debug(\"Bad POST response data returned\"), this.sa(11));\n        } else (t.lb || this.u == t) && this.Hb(), Q(e) || (n = this.kc.zc(e), this.dg(n, t));\n      }, c.Cf = function (t, e) {\n        0 == t[0] ? this.Bf(e) : (this.he = t[1], 0 < (e = this.he - this.Sb) && (t = t[2], this.a.debug(t + \" bytes (in \" + e + \" arrays) are outstanding on the BackChannel\"), this.Jg(t) && !this.wa && (this.wa = Ae(C(this.bg, this), 6e3))));\n      }, c.Bf = function (t) {\n        if (this.a.debug(\"Server claims our backchannel is missing.\"), this.ia) this.a.debug(\"But we are currently starting the request.\");else {\n          if (this.u) {\n            if (!(this.u.qb + 3e3 < t.qb)) return;\n            this.Hb(), this.u.cancel(), this.u = null;\n          } else this.a.T(\"We do not have a BackChannel established\");\n\n          this.Qc(), De(18);\n        }\n      }, c.Jg = function (t) {\n        return 37500 > t && !this.Nf() && 0 == this.Ha;\n      }, c.$a = function (t) {\n        return this.Te ? this.i ? this.i.$a(t) : t : null;\n      }, c.bg = function () {\n        null != this.wa && (this.wa = null, this.u.cancel(), this.u = null, this.Qc(), De(19));\n      }, c.Hb = function () {\n        null != this.wa && (f.clearTimeout(this.wa), this.wa = null);\n      }, c.Tc = function (t) {\n        this.a.debug(\"Request complete\");\n        var e = null;\n\n        if (this.u == t) {\n          this.Hb(), this.u = null;\n          var n = 2;\n        } else {\n          if (!this.G.Jc(t)) return;\n          e = t.la(), this.G.ze(t), n = 1;\n        }\n\n        if (this.w = t.w, 0 != this.g) if (t.S) 1 == n ? (function (t, e, n) {\n          Se.dispatchEvent(new Ne(Se, t, e, n));\n        }(t.Da ? t.Da.length : 0, N() - t.qb, this.La), this.Dc()) : this.Kd();else {\n          var r = t.Hc();\n          if (3 == r || 0 == r && 0 < this.w) this.a.debug(\"Not retrying due to error type\");else {\n            var i = this;\n            if (this.a.debug(function () {\n              return \"Maybe retrying, last error: \" + function (t, e) {\n                switch (t) {\n                  case 0:\n                    return \"Non-200 return code (\" + e + \")\";\n\n                  case 1:\n                    return \"XMLHTTP failure (no data)\";\n\n                  case 2:\n                    return \"HttpConnection timeout\";\n\n                  default:\n                    return \"Unknown error\";\n                }\n              }(r, i.w);\n            }), 1 == n && this.Yf(t) || 2 == n && this.Qc()) return;\n            this.a.debug(\"Exceeded max number of retries\");\n          }\n\n          switch (e && 0 < e.length && this.G.Re(e), this.a.debug(\"Error: HTTP request failed\"), r) {\n            case 1:\n              this.sa(5);\n              break;\n\n            case 4:\n              this.sa(10);\n              break;\n\n            case 3:\n              this.sa(6);\n              break;\n\n            default:\n              this.sa(2);\n          }\n        }\n      }, c.Xd = function (t) {\n        var e = this.Ve + Math.floor(Math.random() * this.vg);\n        return this.Ba() || (this.a.debug(\"Inactive channel\"), e *= 2), e * t;\n      }, c.pc = function (t) {\n        if (this.ta && (t = t.h)) {\n          var e = t.kb(\"X-Client-Wire-Protocol\");\n          e && this.G.ld(e), this.aa && ((t = t.kb(\"X-HTTP-Session-Id\")) ? (this.Fe(t), this.hb.l(this.aa, t)) : this.a.T(\"Missing X_HTTP_SESSION_ID in the handshake response\"));\n        }\n      }, c.dg = function (t, e) {\n        for (var n = this.i && this.i.sc ? [] : null, r = 0; r < t.length; r++) {\n          var i = t[r];\n          if (this.Sb = i[0], i = i[1], 2 == this.g) {\n            if (\"c\" == i[0]) {\n              this.ra = i[1], this.na = this.$a(i[2]);\n              var o = i[3];\n              null != o && (this.tc = o, this.a.info(\"VER=\" + this.tc)), null != (o = i[4]) && (this.De = o, this.a.info(\"SVER=\" + this.De)), null != (i = i[5]) && \"number\" == typeof i && 0 < i && (this.Db = i *= 1.5, this.a.info(\"backChannelRequestTimeoutMs_=\" + i)), this.pc(e), this.g = 3, this.i && this.i.wd(), this.Lg(e);\n            } else \"stop\" != i[0] && \"close\" != i[0] || this.sa(7);\n          } else 3 == this.g && (\"stop\" == i[0] || \"close\" == i[0] ? (n && 0 != n.length && (this.i.sc(this, n), n.length = 0), \"stop\" == i[0] ? this.sa(7) : this.disconnect()) : \"noop\" != i[0] && (n ? n.push(i) : this.i && this.i.ud(i)), this.Ha = 0);\n        }\n\n        n && 0 != n.length && this.i.sc(this, n);\n      }, c.Lg = function (t) {\n        this.md = this.Pd(this.na, this.K), t.lb ? (this.a.debug(\"Upgrade the handshake request to a backchannel.\"), this.G.ze(t), t.tg(this.Db), this.u = t) : this.Kd();\n      }, c.sa = function (t) {\n        if (this.a.info(\"Error code \" + t), 2 == t) {\n          var e = null;\n          this.i && (e = null);\n          var n = C(this.Pg, this);\n          e || (e = new Ge(\"//www.google.com/images/cleardot.gif\"), f.location && \"http\" == f.location.protocol || e.tb(\"https\"), e.Ub()), function (t, e) {\n            var n = new Ee();\n            n.debug(\"TestLoadImage: loading \" + t);\n            var r = new Image();\n            r.onload = D(ln, n, r, \"TestLoadImage: loaded\", !0, e), r.onerror = D(ln, n, r, \"TestLoadImage: error\", !1, e), r.onabort = D(ln, n, r, \"TestLoadImage: abort\", !1, e), r.ontimeout = D(ln, n, r, \"TestLoadImage: timeout\", !1, e), f.setTimeout(function () {\n              r.ontimeout && r.ontimeout();\n            }, 1e4), r.src = t;\n          }(e.toString(), n);\n        } else De(2);\n\n        this.cg(t);\n      }, c.Pg = function (t) {\n        t ? (this.a.info(\"Successfully pinged google.com\"), De(2)) : (this.a.info(\"Failed to ping google.com\"), De(1));\n      }, c.cg = function (t) {\n        this.a.debug(\"HttpChannel: error - \" + t), this.g = 0, this.i && this.i.td(t), this.qe(), this.qd();\n      }, c.qe = function () {\n        if (this.g = 0, this.w = -1, this.i) {\n          var t = this.G.la();\n\n          if (0 != t.length || 0 != this.M.length) {\n            var e = this;\n            this.a.debug(function () {\n              return \"Number of undelivered maps, pending: \" + t.length + \", outgoing: \" + e.M.length;\n            }), this.G.$e(), V(this.M), this.M.length = 0;\n          }\n\n          this.i.sd();\n        }\n      }, c.Sd = function (t) {\n        return t = this.Cd(null, t), this.a.debug(\"GetForwardChannelUri: \" + t), t;\n      }, c.Pd = function (t, e) {\n        return t = this.Cd(this.fc() ? t : null, e), this.a.debug(\"GetBackChannelUri: \" + t), t;\n      }, c.Cd = function (t, e) {\n        var n = function (t) {\n          return t instanceof Ge ? t.clone() : new Ge(t, void 0);\n        }(e);\n\n        if (\"\" != n.xa) t && n.rb(t + \".\" + n.xa), n.sb(n.Ca);else {\n          var r = f.location;\n\n          n = function (t, e, n, r) {\n            var i = new Ge(null, void 0);\n            return t && i.tb(t), e && i.rb(e), n && i.sb(n), r && i.ec(r), i;\n          }(r.protocol, t ? t + \".\" + r.hostname : r.hostname, +r.port, e);\n        }\n        return this.gb && X(this.gb, function (t, e) {\n          n.l(e, t);\n        }), t = this.aa, e = this.Kc, t && e && n.l(t, e), n.l(\"VER\", this.tc), this.Ya(n), n;\n      }, c.Jb = function (t) {\n        if (t && !this.gc) throw Error(\"Can't create secondary domain capable XhrIo object.\");\n        return (t = new dn(this.Xa)).Je(this.gc), t;\n      }, c.Ba = function () {\n        return !!this.i && this.i.Ba();\n      }, c.fc = function () {\n        return this.gc;\n      }, (c = En.prototype).sc = null, c.wd = function () {}, c.ud = function () {}, c.td = function () {}, c.sd = function () {}, c.Ba = function () {\n        return !0;\n      }, c.Ue = function () {}, c.$a = function (t) {\n        return t;\n      }, Sn.prototype.cf = function (t, e) {\n        return new Tn(t, e);\n      }, A(Tn, Wt), (c = Tn.prototype).addEventListener = function (t, e, n, r) {\n        Tn.L.addEventListener.call(this, t, e, n, r);\n      }, c.removeEventListener = function (t, e, n, r) {\n        Tn.L.removeEventListener.call(this, t, e, n, r);\n      }, c.open = function () {\n        this.b.Ee(this.vd), this.Og && this.b.Hg(), this.b.connect(this.Qg, this.yb, this.Rc || void 0);\n      }, c.close = function () {\n        this.b.disconnect();\n      }, c.send = function (t) {\n        if (d(t)) {\n          var e = {};\n          e.__data__ = t, this.b.Zc(e);\n        } else this.zg ? ((e = {}).__data__ = jt(t), this.b.Zc(e)) : this.b.Zc(t);\n      }, c.F = function () {\n        this.b.Ee(null), delete this.vd, this.b.disconnect(), delete this.b, Tn.L.F.call(this);\n      }, A(In, Le), A(Cn, xe), A(Dn, En), Dn.prototype.wd = function () {\n        be(this.b.s, \"WebChannel opened on \" + this.b.yb), this.b.dispatchEvent(\"a\");\n      }, Dn.prototype.ud = function (t) {\n        this.b.dispatchEvent(new In(t));\n      }, Dn.prototype.td = function (t) {\n        be(this.b.s, \"WebChannel aborted on \" + this.b.yb + \" due to channel error: \" + t), this.b.dispatchEvent(new Cn(t));\n      }, Dn.prototype.sd = function () {\n        be(this.b.s, \"WebChannel closed on \" + this.b.yb), this.b.dispatchEvent(\"b\");\n      };\n      var Nn = D(function (t, e) {\n        function n() {}\n\n        n.prototype = t.prototype;\n        var r = new n();\n        return t.apply(r, Array.prototype.slice.call(arguments, 1)), r;\n      }, Sn);\n\n      function An() {\n        this.V = [], this.Z = [];\n      }\n\n      function kn(t, e) {\n        if (M.call(this), this.oe = t || 0, this.Wb = e || 10, this.oe > this.Wb) throw Error(Rn);\n        this.fa = new An(), this.oa = new on(), this.Ac = 0, this.Nc = null, this.Cb();\n      }\n\n      (c = An.prototype).Vf = function () {\n        0 == this.V.length && (this.V = this.Z, this.V.reverse(), this.Z = []);\n      }, c.enqueue = function (t) {\n        this.Z.push(t);\n      }, c.ab = function () {\n        return this.Vf(), this.V.pop();\n      }, c.C = function () {\n        return this.V.length + this.Z.length;\n      }, c.X = function () {\n        return 0 == this.V.length && 0 == this.Z.length;\n      }, c.clear = function () {\n        this.V = [], this.Z = [];\n      }, c.contains = function (t) {\n        return 0 <= P(this.V, t) || 0 <= P(this.Z, t);\n      }, c.remove = function (t) {\n        var e = this.V,\n            n = L(e, t);\n        return 0 <= n ? (Array.prototype.splice.call(e, n, 1), e = !0) : e = !1, e || B(this.Z, t);\n      }, c.H = function () {\n        for (var t = [], e = this.V.length - 1; 0 <= e; --e) {\n          t.push(this.V[e]);\n        }\n\n        var n = this.Z.length;\n\n        for (e = 0; e < n; ++e) {\n          t.push(this.Z[e]);\n        }\n\n        return t;\n      }, A(kn, M);\n      var Rn = \"[goog.structs.Pool] Min can not be greater than max\";\n\n      function Mn(t, e) {\n        this.fe = t, this.gd = e;\n      }\n\n      function On(t) {\n        this.Y = [], t && this.Lf(t);\n      }\n\n      function _n() {\n        On.call(this);\n      }\n\n      function Pn(t, e) {\n        this.Gd = void 0, this.cc = new _n(), kn.call(this, t, e);\n      }\n\n      function Ln(t, e, n, r) {\n        this.Jf = t, this.Ab = !!r, Pn.call(this, e, n);\n      }\n\n      (c = kn.prototype).Mb = function () {\n        var t = N();\n\n        if (!(null != this.Nc && t - this.Nc < this.Ac)) {\n          var e = this.qg();\n          return e && (this.Nc = t, this.oa.add(e)), e;\n        }\n      }, c.og = function (t) {\n        return !!this.oa.remove(t) && (this.nc(t), !0);\n      }, c.qg = function () {\n        for (var t; 0 < this.Td() && (t = this.fa.ab(), !this.Sc(t));) {\n          this.Cb();\n        }\n\n        return !t && this.C() < this.Wb && (t = this.xc()), t;\n      }, c.nc = function (t) {\n        this.oa.remove(t), this.Sc(t) && this.C() < this.Wb ? this.fa.enqueue(t) : this.Bc(t);\n      }, c.Cb = function () {\n        for (var t = this.fa; this.C() < this.oe;) {\n          t.enqueue(this.xc());\n        }\n\n        for (; this.C() > this.Wb && 0 < this.Td();) {\n          this.Bc(t.ab());\n        }\n      }, c.xc = function () {\n        return {};\n      }, c.Bc = function (t) {\n        if (\"function\" == typeof t.bb) t.bb();else for (var e in t) {\n          t[e] = null;\n        }\n      }, c.Sc = function (t) {\n        return \"function\" != typeof t.Ye || t.Ye();\n      }, c.contains = function (t) {\n        return this.fa.contains(t) || this.oa.contains(t);\n      }, c.C = function () {\n        return this.fa.C() + this.oa.C();\n      }, c.rf = function () {\n        return this.oa.C();\n      }, c.Td = function () {\n        return this.fa.C();\n      }, c.X = function () {\n        return this.fa.X() && this.oa.X();\n      }, c.F = function () {\n        if (kn.L.F.call(this), 0 < this.rf()) throw Error(\"[goog.structs.Pool] Objects not released\");\n        delete this.oa;\n\n        for (var t = this.fa; !t.X();) {\n          this.Bc(t.ab());\n        }\n\n        delete this.fa;\n      }, Mn.prototype.getKey = function () {\n        return this.fe;\n      }, Mn.prototype.clone = function () {\n        return new Mn(this.fe, this.gd);\n      }, (c = On.prototype).ce = function (t, e) {\n        var n = this.Y;\n        n.push(new Mn(t, e)), this.$f(n.length - 1);\n      }, c.Lf = function (t) {\n        if (t instanceof On) {\n          var e = t.W();\n\n          if (t = t.H(), 0 >= this.C()) {\n            for (var n = this.Y, r = 0; r < e.length; r++) {\n              n.push(new Mn(e[r], t[r]));\n            }\n\n            return;\n          }\n        } else e = J(t), t = Y(t);\n\n        for (r = 0; r < e.length; r++) {\n          this.ce(e[r], t[r]);\n        }\n      }, c.remove = function () {\n        var t = this.Y,\n            e = t.length,\n            n = t[0];\n        if (!(0 >= e)) return 1 == e ? F(t) : (t[0] = t.pop(), this.Zf()), n.gd;\n      }, c.Zf = function () {\n        for (var t = 0, e = this.Y, n = e.length, r = e[t]; t < n >> 1;) {\n          var i = this.tf(t),\n              o = this.zf(t);\n          if (e[i = o < n && e[o].getKey() < e[i].getKey() ? o : i].getKey() > r.getKey()) break;\n          e[t] = e[i], t = i;\n        }\n\n        e[t] = r;\n      }, c.$f = function (t) {\n        for (var e = this.Y, n = e[t]; 0 < t;) {\n          var r = this.wf(t);\n          if (!(e[r].getKey() > n.getKey())) break;\n          e[t] = e[r], t = r;\n        }\n\n        e[t] = n;\n      }, c.tf = function (t) {\n        return 2 * t + 1;\n      }, c.zf = function (t) {\n        return 2 * t + 2;\n      }, c.wf = function (t) {\n        return t - 1 >> 1;\n      }, c.H = function () {\n        for (var t = this.Y, e = [], n = t.length, r = 0; r < n; r++) {\n          e.push(t[r].gd);\n        }\n\n        return e;\n      }, c.W = function () {\n        for (var t = this.Y, e = [], n = t.length, r = 0; r < n; r++) {\n          e.push(t[r].getKey());\n        }\n\n        return e;\n      }, c.va = function (t) {\n        return q(this.Y, function (e) {\n          return e.getKey() == t;\n        });\n      }, c.clone = function () {\n        return new On(this);\n      }, c.C = function () {\n        return this.Y.length;\n      }, c.X = function () {\n        return 0 == this.Y.length;\n      }, c.clear = function () {\n        F(this.Y);\n      }, A(_n, On), _n.prototype.enqueue = function (t, e) {\n        this.ce(t, e);\n      }, _n.prototype.ab = function () {\n        return this.remove();\n      }, A(Pn, kn), (c = Pn.prototype).Mb = function (t, e) {\n        if (!t) return (t = Pn.L.Mb.call(this)) && this.Ac && (this.Gd = f.setTimeout(C(this.Nb, this), this.Ac)), t;\n        this.cc.enqueue(void 0 !== e ? e : 100, t), this.Nb();\n      }, c.Nb = function () {\n        for (var t = this.cc; 0 < t.C();) {\n          var e = this.Mb();\n          if (!e) break;\n          t.ab().apply(this, [e]);\n        }\n      }, c.nc = function (t) {\n        Pn.L.nc.call(this, t), this.Nb();\n      }, c.Cb = function () {\n        Pn.L.Cb.call(this), this.Nb();\n      }, c.F = function () {\n        Pn.L.F.call(this), f.clearTimeout(this.Gd), this.cc.clear(), this.cc = null;\n      }, A(Ln, Pn), Ln.prototype.xc = function () {\n        var t = new dn(),\n            e = this.Jf;\n        return e && e.forEach(function (e, n) {\n          t.headers.set(n, e);\n        }), this.Ab && t.Je(!0), t;\n      }, Ln.prototype.Sc = function (t) {\n        return !t.Ka && !t.Ba();\n      }, Sn.prototype.createWebChannel = Sn.prototype.cf, Tn.prototype.send = Tn.prototype.send, Tn.prototype.open = Tn.prototype.open, Tn.prototype.close = Tn.prototype.close, ke.NO_ERROR = 0, ke.TIMEOUT = 8, ke.HTTP_ERROR = 6, Re.COMPLETE = \"complete\", Oe.EventType = Pe, Pe.OPEN = \"a\", Pe.CLOSE = \"b\", Pe.ERROR = \"c\", Pe.MESSAGE = \"d\", Wt.prototype.listen = Wt.prototype.nb, Ln.prototype.getObject = Ln.prototype.Mb, Ln.prototype.releaseObject = Ln.prototype.og, dn.prototype.listenOnce = dn.prototype.Oc, dn.prototype.getLastError = dn.prototype.Hc, dn.prototype.getLastErrorCode = dn.prototype.Ud, dn.prototype.getStatus = dn.prototype.za, dn.prototype.getStatusText = dn.prototype.Yd, dn.prototype.getResponseJson = dn.prototype.yf, dn.prototype.getResponseText = dn.prototype.ya, dn.prototype.getResponseText = dn.prototype.ya, dn.prototype.send = dn.prototype.send;\n\n      var xn = {\n        createWebChannelTransport: Nn,\n        ErrorCode: ke,\n        EventType: Re,\n        WebChannel: Oe,\n        XhrIoPool: Ln\n      },\n          qn = xn.createWebChannelTransport,\n          Fn = xn.ErrorCode,\n          Bn = xn.EventType,\n          Un = xn.WebChannel,\n          Vn = xn.XhrIoPool,\n          Qn = \"FirebaseError\",\n          Kn = Error.captureStackTrace,\n          Wn = function () {\n        return function (t, e) {\n          if (this.code = t, this.message = e, Kn) Kn(this, Gn.prototype.create);else try {\n            throw Error.apply(this, arguments);\n          } catch (t) {\n            this.name = Qn, Object.defineProperty(this, \"stack\", {\n              get: function get() {\n                return t.stack;\n              }\n            });\n          }\n        };\n      }();\n\n      Wn.prototype = Object.create(Error.prototype), Wn.prototype.constructor = Wn, Wn.prototype.name = Qn;\n\n      var jn,\n          zn,\n          Gn = function () {\n        function t(t, e, n) {\n          this.service = t, this.serviceName = e, this.errors = n, this.pattern = /\\{\\$([^}]+)}/g;\n        }\n\n        return t.prototype.create = function (t, e) {\n          void 0 === e && (e = {});\n          var n,\n              r = this.errors[t],\n              i = this.service + \"/\" + t;\n          n = void 0 === r ? \"Error\" : r.replace(this.pattern, function (t, n) {\n            var r = e[n];\n            return void 0 !== r ? r.toString() : \"<\" + n + \"?>\";\n          }), n = this.serviceName + \": \" + n + \" (\" + i + \").\";\n          var o = new Wn(i, n);\n\n          for (var s in e) {\n            e.hasOwnProperty(s) && \"_\" !== s.slice(-1) && (o[s] = e[s]);\n          }\n\n          return o;\n        }, t;\n      }(),\n          Hn = (function (t) {\n        function e() {\n          var e = t.call(this) || this;\n          e.chain_ = [], e.buf_ = [], e.W_ = [], e.pad_ = [], e.inbuf_ = 0, e.total_ = 0, e.blockSize = 64, e.pad_[0] = 128;\n\n          for (var n = 1; n < e.blockSize; ++n) {\n            e.pad_[n] = 0;\n          }\n\n          return e.reset(), e;\n        }\n\n        s(e, t), e.prototype.reset = function () {\n          this.chain_[0] = 1732584193, this.chain_[1] = 4023233417, this.chain_[2] = 2562383102, this.chain_[3] = 271733878, this.chain_[4] = 3285377520, this.inbuf_ = 0, this.total_ = 0;\n        }, e.prototype.compress_ = function (t, e) {\n          e || (e = 0);\n          var n = this.W_;\n          if (\"string\" == typeof t) for (var r = 0; r < 16; r++) {\n            n[r] = t.charCodeAt(e) << 24 | t.charCodeAt(e + 1) << 16 | t.charCodeAt(e + 2) << 8 | t.charCodeAt(e + 3), e += 4;\n          } else for (r = 0; r < 16; r++) {\n            n[r] = t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3], e += 4;\n          }\n\n          for (r = 16; r < 80; r++) {\n            var i = n[r - 3] ^ n[r - 8] ^ n[r - 14] ^ n[r - 16];\n            n[r] = 4294967295 & (i << 1 | i >>> 31);\n          }\n\n          var o,\n              s,\n              a = this.chain_[0],\n              u = this.chain_[1],\n              c = this.chain_[2],\n              h = this.chain_[3],\n              l = this.chain_[4];\n\n          for (r = 0; r < 80; r++) {\n            r < 40 ? r < 20 ? (o = h ^ u & (c ^ h), s = 1518500249) : (o = u ^ c ^ h, s = 1859775393) : r < 60 ? (o = u & c | h & (u | c), s = 2400959708) : (o = u ^ c ^ h, s = 3395469782);\n            i = (a << 5 | a >>> 27) + o + l + s + n[r] & 4294967295;\n            l = h, h = c, c = 4294967295 & (u << 30 | u >>> 2), u = a, a = i;\n          }\n\n          this.chain_[0] = this.chain_[0] + a & 4294967295, this.chain_[1] = this.chain_[1] + u & 4294967295, this.chain_[2] = this.chain_[2] + c & 4294967295, this.chain_[3] = this.chain_[3] + h & 4294967295, this.chain_[4] = this.chain_[4] + l & 4294967295;\n        }, e.prototype.update = function (t, e) {\n          if (null != t) {\n            void 0 === e && (e = t.length);\n\n            for (var n = e - this.blockSize, r = 0, i = this.buf_, o = this.inbuf_; r < e;) {\n              if (0 == o) for (; r <= n;) {\n                this.compress_(t, r), r += this.blockSize;\n              }\n\n              if (\"string\" == typeof t) {\n                for (; r < e;) {\n                  if (i[o] = t.charCodeAt(r), ++r, ++o == this.blockSize) {\n                    this.compress_(i), o = 0;\n                    break;\n                  }\n                }\n              } else for (; r < e;) {\n                if (i[o] = t[r], ++r, ++o == this.blockSize) {\n                  this.compress_(i), o = 0;\n                  break;\n                }\n              }\n            }\n\n            this.inbuf_ = o, this.total_ += e;\n          }\n        }, e.prototype.digest = function () {\n          var t = [],\n              e = 8 * this.total_;\n          this.inbuf_ < 56 ? this.update(this.pad_, 56 - this.inbuf_) : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n\n          for (var n = this.blockSize - 1; n >= 56; n--) {\n            this.buf_[n] = 255 & e, e /= 256;\n          }\n\n          this.compress_(this.buf_);\n          var r = 0;\n\n          for (n = 0; n < 5; n++) {\n            for (var i = 24; i >= 0; i -= 8) {\n              t[r] = this.chain_[n] >> i & 255, ++r;\n            }\n          }\n\n          return t;\n        };\n      }(function () {\n        return function () {\n          this.blockSize = -1;\n        };\n      }()), t.SDK_VERSION),\n          Xn = new i(\"@firebase/firestore\");\n\n      function Yn() {\n        return Xn.logLevel === e.DEBUG ? jn.DEBUG : Xn.logLevel === e.SILENT ? jn.SILENT : jn.ERROR;\n      }\n\n      function Jn(t) {\n        switch (t) {\n          case jn.DEBUG:\n            Xn.logLevel = e.DEBUG;\n            break;\n\n          case jn.ERROR:\n            Xn.logLevel = e.ERROR;\n            break;\n\n          case jn.SILENT:\n            Xn.logLevel = e.SILENT;\n            break;\n\n          default:\n            Xn.error(\"Firestore (\" + Hn + \"): Invalid value passed to `setLogLevel`\");\n        }\n      }\n\n      function Zn(t, n) {\n        for (var r = [], i = 2; i < arguments.length; i++) {\n          r[i - 2] = arguments[i];\n        }\n\n        if (Xn.logLevel <= e.DEBUG) {\n          var o = r.map(tr);\n          Xn.debug.apply(Xn, [\"Firestore (\" + Hn + \") [\" + t + \"]: \" + n].concat(o));\n        }\n      }\n\n      function $n(t) {\n        for (var n = [], r = 1; r < arguments.length; r++) {\n          n[r - 1] = arguments[r];\n        }\n\n        if (Xn.logLevel <= e.ERROR) {\n          var i = n.map(tr);\n          Xn.error.apply(Xn, [\"Firestore (\" + Hn + \"): \" + t].concat(i));\n        }\n      }\n\n      function tr(t) {\n        if (\"string\" == typeof t) return t;\n        var e = rr.getPlatform();\n\n        try {\n          return e.formatJSON(t);\n        } catch (e) {\n          return t;\n        }\n      }\n\n      function er(t) {\n        var e = \"FIRESTORE (\" + Hn + \") INTERNAL ASSERTION FAILED: \" + t;\n        throw $n(e), new Error(e);\n      }\n\n      function nr(t, e) {\n        t || er(e);\n      }\n\n      (zn = jn || (jn = {}))[zn.DEBUG = 0] = \"DEBUG\", zn[zn.ERROR = 1] = \"ERROR\", zn[zn.SILENT = 2] = \"SILENT\";\n\n      var rr = function () {\n        function t() {}\n\n        return t.setPlatform = function (e) {\n          t.platform && er(\"Platform already defined\"), t.platform = e;\n        }, t.getPlatform = function () {\n          return t.platform || er(\"Platform not set\"), t.platform;\n        }, t;\n      }();\n\n      function ir() {\n        return rr.getPlatform().emptyByteString;\n      }\n\n      var or = {\n        OK: \"ok\",\n        CANCELLED: \"cancelled\",\n        UNKNOWN: \"unknown\",\n        INVALID_ARGUMENT: \"invalid-argument\",\n        DEADLINE_EXCEEDED: \"deadline-exceeded\",\n        NOT_FOUND: \"not-found\",\n        ALREADY_EXISTS: \"already-exists\",\n        PERMISSION_DENIED: \"permission-denied\",\n        UNAUTHENTICATED: \"unauthenticated\",\n        RESOURCE_EXHAUSTED: \"resource-exhausted\",\n        FAILED_PRECONDITION: \"failed-precondition\",\n        ABORTED: \"aborted\",\n        OUT_OF_RANGE: \"out-of-range\",\n        UNIMPLEMENTED: \"unimplemented\",\n        INTERNAL: \"internal\",\n        UNAVAILABLE: \"unavailable\",\n        DATA_LOSS: \"data-loss\"\n      },\n          sr = function (t) {\n        function e(e, n) {\n          var r = t.call(this, n) || this;\n          return r.code = e, r.message = n, r.name = \"FirebaseError\", r.toString = function () {\n            return r.name + \": [code=\" + r.code + \"]: \" + r.message;\n          }, r;\n        }\n\n        return s(e, t), e;\n      }(Error);\n\n      function ar(t, e) {\n        function n() {\n          var t = \"This constructor is private.\";\n          throw e && (t += \" \", t += e), new sr(or.INVALID_ARGUMENT, t);\n        }\n\n        for (var r in n.prototype = t.prototype, t) {\n          t.hasOwnProperty(r) && (n[r] = t[r]);\n        }\n\n        return n;\n      }\n\n      function ur(t, e) {\n        return Object.prototype.hasOwnProperty.call(t, e);\n      }\n\n      function cr(t, e) {\n        return void 0 !== t ? t : e;\n      }\n\n      function hr(t, e) {\n        for (var n in t) {\n          if (Object.prototype.hasOwnProperty.call(t, n)) {\n            var r = Number(n);\n            isNaN(r) || e(r, t[n]);\n          }\n        }\n      }\n\n      function lr(t, e) {\n        for (var n in t) {\n          Object.prototype.hasOwnProperty.call(t, n) && e(n, t[n]);\n        }\n      }\n\n      function fr(t) {\n        for (var e in nr(null != t && \"object\" == typeof t, \"isEmpty() expects object parameter.\"), t) {\n          if (Object.prototype.hasOwnProperty.call(t, e)) return !1;\n        }\n\n        return !0;\n      }\n\n      function dr(t, e, n) {\n        if (e.length !== n) throw new sr(or.INVALID_ARGUMENT, \"Function \" + t + \"() requires \" + kr(n, \"argument\") + \", but was called with \" + kr(e.length, \"argument\") + \".\");\n      }\n\n      function pr(t, e, n) {\n        if (e.length < n) throw new sr(or.INVALID_ARGUMENT, \"Function \" + t + \"() requires at least \" + kr(n, \"argument\") + \", but was called with \" + kr(e.length, \"argument\") + \".\");\n      }\n\n      function mr(t, e, n, r) {\n        if (e.length < n || e.length > r) throw new sr(or.INVALID_ARGUMENT, \"Function \" + t + \"() requires between \" + n + \" and \" + r + \" arguments, but was called with \" + kr(e.length, \"argument\") + \".\");\n      }\n\n      function yr(t, e, n, r) {\n        Sr(t, e, Ar(n) + \" argument\", r);\n      }\n\n      function gr(t, e, n, r) {\n        void 0 !== r && yr(t, e, n, r);\n      }\n\n      function vr(t, e, n, r) {\n        Sr(t, e, n + \" option\", r);\n      }\n\n      function br(t, e, n, r) {\n        void 0 !== r && vr(t, e, n, r);\n      }\n\n      function wr(t, e, n, r, i) {\n        void 0 !== r && function (t, e, n, r, i) {\n          if (!(r instanceof Array)) throw new sr(or.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + e + \" option to be an array, but it was: \" + Ir(r));\n\n          for (var o = 0; o < r.length; ++o) {\n            if (!i(r[o])) throw new sr(or.INVALID_ARGUMENT, \"Function \" + t + \"() requires all \" + e + \" elements to be \" + n + \", but the value at index \" + o + \" was: \" + Ir(r[o]));\n          }\n        }(t, e, n, r, i);\n      }\n\n      function Er(t, e, n, r, i) {\n        void 0 !== r && function (t, e, n, r, i) {\n          for (var o = [], s = 0, a = i; s < a.length; s++) {\n            var u = a[s];\n            if (u === r) return;\n            o.push(Ir(u));\n          }\n\n          var c = Ir(r);\n          throw new sr(or.INVALID_ARGUMENT, \"Invalid value \" + c + \" provided to function \" + t + '() for option \"' + n + '\". Acceptable values: ' + o.join(\", \"));\n        }(t, 0, n, r, i);\n      }\n\n      function Sr(t, e, n, r) {\n        if (!(\"object\" === e ? Tr(r) : \"non-empty string\" === e ? \"string\" == typeof r && \"\" !== r : typeof r === e)) {\n          var i = Ir(r);\n          throw new sr(or.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + n + \" to be of type \" + e + \", but it was: \" + i);\n        }\n      }\n\n      function Tr(t) {\n        return \"object\" == typeof t && null !== t && (Object.getPrototypeOf(t) === Object.prototype || null === Object.getPrototypeOf(t));\n      }\n\n      function Ir(t) {\n        if (void 0 === t) return \"undefined\";\n        if (null === t) return \"null\";\n        if (\"string\" == typeof t) return t.length > 20 && (t = t.substring(0, 20) + \"...\"), JSON.stringify(t);\n        if (\"number\" == typeof t || \"boolean\" == typeof t) return \"\" + t;\n\n        if (\"object\" == typeof t) {\n          if (t instanceof Array) return \"an array\";\n\n          var e = function (t) {\n            if (t.constructor) {\n              var e = /function\\s+([^\\s(]+)\\s*\\(/.exec(t.constructor.toString());\n              if (e && e.length > 1) return e[1];\n            }\n\n            return null;\n          }(t);\n\n          return e ? \"a custom \" + e + \" object\" : \"an object\";\n        }\n\n        return \"function\" == typeof t ? \"a function\" : er(\"Unknown wrong type: \" + typeof t);\n      }\n\n      function Cr(t, e, n) {\n        if (void 0 === n) throw new sr(or.INVALID_ARGUMENT, \"Function \" + t + \"() requires a valid \" + Ar(e) + \" argument, but it was undefined.\");\n      }\n\n      function Dr(t, e, n) {\n        lr(e, function (e, r) {\n          if (n.indexOf(e) < 0) throw new sr(or.INVALID_ARGUMENT, \"Unknown option '\" + e + \"' passed to function \" + t + \"(). Available options: \" + n.join(\", \"));\n        });\n      }\n\n      function Nr(t, e, n, r) {\n        var i = Ir(r);\n        return new sr(or.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + Ar(n) + \" argument to be a \" + e + \", but it was: \" + i);\n      }\n\n      function Ar(t) {\n        switch (t) {\n          case 1:\n            return \"first\";\n\n          case 2:\n            return \"second\";\n\n          case 3:\n            return \"third\";\n\n          default:\n            return t + \"th\";\n        }\n      }\n\n      function kr(t, e) {\n        return t + \" \" + e + (1 === t ? \"\" : \"s\");\n      }\n\n      var Rr = function () {\n        function t() {}\n\n        return t.newId = function () {\n          for (var t = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", e = \"\", n = 0; n < 20; n++) {\n            e += t.charAt(Math.floor(Math.random() * t.length));\n          }\n\n          return nr(20 === e.length, \"Invalid auto ID: \" + e), e;\n        }, t;\n      }();\n\n      function Mr(t, e) {\n        return t < e ? -1 : t > e ? 1 : 0;\n      }\n\n      function Or(t, e) {\n        if (t.length !== e.length) return !1;\n\n        for (var n = 0; n < t.length; n++) {\n          if (!t[n].isEqual(e[n])) return !1;\n        }\n\n        return !0;\n      }\n\n      function _r() {\n        if (\"undefined\" == typeof Uint8Array) throw new sr(or.UNIMPLEMENTED, \"Uint8Arrays are not available in this environment.\");\n      }\n\n      function Pr() {\n        if (!rr.getPlatform().base64Available) throw new sr(or.UNIMPLEMENTED, \"Blobs are unavailable in Firestore in this environment.\");\n      }\n\n      var Lr,\n          xr,\n          qr = function () {\n        function t(t) {\n          Pr(), this._binaryString = t;\n        }\n\n        return t.fromBase64String = function (e) {\n          dr(\"Blob.fromBase64String\", arguments, 1), yr(\"Blob.fromBase64String\", \"string\", 1, e), Pr();\n\n          try {\n            return new t(rr.getPlatform().atob(e));\n          } catch (t) {\n            throw new sr(or.INVALID_ARGUMENT, \"Failed to construct Blob from Base64 string: \" + t);\n          }\n        }, t.fromUint8Array = function (e) {\n          if (dr(\"Blob.fromUint8Array\", arguments, 1), _r(), !(e instanceof Uint8Array)) throw Nr(\"Blob.fromUint8Array\", \"Uint8Array\", 1, e);\n          return new t(Array.prototype.map.call(e, function (t) {\n            return String.fromCharCode(t);\n          }).join(\"\"));\n        }, t.prototype.toBase64 = function () {\n          return dr(\"Blob.toBase64\", arguments, 0), Pr(), rr.getPlatform().btoa(this._binaryString);\n        }, t.prototype.toUint8Array = function () {\n          dr(\"Blob.toUint8Array\", arguments, 0), _r();\n\n          for (var t = new Uint8Array(this._binaryString.length), e = 0; e < this._binaryString.length; e++) {\n            t[e] = this._binaryString.charCodeAt(e);\n          }\n\n          return t;\n        }, t.prototype.toString = function () {\n          return \"Blob(base64: \" + this.toBase64() + \")\";\n        }, t.prototype.isEqual = function (t) {\n          return this._binaryString === t._binaryString;\n        }, t.prototype._compareTo = function (t) {\n          return Mr(this._binaryString, t._binaryString);\n        }, t;\n      }(),\n          Fr = ar(qr, \"Use Blob.fromUint8Array() or Blob.fromBase64String() instead.\"),\n          Br = function () {\n        function t(t, e) {\n          if (dr(\"GeoPoint\", arguments, 2), yr(\"GeoPoint\", \"number\", 1, t), yr(\"GeoPoint\", \"number\", 2, e), !isFinite(t) || t < -90 || t > 90) throw new sr(or.INVALID_ARGUMENT, \"Latitude must be a number between -90 and 90, but was: \" + t);\n          if (!isFinite(e) || e < -180 || e > 180) throw new sr(or.INVALID_ARGUMENT, \"Longitude must be a number between -180 and 180, but was: \" + e);\n          this._lat = t, this._long = e;\n        }\n\n        return Object.defineProperty(t.prototype, \"latitude\", {\n          get: function get() {\n            return this._lat;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"longitude\", {\n          get: function get() {\n            return this._long;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.isEqual = function (t) {\n          return this._lat === t._lat && this._long === t._long;\n        }, t.prototype._compareTo = function (t) {\n          return Mr(this._lat, t._lat) || Mr(this._long, t._long);\n        }, t;\n      }(),\n          Ur = function () {\n        function t(t, e) {\n          if (this.seconds = t, this.nanoseconds = e, e < 0) throw new sr(or.INVALID_ARGUMENT, \"Timestamp nanoseconds out of range: \" + e);\n          if (e >= 1e9) throw new sr(or.INVALID_ARGUMENT, \"Timestamp nanoseconds out of range: \" + e);\n          if (t < -62135596800) throw new sr(or.INVALID_ARGUMENT, \"Timestamp seconds out of range: \" + t);\n          if (t >= 253402300800) throw new sr(or.INVALID_ARGUMENT, \"Timestamp seconds out of range: \" + t);\n        }\n\n        return t.now = function () {\n          return t.fromMillis(Date.now());\n        }, t.fromDate = function (e) {\n          return t.fromMillis(e.getTime());\n        }, t.fromMillis = function (e) {\n          var n = Math.floor(e / 1e3);\n          return new t(n, 1e6 * (e - 1e3 * n));\n        }, t.prototype.toDate = function () {\n          return new Date(this.toMillis());\n        }, t.prototype.toMillis = function () {\n          return 1e3 * this.seconds + this.nanoseconds / 1e6;\n        }, t.prototype._compareTo = function (t) {\n          return this.seconds === t.seconds ? Mr(this.nanoseconds, t.nanoseconds) : Mr(this.seconds, t.seconds);\n        }, t.prototype.isEqual = function (t) {\n          return t.seconds === this.seconds && t.nanoseconds === this.nanoseconds;\n        }, t.prototype.toString = function () {\n          return \"Timestamp(seconds=\" + this.seconds + \", nanoseconds=\" + this.nanoseconds + \")\";\n        }, t;\n      }(),\n          Vr = function () {\n        return function (t, e, n, r) {\n          this.databaseId = t, this.persistenceKey = e, this.host = n, this.ssl = r;\n        };\n      }(),\n          Qr = \"(default)\",\n          Kr = function () {\n        function t(t, e) {\n          this.projectId = t, this.database = e || Qr;\n        }\n\n        return Object.defineProperty(t.prototype, \"isDefaultDatabase\", {\n          get: function get() {\n            return this.database === Qr;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.isEqual = function (e) {\n          return e instanceof t && e.projectId === this.projectId && e.database === this.database;\n        }, t.prototype.compareTo = function (t) {\n          return Mr(this.projectId, t.projectId) || Mr(this.database, t.database);\n        }, t;\n      }(),\n          Wr = function () {\n        function t(t, e, n) {\n          this.init(t, e, n);\n        }\n\n        return t.prototype.init = function (t, e, n) {\n          void 0 === e ? e = 0 : e > t.length && er(\"offset \" + e + \" out of range \" + t.length), void 0 === n ? n = t.length - e : n > t.length - e && er(\"length \" + n + \" out of range \" + (t.length - e)), this.segments = t, this.offset = e, this.len = n;\n        }, t.prototype.construct = function (t, e, n) {\n          var r = Object.create(Object.getPrototypeOf(this));\n          return r.init(t, e, n), r;\n        }, Object.defineProperty(t.prototype, \"length\", {\n          get: function get() {\n            return this.len;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.isEqual = function (e) {\n          return 0 === t.comparator(this, e);\n        }, t.prototype.child = function (e) {\n          var n = this.segments.slice(this.offset, this.limit());\n          return e instanceof t ? e.forEach(function (t) {\n            n.push(t);\n          }) : \"string\" == typeof e ? n.push(e) : er(\"Unknown parameter type for Path.child(): \" + e), this.construct(n);\n        }, t.prototype.limit = function () {\n          return this.offset + this.length;\n        }, t.prototype.popFirst = function (t) {\n          return t = void 0 === t ? 1 : t, nr(this.length >= t, \"Can't call popFirst() with less segments\"), this.construct(this.segments, this.offset + t, this.length - t);\n        }, t.prototype.popLast = function () {\n          return nr(!this.isEmpty(), \"Can't call popLast() on empty path\"), this.construct(this.segments, this.offset, this.length - 1);\n        }, t.prototype.firstSegment = function () {\n          return nr(!this.isEmpty(), \"Can't call firstSegment() on empty path\"), this.segments[this.offset];\n        }, t.prototype.lastSegment = function () {\n          return nr(!this.isEmpty(), \"Can't call lastSegment() on empty path\"), this.segments[this.limit() - 1];\n        }, t.prototype.get = function (t) {\n          return nr(t < this.length, \"Index out of range\"), this.segments[this.offset + t];\n        }, t.prototype.isEmpty = function () {\n          return 0 === this.length;\n        }, t.prototype.isPrefixOf = function (t) {\n          if (t.length < this.length) return !1;\n\n          for (var e = 0; e < this.length; e++) {\n            if (this.get(e) !== t.get(e)) return !1;\n          }\n\n          return !0;\n        }, t.prototype.isImmediateParentOf = function (t) {\n          if (this.length + 1 !== t.length) return !1;\n\n          for (var e = 0; e < this.length; e++) {\n            if (this.get(e) !== t.get(e)) return !1;\n          }\n\n          return !0;\n        }, t.prototype.forEach = function (t) {\n          for (var e = this.offset, n = this.limit(); e < n; e++) {\n            t(this.segments[e]);\n          }\n        }, t.prototype.toArray = function () {\n          return this.segments.slice(this.offset, this.limit());\n        }, t.comparator = function (t, e) {\n          for (var n = Math.min(t.length, e.length), r = 0; r < n; r++) {\n            var i = t.get(r),\n                o = e.get(r);\n            if (i < o) return -1;\n            if (i > o) return 1;\n          }\n\n          return t.length < e.length ? -1 : t.length > e.length ? 1 : 0;\n        }, t;\n      }(),\n          jr = function (t) {\n        function e() {\n          return null !== t && t.apply(this, arguments) || this;\n        }\n\n        return s(e, t), e.prototype.canonicalString = function () {\n          return this.toArray().join(\"/\");\n        }, e.prototype.toString = function () {\n          return this.canonicalString();\n        }, e.fromString = function (t) {\n          if (t.indexOf(\"//\") >= 0) throw new sr(or.INVALID_ARGUMENT, \"Invalid path (\" + t + \"). Paths must not contain // in them.\");\n          return new e(t.split(\"/\").filter(function (t) {\n            return t.length > 0;\n          }));\n        }, e.EMPTY_PATH = new e([]), e;\n      }(Wr),\n          zr = /^[_a-zA-Z][_a-zA-Z0-9]*$/,\n          Gr = function (t) {\n        function e() {\n          return null !== t && t.apply(this, arguments) || this;\n        }\n\n        return s(e, t), e.isValidIdentifier = function (t) {\n          return zr.test(t);\n        }, e.prototype.canonicalString = function () {\n          return this.toArray().map(function (t) {\n            return t = t.replace(\"\\\\\", \"\\\\\\\\\").replace(\"`\", \"\\\\`\"), e.isValidIdentifier(t) || (t = \"`\" + t + \"`\"), t;\n          }).join(\".\");\n        }, e.prototype.toString = function () {\n          return this.canonicalString();\n        }, e.prototype.isKeyField = function () {\n          return 1 === this.length && \"__name__\" === this.get(0);\n        }, e.keyField = function () {\n          return new e([\"__name__\"]);\n        }, e.fromServerFormat = function (t) {\n          for (var n = [], r = \"\", i = 0, o = function o() {\n            if (0 === r.length) throw new sr(or.INVALID_ARGUMENT, \"Invalid field path (\" + t + \"). Paths must not be empty, begin with '.', end with '.', or contain '..'\");\n            n.push(r), r = \"\";\n          }, s = !1; i < t.length;) {\n            var a = t[i];\n\n            if (\"\\\\\" === a) {\n              if (i + 1 === t.length) throw new sr(or.INVALID_ARGUMENT, \"Path has trailing escape character: \" + t);\n              var u = t[i + 1];\n              if (\"\\\\\" !== u && \".\" !== u && \"`\" !== u) throw new sr(or.INVALID_ARGUMENT, \"Path has invalid escape sequence: \" + t);\n              r += u, i += 2;\n            } else \"`\" === a ? (s = !s, i++) : \".\" !== a || s ? (r += a, i++) : (o(), i++);\n          }\n\n          if (o(), s) throw new sr(or.INVALID_ARGUMENT, \"Unterminated ` in path: \" + t);\n          return new e(n);\n        }, e.EMPTY_PATH = new e([]), e;\n      }(Wr),\n          Hr = function () {\n        function t(e) {\n          this.path = e, nr(t.isDocumentKey(e), \"Invalid DocumentKey with an odd number of segments: \" + e.toArray().join(\"/\"));\n        }\n\n        return t.prototype.isEqual = function (t) {\n          return null !== t && 0 === jr.comparator(this.path, t.path);\n        }, t.prototype.toString = function () {\n          return this.path.toString();\n        }, t.comparator = function (t, e) {\n          return jr.comparator(t.path, e.path);\n        }, t.isDocumentKey = function (t) {\n          return t.length % 2 == 0;\n        }, t.fromSegments = function (e) {\n          return new t(new jr(e.slice()));\n        }, t.fromPathString = function (e) {\n          return new t(jr.fromString(e));\n        }, t.EMPTY = new t(new jr([])), t;\n      }(),\n          Xr = function () {\n        function t(t, e) {\n          this.key = t, this.version = e;\n        }\n\n        return t.compareByKey = function (t, e) {\n          return Hr.comparator(t.key, e.key);\n        }, t;\n      }(),\n          Yr = function (t) {\n        function e(e, n, r, i, o) {\n          var s = t.call(this, e, n) || this;\n          return s.data = r, s.proto = o, s.hasLocalMutations = !!i.hasLocalMutations, s.hasCommittedMutations = !!i.hasCommittedMutations, s;\n        }\n\n        return s(e, t), e.prototype.field = function (t) {\n          return this.data.field(t);\n        }, e.prototype.fieldValue = function (t) {\n          var e = this.field(t);\n          return e ? e.value() : void 0;\n        }, e.prototype.value = function () {\n          return this.data.value();\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && this.version.isEqual(t.version) && this.data.isEqual(t.data) && this.hasLocalMutations === t.hasLocalMutations && this.hasCommittedMutations === t.hasCommittedMutations;\n        }, e.prototype.toString = function () {\n          return \"Document(\" + this.key + \", \" + this.version + \", \" + this.data.toString() + \", {hasLocalMutations: \" + this.hasLocalMutations + \"}), {hasCommittedMutations: \" + this.hasCommittedMutations + \"})\";\n        }, Object.defineProperty(e.prototype, \"hasPendingWrites\", {\n          get: function get() {\n            return this.hasLocalMutations || this.hasCommittedMutations;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.compareByField = function (t, e, n) {\n          var r = e.field(t),\n              i = n.field(t);\n          return void 0 !== r && void 0 !== i ? r.compareTo(i) : er(\"Trying to compare documents on fields that don't exist\");\n        }, e;\n      }(Xr),\n          Jr = function (t) {\n        function e(e, n, r) {\n          var i = t.call(this, e, n) || this;\n          return i.hasCommittedMutations = !(!r || !r.hasCommittedMutations), i;\n        }\n\n        return s(e, t), e.prototype.toString = function () {\n          return \"NoDocument(\" + this.key + \", \" + this.version + \")\";\n        }, Object.defineProperty(e.prototype, \"hasPendingWrites\", {\n          get: function get() {\n            return this.hasCommittedMutations;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          return t instanceof e && t.hasCommittedMutations === this.hasCommittedMutations && t.version.isEqual(this.version) && t.key.isEqual(this.key);\n        }, e;\n      }(Xr),\n          Zr = function (t) {\n        function e(e, n) {\n          return t.call(this, e, n) || this;\n        }\n\n        return s(e, t), e.prototype.toString = function () {\n          return \"UnknownDocument(\" + this.key + \", \" + this.version + \")\";\n        }, Object.defineProperty(e.prototype, \"hasPendingWrites\", {\n          get: function get() {\n            return !0;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          return t instanceof e && t.version.isEqual(this.version) && t.key.isEqual(this.key);\n        }, e;\n      }(Xr),\n          $r = function () {\n        function t(t, e) {\n          this.comparator = t, this.root = e || ei.EMPTY;\n        }\n\n        return t.prototype.insert = function (e, n) {\n          return new t(this.comparator, this.root.insert(e, n, this.comparator).copy(null, null, ei.BLACK, null, null));\n        }, t.prototype.remove = function (e) {\n          return new t(this.comparator, this.root.remove(e, this.comparator).copy(null, null, ei.BLACK, null, null));\n        }, t.prototype.get = function (t) {\n          for (var e = this.root; !e.isEmpty();) {\n            var n = this.comparator(t, e.key);\n            if (0 === n) return e.value;\n            n < 0 ? e = e.left : n > 0 && (e = e.right);\n          }\n\n          return null;\n        }, t.prototype.indexOf = function (t) {\n          for (var e = 0, n = this.root; !n.isEmpty();) {\n            var r = this.comparator(t, n.key);\n            if (0 === r) return e + n.left.size;\n            r < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);\n          }\n\n          return -1;\n        }, t.prototype.isEmpty = function () {\n          return this.root.isEmpty();\n        }, Object.defineProperty(t.prototype, \"size\", {\n          get: function get() {\n            return this.root.size;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.minKey = function () {\n          return this.root.minKey();\n        }, t.prototype.maxKey = function () {\n          return this.root.maxKey();\n        }, t.prototype.inorderTraversal = function (t) {\n          return this.root.inorderTraversal(t);\n        }, t.prototype.forEach = function (t) {\n          this.inorderTraversal(function (e, n) {\n            return t(e, n), !1;\n          });\n        }, t.prototype.reverseTraversal = function (t) {\n          return this.root.reverseTraversal(t);\n        }, t.prototype.getIterator = function () {\n          return new ti(this.root, null, this.comparator, !1);\n        }, t.prototype.getIteratorFrom = function (t) {\n          return new ti(this.root, t, this.comparator, !1);\n        }, t.prototype.getReverseIterator = function () {\n          return new ti(this.root, null, this.comparator, !0);\n        }, t.prototype.getReverseIteratorFrom = function (t) {\n          return new ti(this.root, t, this.comparator, !0);\n        }, t;\n      }(),\n          ti = function () {\n        function t(t, e, n, r) {\n          this.isReverse = r, this.nodeStack = [];\n\n          for (var i = 1; !t.isEmpty();) {\n            if (i = e ? n(t.key, e) : 1, r && (i *= -1), i < 0) t = this.isReverse ? t.left : t.right;else {\n              if (0 === i) {\n                this.nodeStack.push(t);\n                break;\n              }\n\n              this.nodeStack.push(t), t = this.isReverse ? t.right : t.left;\n            }\n          }\n        }\n\n        return t.prototype.getNext = function () {\n          nr(this.nodeStack.length > 0, \"getNext() called on iterator when hasNext() is false.\");\n          var t = this.nodeStack.pop(),\n              e = {\n            key: t.key,\n            value: t.value\n          };\n          if (this.isReverse) for (t = t.left; !t.isEmpty();) {\n            this.nodeStack.push(t), t = t.right;\n          } else for (t = t.right; !t.isEmpty();) {\n            this.nodeStack.push(t), t = t.left;\n          }\n          return e;\n        }, t.prototype.hasNext = function () {\n          return this.nodeStack.length > 0;\n        }, t.prototype.peek = function () {\n          if (0 === this.nodeStack.length) return null;\n          var t = this.nodeStack[this.nodeStack.length - 1];\n          return {\n            key: t.key,\n            value: t.value\n          };\n        }, t;\n      }(),\n          ei = function () {\n        function t(e, n, r, i, o) {\n          this.key = e, this.value = n, this.color = null != r ? r : t.RED, this.left = null != i ? i : t.EMPTY, this.right = null != o ? o : t.EMPTY, this.size = this.left.size + 1 + this.right.size;\n        }\n\n        return t.prototype.copy = function (e, n, r, i, o) {\n          return new t(null != e ? e : this.key, null != n ? n : this.value, null != r ? r : this.color, null != i ? i : this.left, null != o ? o : this.right);\n        }, t.prototype.isEmpty = function () {\n          return !1;\n        }, t.prototype.inorderTraversal = function (t) {\n          return this.left.inorderTraversal(t) || t(this.key, this.value) || this.right.inorderTraversal(t);\n        }, t.prototype.reverseTraversal = function (t) {\n          return this.right.reverseTraversal(t) || t(this.key, this.value) || this.left.reverseTraversal(t);\n        }, t.prototype.min = function () {\n          return this.left.isEmpty() ? this : this.left.min();\n        }, t.prototype.minKey = function () {\n          return this.min().key;\n        }, t.prototype.maxKey = function () {\n          return this.right.isEmpty() ? this.key : this.right.maxKey();\n        }, t.prototype.insert = function (t, e, n) {\n          var r = this,\n              i = n(t, r.key);\n          return (r = i < 0 ? r.copy(null, null, null, r.left.insert(t, e, n), null) : 0 === i ? r.copy(null, e, null, null, null) : r.copy(null, null, null, null, r.right.insert(t, e, n))).fixUp();\n        }, t.prototype.removeMin = function () {\n          if (this.left.isEmpty()) return t.EMPTY;\n          var e = this;\n          return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), (e = e.copy(null, null, null, e.left.removeMin(), null)).fixUp();\n        }, t.prototype.remove = function (e, n) {\n          var r,\n              i = this;\n          if (n(e, i.key) < 0) i.left.isEmpty() || i.left.isRed() || i.left.left.isRed() || (i = i.moveRedLeft()), i = i.copy(null, null, null, i.left.remove(e, n), null);else {\n            if (i.left.isRed() && (i = i.rotateRight()), i.right.isEmpty() || i.right.isRed() || i.right.left.isRed() || (i = i.moveRedRight()), 0 === n(e, i.key)) {\n              if (i.right.isEmpty()) return t.EMPTY;\n              r = i.right.min(), i = i.copy(r.key, r.value, null, null, i.right.removeMin());\n            }\n\n            i = i.copy(null, null, null, null, i.right.remove(e, n));\n          }\n          return i.fixUp();\n        }, t.prototype.isRed = function () {\n          return this.color;\n        }, t.prototype.fixUp = function () {\n          var t = this;\n          return t.right.isRed() && !t.left.isRed() && (t = t.rotateLeft()), t.left.isRed() && t.left.left.isRed() && (t = t.rotateRight()), t.left.isRed() && t.right.isRed() && (t = t.colorFlip()), t;\n        }, t.prototype.moveRedLeft = function () {\n          var t = this.colorFlip();\n          return t.right.left.isRed() && (t = (t = (t = t.copy(null, null, null, null, t.right.rotateRight())).rotateLeft()).colorFlip()), t;\n        }, t.prototype.moveRedRight = function () {\n          var t = this.colorFlip();\n          return t.left.left.isRed() && (t = (t = t.rotateRight()).colorFlip()), t;\n        }, t.prototype.rotateLeft = function () {\n          var e = this.copy(null, null, t.RED, null, this.right.left);\n          return this.right.copy(null, null, this.color, e, null);\n        }, t.prototype.rotateRight = function () {\n          var e = this.copy(null, null, t.RED, this.left.right, null);\n          return this.left.copy(null, null, this.color, null, e);\n        }, t.prototype.colorFlip = function () {\n          var t = this.left.copy(null, null, !this.left.color, null, null),\n              e = this.right.copy(null, null, !this.right.color, null, null);\n          return this.copy(null, null, !this.color, t, e);\n        }, t.prototype.checkMaxDepth = function () {\n          var t = this.check();\n          return Math.pow(2, t) <= this.size + 1;\n        }, t.prototype.check = function () {\n          if (this.isRed() && this.left.isRed()) throw er(\"Red node has red child(\" + this.key + \",\" + this.value + \")\");\n          if (this.right.isRed()) throw er(\"Right child of (\" + this.key + \",\" + this.value + \") is red\");\n          var t = this.left.check();\n          if (t !== this.right.check()) throw er(\"Black depths differ\");\n          return t + (this.isRed() ? 0 : 1);\n        }, t.EMPTY = null, t.RED = !0, t.BLACK = !1, t;\n      }(),\n          ni = function () {\n        function t() {\n          this.size = 0;\n        }\n\n        return t.prototype.copy = function (t, e, n, r, i) {\n          return this;\n        }, t.prototype.insert = function (t, e, n) {\n          return new ei(t, e);\n        }, t.prototype.remove = function (t, e) {\n          return this;\n        }, t.prototype.isEmpty = function () {\n          return !0;\n        }, t.prototype.inorderTraversal = function (t) {\n          return !1;\n        }, t.prototype.reverseTraversal = function (t) {\n          return !1;\n        }, t.prototype.minKey = function () {\n          return null;\n        }, t.prototype.maxKey = function () {\n          return null;\n        }, t.prototype.isRed = function () {\n          return !1;\n        }, t.prototype.checkMaxDepth = function () {\n          return !0;\n        }, t.prototype.check = function () {\n          return 0;\n        }, t;\n      }();\n\n      ei.EMPTY = new ni(), function (t) {\n        t[t.NullValue = 0] = \"NullValue\", t[t.BooleanValue = 1] = \"BooleanValue\", t[t.NumberValue = 2] = \"NumberValue\", t[t.TimestampValue = 3] = \"TimestampValue\", t[t.StringValue = 4] = \"StringValue\", t[t.BlobValue = 5] = \"BlobValue\", t[t.RefValue = 6] = \"RefValue\", t[t.GeoPointValue = 7] = \"GeoPointValue\", t[t.ArrayValue = 8] = \"ArrayValue\", t[t.ObjectValue = 9] = \"ObjectValue\";\n      }(Lr || (Lr = {})), function (t) {\n        t[t.Default = 0] = \"Default\", t[t.Estimate = 1] = \"Estimate\", t[t.Previous = 2] = \"Previous\";\n      }(xr || (xr = {}));\n\n      var ri = function () {\n        function t(t, e) {\n          this.serverTimestampBehavior = t, this.timestampsInSnapshots = e;\n        }\n\n        return t.fromSnapshotOptions = function (e, n) {\n          switch (e.serverTimestamps) {\n            case \"estimate\":\n              return new t(xr.Estimate, n);\n\n            case \"previous\":\n              return new t(xr.Previous, n);\n\n            case \"none\":\n            case void 0:\n              return new t(xr.Default, n);\n\n            default:\n              return er(\"fromSnapshotOptions() called with invalid options.\");\n          }\n        }, t;\n      }(),\n          ii = function () {\n        function t() {}\n\n        return t.prototype.toString = function () {\n          var t = this.value();\n          return null === t ? \"null\" : t.toString();\n        }, t.prototype.defaultCompareTo = function (t) {\n          return nr(this.typeOrder !== t.typeOrder, \"Default compareTo should not be used for values of same type.\"), Mr(this.typeOrder, t.typeOrder);\n        }, t;\n      }(),\n          oi = function (t) {\n        function e() {\n          var e = t.call(this) || this;\n          return e.typeOrder = Lr.NullValue, e.internalValue = null, e;\n        }\n\n        return s(e, t), e.prototype.value = function (t) {\n          return null;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e;\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? 0 : this.defaultCompareTo(t);\n        }, e.INSTANCE = new e(), e;\n      }(ii),\n          si = function (t) {\n        function e(e) {\n          var n = t.call(this) || this;\n          return n.internalValue = e, n.typeOrder = Lr.BooleanValue, n;\n        }\n\n        return s(e, t), e.prototype.value = function (t) {\n          return this.internalValue;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.internalValue === t.internalValue;\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? Mr(this, t) : this.defaultCompareTo(t);\n        }, e.of = function (t) {\n          return t ? e.TRUE : e.FALSE;\n        }, e.TRUE = new e(!0), e.FALSE = new e(!1), e;\n      }(ii),\n          ai = function (t) {\n        function e(e) {\n          var n = t.call(this) || this;\n          return n.internalValue = e, n.typeOrder = Lr.NumberValue, n;\n        }\n\n        return s(e, t), e.prototype.value = function (t) {\n          return this.internalValue;\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? (n = this.internalValue, r = t.internalValue, n < r ? -1 : n > r ? 1 : n === r ? 0 : isNaN(n) ? isNaN(r) ? 0 : -1 : 1) : this.defaultCompareTo(t);\n          var n, r;\n        }, e;\n      }(ii);\n\n      function ui(t, e) {\n        return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e;\n      }\n\n      var ci = function (t) {\n        function e(e) {\n          return t.call(this, e) || this;\n        }\n\n        return s(e, t), e.prototype.isEqual = function (t) {\n          return t instanceof e && ui(this.internalValue, t.internalValue);\n        }, e;\n      }(ai),\n          hi = function (t) {\n        function e(e) {\n          var n = t.call(this, e) || this;\n          return n.internalValue = e, n;\n        }\n\n        return s(e, t), e.prototype.isEqual = function (t) {\n          return t instanceof e && ui(this.internalValue, t.internalValue);\n        }, e.NAN = new e(NaN), e.POSITIVE_INFINITY = new e(1 / 0), e.NEGATIVE_INFINITY = new e(-1 / 0), e;\n      }(ai),\n          li = function (t) {\n        function e(e) {\n          var n = t.call(this) || this;\n          return n.internalValue = e, n.typeOrder = Lr.StringValue, n;\n        }\n\n        return s(e, t), e.prototype.value = function (t) {\n          return this.internalValue;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.internalValue === t.internalValue;\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? Mr(this.internalValue, t.internalValue) : this.defaultCompareTo(t);\n        }, e;\n      }(ii),\n          fi = function (t) {\n        function e(e) {\n          var n = t.call(this) || this;\n          return n.internalValue = e, n.typeOrder = Lr.TimestampValue, n;\n        }\n\n        return s(e, t), e.prototype.value = function (t) {\n          return !t || t.timestampsInSnapshots ? this.internalValue : this.internalValue.toDate();\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.internalValue.isEqual(t.internalValue);\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? this.internalValue._compareTo(t.internalValue) : t instanceof di ? -1 : this.defaultCompareTo(t);\n        }, e;\n      }(ii),\n          di = function (t) {\n        function e(e, n) {\n          var r = t.call(this) || this;\n          return r.localWriteTime = e, r.previousValue = n, r.typeOrder = Lr.TimestampValue, r;\n        }\n\n        return s(e, t), e.prototype.value = function (t) {\n          return t && t.serverTimestampBehavior === xr.Estimate ? new fi(this.localWriteTime).value(t) : t && t.serverTimestampBehavior === xr.Previous && this.previousValue ? this.previousValue.value(t) : null;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.localWriteTime.isEqual(t.localWriteTime);\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? this.localWriteTime._compareTo(t.localWriteTime) : t instanceof fi ? 1 : this.defaultCompareTo(t);\n        }, e.prototype.toString = function () {\n          return \"<ServerTimestamp localTime=\" + this.localWriteTime.toString() + \">\";\n        }, e;\n      }(ii),\n          pi = function (t) {\n        function e(e) {\n          var n = t.call(this) || this;\n          return n.internalValue = e, n.typeOrder = Lr.BlobValue, n;\n        }\n\n        return s(e, t), e.prototype.value = function (t) {\n          return this.internalValue;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.internalValue.isEqual(t.internalValue);\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? this.internalValue._compareTo(t.internalValue) : this.defaultCompareTo(t);\n        }, e;\n      }(ii),\n          mi = function (t) {\n        function e(e, n) {\n          var r = t.call(this) || this;\n          return r.databaseId = e, r.key = n, r.typeOrder = Lr.RefValue, r;\n        }\n\n        return s(e, t), e.prototype.value = function (t) {\n          return this.key;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && this.databaseId.isEqual(t.databaseId);\n        }, e.prototype.compareTo = function (t) {\n          if (t instanceof e) {\n            var n = this.databaseId.compareTo(t.databaseId);\n            return 0 !== n ? n : Hr.comparator(this.key, t.key);\n          }\n\n          return this.defaultCompareTo(t);\n        }, e;\n      }(ii),\n          yi = function (t) {\n        function e(e) {\n          var n = t.call(this) || this;\n          return n.internalValue = e, n.typeOrder = Lr.GeoPointValue, n;\n        }\n\n        return s(e, t), e.prototype.value = function (t) {\n          return this.internalValue;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.internalValue.isEqual(t.internalValue);\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? this.internalValue._compareTo(t.internalValue) : this.defaultCompareTo(t);\n        }, e;\n      }(ii),\n          gi = function (t) {\n        function e(e) {\n          var n = t.call(this) || this;\n          return n.internalValue = e, n.typeOrder = Lr.ObjectValue, n;\n        }\n\n        return s(e, t), e.prototype.value = function (t) {\n          var e = {};\n          return this.internalValue.inorderTraversal(function (n, r) {\n            e[n] = r.value(t);\n          }), e;\n        }, e.prototype.forEach = function (t) {\n          this.internalValue.inorderTraversal(t);\n        }, e.prototype.isEqual = function (t) {\n          if (t instanceof e) {\n            for (var n = this.internalValue.getIterator(), r = t.internalValue.getIterator(); n.hasNext() && r.hasNext();) {\n              var i = n.getNext(),\n                  o = r.getNext();\n              if (i.key !== o.key || !i.value.isEqual(o.value)) return !1;\n            }\n\n            return !n.hasNext() && !r.hasNext();\n          }\n\n          return !1;\n        }, e.prototype.compareTo = function (t) {\n          if (t instanceof e) {\n            for (var n = this.internalValue.getIterator(), r = t.internalValue.getIterator(); n.hasNext() && r.hasNext();) {\n              var i = n.getNext(),\n                  o = r.getNext(),\n                  s = Mr(i.key, o.key) || i.value.compareTo(o.value);\n              if (s) return s;\n            }\n\n            return Mr(n.hasNext(), r.hasNext());\n          }\n\n          return this.defaultCompareTo(t);\n        }, e.prototype.set = function (t, n) {\n          if (nr(!t.isEmpty(), \"Cannot set field for empty path on ObjectValue\"), 1 === t.length) return this.setChild(t.firstSegment(), n);\n          var r = this.child(t.firstSegment());\n          r instanceof e || (r = e.EMPTY);\n          var i = r.set(t.popFirst(), n);\n          return this.setChild(t.firstSegment(), i);\n        }, e.prototype.delete = function (t) {\n          if (nr(!t.isEmpty(), \"Cannot delete field for empty path on ObjectValue\"), 1 === t.length) return new e(this.internalValue.remove(t.firstSegment()));\n          var n = this.child(t.firstSegment());\n\n          if (n instanceof e) {\n            var r = n.delete(t.popFirst());\n            return new e(this.internalValue.insert(t.firstSegment(), r));\n          }\n\n          return this;\n        }, e.prototype.contains = function (t) {\n          return void 0 !== this.field(t);\n        }, e.prototype.field = function (t) {\n          nr(!t.isEmpty(), \"Can't get field of empty path\");\n          var n = this;\n          return t.forEach(function (t) {\n            n = n instanceof e && n.internalValue.get(t) || void 0;\n          }), n;\n        }, e.prototype.toString = function () {\n          return JSON.stringify(this.value());\n        }, e.prototype.child = function (t) {\n          return this.internalValue.get(t) || void 0;\n        }, e.prototype.setChild = function (t, n) {\n          return new e(this.internalValue.insert(t, n));\n        }, e.EMPTY = new e(new $r(Mr)), e;\n      }(ii),\n          vi = function (t) {\n        function e(e) {\n          var n = t.call(this) || this;\n          return n.internalValue = e, n.typeOrder = Lr.ArrayValue, n;\n        }\n\n        return s(e, t), e.prototype.value = function (t) {\n          return this.internalValue.map(function (e) {\n            return e.value(t);\n          });\n        }, e.prototype.forEach = function (t) {\n          this.internalValue.forEach(t);\n        }, e.prototype.isEqual = function (t) {\n          if (t instanceof e) {\n            if (this.internalValue.length !== t.internalValue.length) return !1;\n\n            for (var n = 0; n < this.internalValue.length; n++) {\n              if (!this.internalValue[n].isEqual(t.internalValue[n])) return !1;\n            }\n\n            return !0;\n          }\n\n          return !1;\n        }, e.prototype.compareTo = function (t) {\n          if (t instanceof e) {\n            for (var n = Math.min(this.internalValue.length, t.internalValue.length), r = 0; r < n; r++) {\n              var i = this.internalValue[r].compareTo(t.internalValue[r]);\n              if (i) return i;\n            }\n\n            return Mr(this.internalValue.length, t.internalValue.length);\n          }\n\n          return this.defaultCompareTo(t);\n        }, e.prototype.toString = function () {\n          return JSON.stringify(this.value());\n        }, e;\n      }(ii),\n          bi = Number,\n          wi = bi.MIN_SAFE_INTEGER || -(Math.pow(2, 53) - 1),\n          Ei = bi.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1,\n          Si = bi.isInteger || function (t) {\n        return \"number\" == typeof t && isFinite(t) && Math.floor(t) === t;\n      };\n\n      function Ti(t) {\n        return null === t || void 0 === t;\n      }\n\n      function Ii(t) {\n        return Si(t) && t <= Ei && t >= wi;\n      }\n\n      var Ci,\n          Di = function () {\n        function t(t, e, n, r, i, o) {\n          void 0 === e && (e = []), void 0 === n && (n = []), void 0 === r && (r = null), void 0 === i && (i = null), void 0 === o && (o = null), this.path = t, this.explicitOrderBy = e, this.filters = n, this.limit = r, this.startAt = i, this.endAt = o, this.memoizedCanonicalId = null, this.memoizedOrderBy = null, this.startAt && this.assertValidBound(this.startAt), this.endAt && this.assertValidBound(this.endAt);\n        }\n\n        return t.atPath = function (e) {\n          return new t(e);\n        }, Object.defineProperty(t.prototype, \"orderBy\", {\n          get: function get() {\n            if (null === this.memoizedOrderBy) {\n              var t = this.getInequalityFilterField(),\n                  e = this.getFirstOrderByField();\n              if (null !== t && null === e) t.isKeyField() ? this.memoizedOrderBy = [Li] : this.memoizedOrderBy = [new Pi(t), Li];else {\n                nr(null === t || null !== e && t.isEqual(e), \"First orderBy should match inequality field.\"), this.memoizedOrderBy = [];\n\n                for (var n = !1, r = 0, i = this.explicitOrderBy; r < i.length; r++) {\n                  var o = i[r];\n                  this.memoizedOrderBy.push(o), o.field.isKeyField() && (n = !0);\n                }\n\n                if (!n) {\n                  var s = this.explicitOrderBy.length > 0 ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir : Oi.ASCENDING;\n                  this.memoizedOrderBy.push(s === Oi.ASCENDING ? Li : xi);\n                }\n              }\n            }\n\n            return this.memoizedOrderBy;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.addFilter = function (e) {\n          nr(null == this.getInequalityFilterField() || !(e instanceof ki) || !e.isInequality() || e.field.isEqual(this.getInequalityFilterField()), \"Query must only have one inequality field.\"), nr(!Hr.isDocumentKey(this.path), \"No filtering allowed for document query\");\n          var n = this.filters.concat([e]);\n          return new t(this.path, this.explicitOrderBy.slice(), n, this.limit, this.startAt, this.endAt);\n        }, t.prototype.addOrderBy = function (e) {\n          nr(!Hr.isDocumentKey(this.path), \"No ordering allowed for document query\"), nr(!this.startAt && !this.endAt, \"Bounds must be set after orderBy\");\n          var n = this.explicitOrderBy.concat([e]);\n          return new t(this.path, n, this.filters.slice(), this.limit, this.startAt, this.endAt);\n        }, t.prototype.withLimit = function (e) {\n          return new t(this.path, this.explicitOrderBy.slice(), this.filters.slice(), e, this.startAt, this.endAt);\n        }, t.prototype.withStartAt = function (e) {\n          return new t(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, e, this.endAt);\n        }, t.prototype.withEndAt = function (e) {\n          return new t(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.startAt, e);\n        }, t.prototype.canonicalId = function () {\n          if (null === this.memoizedCanonicalId) {\n            var t = this.path.canonicalString();\n            t += \"|f:\";\n\n            for (var e = 0, n = this.filters; e < n.length; e++) {\n              t += n[e].canonicalId(), t += \",\";\n            }\n\n            t += \"|ob:\";\n\n            for (var r = 0, i = this.orderBy; r < i.length; r++) {\n              t += i[r].canonicalId(), t += \",\";\n            }\n\n            Ti(this.limit) || (t += \"|l:\", t += this.limit), this.startAt && (t += \"|lb:\", t += this.startAt.canonicalId()), this.endAt && (t += \"|ub:\", t += this.endAt.canonicalId()), this.memoizedCanonicalId = t;\n          }\n\n          return this.memoizedCanonicalId;\n        }, t.prototype.toString = function () {\n          var t = \"Query(\" + this.path.canonicalString();\n          return this.filters.length > 0 && (t += \", filters: [\" + this.filters.join(\", \") + \"]\"), Ti(this.limit) || (t += \", limit: \" + this.limit), this.explicitOrderBy.length > 0 && (t += \", orderBy: [\" + this.explicitOrderBy.join(\", \") + \"]\"), this.startAt && (t += \", startAt: \" + this.startAt.canonicalId()), this.endAt && (t += \", endAt: \" + this.endAt.canonicalId()), t + \")\";\n        }, t.prototype.isEqual = function (t) {\n          if (this.limit !== t.limit) return !1;\n          if (this.orderBy.length !== t.orderBy.length) return !1;\n\n          for (var e = 0; e < this.orderBy.length; e++) {\n            if (!this.orderBy[e].isEqual(t.orderBy[e])) return !1;\n          }\n\n          if (this.filters.length !== t.filters.length) return !1;\n\n          for (e = 0; e < this.filters.length; e++) {\n            if (!this.filters[e].isEqual(t.filters[e])) return !1;\n          }\n\n          return !!this.path.isEqual(t.path) && !(null !== this.startAt ? !this.startAt.isEqual(t.startAt) : null !== t.startAt) && (null !== this.endAt ? this.endAt.isEqual(t.endAt) : null === t.endAt);\n        }, t.prototype.docComparator = function (t, e) {\n          for (var n = !1, r = 0, i = this.orderBy; r < i.length; r++) {\n            var o = i[r],\n                s = o.compare(t, e);\n            if (0 !== s) return s;\n            n = n || o.field.isKeyField();\n          }\n\n          return nr(n, \"orderBy used that doesn't compare on key field\"), 0;\n        }, t.prototype.matches = function (t) {\n          return this.matchesAncestor(t) && this.matchesOrderBy(t) && this.matchesFilters(t) && this.matchesBounds(t);\n        }, t.prototype.hasLimit = function () {\n          return !Ti(this.limit);\n        }, t.prototype.getFirstOrderByField = function () {\n          return this.explicitOrderBy.length > 0 ? this.explicitOrderBy[0].field : null;\n        }, t.prototype.getInequalityFilterField = function () {\n          for (var t = 0, e = this.filters; t < e.length; t++) {\n            var n = e[t];\n            if (n instanceof ki && n.isInequality()) return n.field;\n          }\n\n          return null;\n        }, t.prototype.hasArrayContainsFilter = function () {\n          return void 0 !== this.filters.find(function (t) {\n            return t instanceof ki && t.op === Ai.ARRAY_CONTAINS;\n          });\n        }, t.prototype.isDocumentQuery = function () {\n          return Hr.isDocumentKey(this.path) && 0 === this.filters.length;\n        }, t.prototype.matchesAncestor = function (t) {\n          var e = t.key.path;\n          return Hr.isDocumentKey(this.path) ? this.path.isEqual(e) : this.path.isPrefixOf(e) && this.path.length === e.length - 1;\n        }, t.prototype.matchesOrderBy = function (t) {\n          for (var e = 0, n = this.explicitOrderBy; e < n.length; e++) {\n            var r = n[e];\n            if (!r.field.isKeyField() && void 0 === t.field(r.field)) return !1;\n          }\n\n          return !0;\n        }, t.prototype.matchesFilters = function (t) {\n          for (var e = 0, n = this.filters; e < n.length; e++) {\n            if (!n[e].matches(t)) return !1;\n          }\n\n          return !0;\n        }, t.prototype.matchesBounds = function (t) {\n          return !(this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, t)) && (!this.endAt || !this.endAt.sortsBeforeDocument(this.orderBy, t));\n        }, t.prototype.assertValidBound = function (t) {\n          nr(t.position.length <= this.orderBy.length, \"Bound is longer than orderBy\");\n        }, t;\n      }(),\n          Ni = function () {\n        function t() {}\n\n        return t.create = function (t, e, n) {\n          if (n.isEqual(oi.INSTANCE)) {\n            if (e !== Ai.EQUAL) throw new sr(or.INVALID_ARGUMENT, \"Invalid query. You can only perform equals comparisons on null.\");\n            return new Ri(t);\n          }\n\n          if (n.isEqual(hi.NAN)) {\n            if (e !== Ai.EQUAL) throw new sr(or.INVALID_ARGUMENT, \"Invalid query. You can only perform equals comparisons on NaN.\");\n            return new Mi(t);\n          }\n\n          return new ki(t, e, n);\n        }, t;\n      }(),\n          Ai = function () {\n        function t(t) {\n          this.name = t;\n        }\n\n        return t.fromString = function (e) {\n          switch (e) {\n            case \"<\":\n              return t.LESS_THAN;\n\n            case \"<=\":\n              return t.LESS_THAN_OR_EQUAL;\n\n            case \"==\":\n              return t.EQUAL;\n\n            case \">=\":\n              return t.GREATER_THAN_OR_EQUAL;\n\n            case \">\":\n              return t.GREATER_THAN;\n\n            case \"array-contains\":\n              return t.ARRAY_CONTAINS;\n\n            default:\n              return er(\"Unknown relation: \" + e);\n          }\n        }, t.prototype.toString = function () {\n          return this.name;\n        }, t.prototype.isEqual = function (t) {\n          return this.name === t.name;\n        }, t.LESS_THAN = new t(\"<\"), t.LESS_THAN_OR_EQUAL = new t(\"<=\"), t.EQUAL = new t(\"==\"), t.GREATER_THAN = new t(\">\"), t.GREATER_THAN_OR_EQUAL = new t(\">=\"), t.ARRAY_CONTAINS = new t(\"array-contains\"), t;\n      }(),\n          ki = function (t) {\n        function e(e, n, r) {\n          var i = t.call(this) || this;\n          return i.field = e, i.op = n, i.value = r, i;\n        }\n\n        return s(e, t), e.prototype.matches = function (t) {\n          if (this.field.isKeyField()) {\n            nr(this.value instanceof mi, \"Comparing on key, but filter value not a RefValue\"), nr(this.op !== Ai.ARRAY_CONTAINS, \"array-contains queries don't make sense on document keys.\");\n            var e = this.value,\n                n = Hr.comparator(t.key, e.key);\n            return this.matchesComparison(n);\n          }\n\n          var r = t.field(this.field);\n          return void 0 !== r && this.matchesValue(r);\n        }, e.prototype.matchesValue = function (t) {\n          var e = this;\n          return this.op === Ai.ARRAY_CONTAINS ? t instanceof vi && void 0 !== t.internalValue.find(function (t) {\n            return t.isEqual(e.value);\n          }) : this.value.typeOrder === t.typeOrder && this.matchesComparison(t.compareTo(this.value));\n        }, e.prototype.matchesComparison = function (t) {\n          switch (this.op) {\n            case Ai.LESS_THAN:\n              return t < 0;\n\n            case Ai.LESS_THAN_OR_EQUAL:\n              return t <= 0;\n\n            case Ai.EQUAL:\n              return 0 === t;\n\n            case Ai.GREATER_THAN:\n              return t > 0;\n\n            case Ai.GREATER_THAN_OR_EQUAL:\n              return t >= 0;\n\n            default:\n              return er(\"Unknown relation op\" + this.op);\n          }\n        }, e.prototype.isInequality = function () {\n          return this.op !== Ai.EQUAL && this.op !== Ai.ARRAY_CONTAINS;\n        }, e.prototype.canonicalId = function () {\n          return this.field.canonicalString() + this.op.toString() + this.value.toString();\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.op.isEqual(t.op) && this.field.isEqual(t.field) && this.value.isEqual(t.value);\n        }, e.prototype.toString = function () {\n          return this.field.canonicalString() + \" \" + this.op + \" \" + this.value.value();\n        }, e;\n      }(Ni),\n          Ri = function (t) {\n        function e(e) {\n          var n = t.call(this) || this;\n          return n.field = e, n;\n        }\n\n        return s(e, t), e.prototype.matches = function (t) {\n          var e = t.field(this.field);\n          return void 0 !== e && null === e.value();\n        }, e.prototype.canonicalId = function () {\n          return this.field.canonicalString() + \" IS null\";\n        }, e.prototype.toString = function () {\n          return this.field.canonicalString() + \" IS null\";\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.field.isEqual(t.field);\n        }, e;\n      }(Ni),\n          Mi = function (t) {\n        function e(e) {\n          var n = t.call(this) || this;\n          return n.field = e, n;\n        }\n\n        return s(e, t), e.prototype.matches = function (t) {\n          var e = t.field(this.field),\n              n = e && e.value();\n          return \"number\" == typeof n && isNaN(n);\n        }, e.prototype.canonicalId = function () {\n          return this.field.canonicalString() + \" IS NaN\";\n        }, e.prototype.toString = function () {\n          return this.field.canonicalString() + \" IS NaN\";\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.field.isEqual(t.field);\n        }, e;\n      }(Ni),\n          Oi = function () {\n        function t(t) {\n          this.name = t;\n        }\n\n        return t.prototype.toString = function () {\n          return this.name;\n        }, t.ASCENDING = new t(\"asc\"), t.DESCENDING = new t(\"desc\"), t;\n      }(),\n          _i = function () {\n        function t(t, e) {\n          this.position = t, this.before = e;\n        }\n\n        return t.prototype.canonicalId = function () {\n          for (var t = this.before ? \"b:\" : \"a:\", e = 0, n = this.position; e < n.length; e++) {\n            t += n[e].toString();\n          }\n\n          return t;\n        }, t.prototype.sortsBeforeDocument = function (t, e) {\n          nr(this.position.length <= t.length, \"Bound has more components than query's orderBy\");\n\n          for (var n = 0, r = 0; r < this.position.length; r++) {\n            var i = t[r],\n                o = this.position[r];\n            if (i.field.isKeyField()) nr(o instanceof mi, \"Bound has a non-key value where the key path is being used.\"), n = Hr.comparator(o.key, e.key);else {\n              var s = e.field(i.field);\n              nr(void 0 !== s, \"Field should exist since document matched the orderBy already.\"), n = o.compareTo(s);\n            }\n            if (i.dir === Oi.DESCENDING && (n *= -1), 0 !== n) break;\n          }\n\n          return this.before ? n <= 0 : n < 0;\n        }, t.prototype.isEqual = function (t) {\n          if (null === t) return !1;\n          if (this.before !== t.before || this.position.length !== t.position.length) return !1;\n\n          for (var e = 0; e < this.position.length; e++) {\n            var n = this.position[e],\n                r = t.position[e];\n            return n.isEqual(r);\n          }\n\n          return !0;\n        }, t;\n      }(),\n          Pi = function () {\n        function t(t, e) {\n          this.field = t, void 0 === e && (e = Oi.ASCENDING), this.dir = e, this.isKeyOrderBy = t.isKeyField();\n        }\n\n        return t.prototype.compare = function (t, e) {\n          var n = this.isKeyOrderBy ? Yr.compareByKey(t, e) : Yr.compareByField(this.field, t, e);\n\n          switch (this.dir) {\n            case Oi.ASCENDING:\n              return n;\n\n            case Oi.DESCENDING:\n              return -1 * n;\n\n            default:\n              return er(\"Unknown direction: \" + this.dir);\n          }\n        }, t.prototype.canonicalId = function () {\n          return this.field.canonicalString() + this.dir.toString();\n        }, t.prototype.toString = function () {\n          return this.field.canonicalString() + \" (\" + this.dir + \")\";\n        }, t.prototype.isEqual = function (t) {\n          return this.dir === t.dir && this.field.isEqual(t.field);\n        }, t;\n      }(),\n          Li = new Pi(Gr.keyField(), Oi.ASCENDING),\n          xi = new Pi(Gr.keyField(), Oi.DESCENDING),\n          qi = function () {\n        function t(t) {\n          this.timestamp = t;\n        }\n\n        return t.fromMicroseconds = function (e) {\n          var n = Math.floor(e / 1e6);\n          return new t(new Ur(n, e % 1e6 * 1e3));\n        }, t.fromTimestamp = function (e) {\n          return new t(e);\n        }, t.forDeletedDoc = function () {\n          return t.MIN;\n        }, t.prototype.compareTo = function (t) {\n          return this.timestamp._compareTo(t.timestamp);\n        }, t.prototype.isEqual = function (t) {\n          return this.timestamp.isEqual(t.timestamp);\n        }, t.prototype.toMicroseconds = function () {\n          return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;\n        }, t.prototype.toString = function () {\n          return \"SnapshotVersion(\" + this.timestamp.toString() + \")\";\n        }, t.prototype.toTimestamp = function () {\n          return this.timestamp;\n        }, t.MIN = new t(new Ur(0, 0)), t;\n      }();\n\n      !function (t) {\n        t[t.Listen = 0] = \"Listen\", t[t.ExistenceFilterMismatch = 1] = \"ExistenceFilterMismatch\", t[t.LimboResolution = 2] = \"LimboResolution\";\n      }(Ci || (Ci = {}));\n\n      var Fi,\n          Bi = function () {\n        function t(t, e, n, r, i, o) {\n          void 0 === i && (i = qi.MIN), void 0 === o && (o = ir()), this.query = t, this.targetId = e, this.purpose = n, this.sequenceNumber = r, this.snapshotVersion = i, this.resumeToken = o;\n        }\n\n        return t.prototype.copy = function (e) {\n          return new t(this.query, this.targetId, this.purpose, void 0 === e.sequenceNumber ? this.sequenceNumber : e.sequenceNumber, void 0 === e.snapshotVersion ? this.snapshotVersion : e.snapshotVersion, void 0 === e.resumeToken ? this.resumeToken : e.resumeToken);\n        }, t.prototype.isEqual = function (t) {\n          return this.targetId === t.targetId && this.purpose === t.purpose && this.sequenceNumber === t.sequenceNumber && this.snapshotVersion.isEqual(t.snapshotVersion) && this.resumeToken === t.resumeToken && this.query.isEqual(t.query);\n        }, t;\n      }(),\n          Ui = function () {\n        function t(t) {\n          this.comparator = t, this.data = new $r(this.comparator);\n        }\n\n        return t.fromMapKeys = function (e) {\n          var n = new t(e.comparator);\n          return e.forEach(function (t) {\n            n = n.add(t);\n          }), n;\n        }, t.prototype.has = function (t) {\n          return null !== this.data.get(t);\n        }, t.prototype.first = function () {\n          return this.data.minKey();\n        }, t.prototype.last = function () {\n          return this.data.maxKey();\n        }, Object.defineProperty(t.prototype, \"size\", {\n          get: function get() {\n            return this.data.size;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.indexOf = function (t) {\n          return this.data.indexOf(t);\n        }, t.prototype.forEach = function (t) {\n          this.data.inorderTraversal(function (e, n) {\n            return t(e), !1;\n          });\n        }, t.prototype.forEachInRange = function (t, e) {\n          for (var n = this.data.getIteratorFrom(t[0]); n.hasNext();) {\n            var r = n.getNext();\n            if (this.comparator(r.key, t[1]) >= 0) return;\n            e(r.key);\n          }\n        }, t.prototype.forEachWhile = function (t, e) {\n          var n;\n\n          for (n = void 0 !== e ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext();) {\n            if (!t(n.getNext().key)) return;\n          }\n        }, t.prototype.firstAfterOrEqual = function (t) {\n          var e = this.data.getIteratorFrom(t);\n          return e.hasNext() ? e.getNext().key : null;\n        }, t.prototype.getIterator = function () {\n          return new Vi(this.data.getIterator());\n        }, t.prototype.getIteratorFrom = function (t) {\n          return new Vi(this.data.getIteratorFrom(t));\n        }, t.prototype.add = function (t) {\n          return this.copy(this.data.remove(t).insert(t, !0));\n        }, t.prototype.delete = function (t) {\n          return this.has(t) ? this.copy(this.data.remove(t)) : this;\n        }, t.prototype.isEmpty = function () {\n          return this.data.isEmpty();\n        }, t.prototype.unionWith = function (t) {\n          var e = this;\n          return t.forEach(function (t) {\n            e = e.add(t);\n          }), e;\n        }, t.prototype.isEqual = function (e) {\n          if (!(e instanceof t)) return !1;\n          if (this.size !== e.size) return !1;\n\n          for (var n = this.data.getIterator(), r = e.data.getIterator(); n.hasNext();) {\n            var i = n.getNext().key,\n                o = r.getNext().key;\n            if (0 !== this.comparator(i, o)) return !1;\n          }\n\n          return !0;\n        }, t.prototype.toArray = function () {\n          var t = [];\n          return this.forEach(function (e) {\n            t.push(e);\n          }), t;\n        }, t.prototype.toString = function () {\n          var t = [];\n          return this.forEach(function (e) {\n            return t.push(e);\n          }), \"SortedSet(\" + t.toString() + \")\";\n        }, t.prototype.copy = function (e) {\n          var n = new t(this.comparator);\n          return n.data = e, n;\n        }, t;\n      }(),\n          Vi = function () {\n        function t(t) {\n          this.iter = t;\n        }\n\n        return t.prototype.getNext = function () {\n          return this.iter.getNext().key;\n        }, t.prototype.hasNext = function () {\n          return this.iter.hasNext();\n        }, t;\n      }(),\n          Qi = function () {\n        function t(t) {\n          this.fields = t;\n        }\n\n        return t.fromSet = function (e) {\n          return new t(e);\n        }, t.fromArray = function (e) {\n          var n = new Ui(Gr.comparator);\n          return e.forEach(function (t) {\n            return n = n.add(t);\n          }), new t(n);\n        }, t.prototype.covers = function (t) {\n          var e = !1;\n          return this.fields.forEach(function (n) {\n            n.isPrefixOf(t) && (e = !0);\n          }), e;\n        }, t.prototype.isEqual = function (t) {\n          return this.fields.isEqual(t.fields);\n        }, t;\n      }(),\n          Ki = function () {\n        function t(t, e) {\n          this.field = t, this.transform = e;\n        }\n\n        return t.prototype.isEqual = function (t) {\n          return this.field.isEqual(t.field) && this.transform.isEqual(t.transform);\n        }, t;\n      }(),\n          Wi = function () {\n        return function (t, e) {\n          this.version = t, this.transformResults = e;\n        };\n      }();\n\n      !function (t) {\n        t[t.Set = 0] = \"Set\", t[t.Patch = 1] = \"Patch\", t[t.Transform = 2] = \"Transform\", t[t.Delete = 3] = \"Delete\";\n      }(Fi || (Fi = {}));\n\n      var ji = function () {\n        function t(t, e) {\n          this.updateTime = t, this.exists = e, nr(void 0 === t || void 0 === e, 'Precondition can specify \"exists\" or \"updateTime\" but not both');\n        }\n\n        return t.exists = function (e) {\n          return new t(void 0, e);\n        }, t.updateTime = function (e) {\n          return new t(e);\n        }, Object.defineProperty(t.prototype, \"isNone\", {\n          get: function get() {\n            return void 0 === this.updateTime && void 0 === this.exists;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.isValidFor = function (t) {\n          return void 0 !== this.updateTime ? t instanceof Yr && t.version.isEqual(this.updateTime) : void 0 !== this.exists ? this.exists === t instanceof Yr : (nr(this.isNone, \"Precondition should be empty\"), !0);\n        }, t.prototype.isEqual = function (t) {\n          return e = this.updateTime, n = t.updateTime, (null !== e && void 0 !== e ? !(!n || !e.isEqual(n)) : e === n) && this.exists === t.exists;\n          var e, n;\n        }, t.NONE = new t(), t;\n      }(),\n          zi = function () {\n        function t() {}\n\n        return t.prototype.verifyKeyMatches = function (t) {\n          null != t && nr(t.key.isEqual(this.key), \"Can only apply a mutation to a document with the same key\");\n        }, t.getPostMutationVersion = function (t) {\n          return t instanceof Yr ? t.version : qi.MIN;\n        }, t;\n      }(),\n          Gi = function (t) {\n        function e(e, n, r) {\n          var i = t.call(this) || this;\n          return i.key = e, i.value = n, i.precondition = r, i.type = Fi.Set, i;\n        }\n\n        return s(e, t), e.prototype.applyToRemoteDocument = function (t, e) {\n          this.verifyKeyMatches(t), nr(null == e.transformResults, \"Transform results received by SetMutation.\");\n          var n = e.version;\n          return new Yr(this.key, n, this.value, {\n            hasCommittedMutations: !0\n          });\n        }, e.prototype.applyToLocalView = function (t, e, n) {\n          if (this.verifyKeyMatches(t), !this.precondition.isValidFor(t)) return t;\n          var r = zi.getPostMutationVersion(t);\n          return new Yr(this.key, r, this.value, {\n            hasLocalMutations: !0\n          });\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && this.value.isEqual(t.value) && this.precondition.isEqual(t.precondition);\n        }, e;\n      }(zi),\n          Hi = function (t) {\n        function e(e, n, r, i) {\n          var o = t.call(this) || this;\n          return o.key = e, o.data = n, o.fieldMask = r, o.precondition = i, o.type = Fi.Patch, o;\n        }\n\n        return s(e, t), e.prototype.applyToRemoteDocument = function (t, e) {\n          if (this.verifyKeyMatches(t), nr(null == e.transformResults, \"Transform results received by PatchMutation.\"), !this.precondition.isValidFor(t)) return new Zr(this.key, e.version);\n          var n = this.patchDocument(t);\n          return new Yr(this.key, e.version, n, {\n            hasCommittedMutations: !0\n          });\n        }, e.prototype.applyToLocalView = function (t, e, n) {\n          if (this.verifyKeyMatches(t), !this.precondition.isValidFor(t)) return t;\n          var r = zi.getPostMutationVersion(t),\n              i = this.patchDocument(t);\n          return new Yr(this.key, r, i, {\n            hasLocalMutations: !0\n          });\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && this.fieldMask.isEqual(t.fieldMask) && this.precondition.isEqual(t.precondition);\n        }, e.prototype.patchDocument = function (t) {\n          var e;\n          return e = t instanceof Yr ? t.data : gi.EMPTY, this.patchObject(e);\n        }, e.prototype.patchObject = function (t) {\n          var e = this;\n          return this.fieldMask.fields.forEach(function (n) {\n            if (!n.isEmpty()) {\n              var r = e.data.field(n);\n              t = void 0 !== r ? t.set(n, r) : t.delete(n);\n            }\n          }), t;\n        }, e;\n      }(zi),\n          Xi = function (t) {\n        function e(e, n) {\n          var r = t.call(this) || this;\n          return r.key = e, r.fieldTransforms = n, r.type = Fi.Transform, r.precondition = ji.exists(!0), r;\n        }\n\n        return s(e, t), e.prototype.applyToRemoteDocument = function (t, e) {\n          if (this.verifyKeyMatches(t), nr(null != e.transformResults, \"Transform results missing for TransformMutation.\"), !this.precondition.isValidFor(t)) return new Zr(this.key, e.version);\n          var n = this.requireDocument(t),\n              r = this.serverTransformResults(t, e.transformResults),\n              i = e.version,\n              o = this.transformObject(n.data, r);\n          return new Yr(this.key, i, o, {\n            hasCommittedMutations: !0\n          });\n        }, e.prototype.applyToLocalView = function (t, e, n) {\n          if (this.verifyKeyMatches(t), !this.precondition.isValidFor(t)) return t;\n          var r = this.requireDocument(t),\n              i = this.localTransformResults(n, e),\n              o = this.transformObject(r.data, i);\n          return new Yr(this.key, r.version, o, {\n            hasLocalMutations: !0\n          });\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && Or(this.fieldTransforms, t.fieldTransforms) && this.precondition.isEqual(t.precondition);\n        }, e.prototype.requireDocument = function (t) {\n          nr(t instanceof Yr, \"Unknown MaybeDocument type \" + t);\n          var e = t;\n          return nr(e.key.isEqual(this.key), \"Can only transform a document with the same key\"), e;\n        }, e.prototype.serverTransformResults = function (t, e) {\n          var n = [];\n          nr(this.fieldTransforms.length === e.length, \"server transform result count (\" + e.length + \") should match field transform count (\" + this.fieldTransforms.length + \")\");\n\n          for (var r = 0; r < e.length; r++) {\n            var i = this.fieldTransforms[r],\n                o = i.transform,\n                s = null;\n            t instanceof Yr && (s = t.field(i.field) || null), n.push(o.applyToRemoteDocument(s, e[r]));\n          }\n\n          return n;\n        }, e.prototype.localTransformResults = function (t, e) {\n          for (var n = [], r = 0, i = this.fieldTransforms; r < i.length; r++) {\n            var o = i[r],\n                s = o.transform,\n                a = null;\n            e instanceof Yr && (a = e.field(o.field) || null), n.push(s.applyToLocalView(a, t));\n          }\n\n          return n;\n        }, e.prototype.transformObject = function (t, e) {\n          nr(e.length === this.fieldTransforms.length, \"TransformResults length mismatch.\");\n\n          for (var n = 0; n < this.fieldTransforms.length; n++) {\n            var r = this.fieldTransforms[n].field;\n            t = t.set(r, e[n]);\n          }\n\n          return t;\n        }, e;\n      }(zi),\n          Yi = function (t) {\n        function e(e, n) {\n          var r = t.call(this) || this;\n          return r.key = e, r.precondition = n, r.type = Fi.Delete, r;\n        }\n\n        return s(e, t), e.prototype.applyToRemoteDocument = function (t, e) {\n          return this.verifyKeyMatches(t), nr(null == e.transformResults, \"Transform results received by DeleteMutation.\"), new Jr(this.key, e.version, {\n            hasCommittedMutations: !0\n          });\n        }, e.prototype.applyToLocalView = function (t, e, n) {\n          return this.verifyKeyMatches(t), this.precondition.isValidFor(t) ? (t && nr(t.key.isEqual(this.key), \"Can only apply mutation to document with same key\"), new Jr(this.key, qi.forDeletedDoc())) : t;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && this.precondition.isEqual(t.precondition);\n        }, e;\n      }(zi),\n          Ji = function () {\n        function t() {}\n\n        return t.prototype.applyToLocalView = function (t, e) {\n          return new di(e, t);\n        }, t.prototype.applyToRemoteDocument = function (t, e) {\n          return e;\n        }, t.prototype.isEqual = function (e) {\n          return e instanceof t;\n        }, t.instance = new t(), t;\n      }(),\n          Zi = function () {\n        function t(t) {\n          this.elements = t;\n        }\n\n        return t.prototype.applyToLocalView = function (t, e) {\n          return this.apply(t);\n        }, t.prototype.applyToRemoteDocument = function (t, e) {\n          return this.apply(t);\n        }, t.prototype.apply = function (t) {\n          for (var e = to(t), n = function n(t) {\n            e.find(function (e) {\n              return e.isEqual(t);\n            }) || e.push(t);\n          }, r = 0, i = this.elements; r < i.length; r++) {\n            n(i[r]);\n          }\n\n          return new vi(e);\n        }, t.prototype.isEqual = function (e) {\n          return e instanceof t && Or(e.elements, this.elements);\n        }, t;\n      }(),\n          $i = function () {\n        function t(t) {\n          this.elements = t;\n        }\n\n        return t.prototype.applyToLocalView = function (t, e) {\n          return this.apply(t);\n        }, t.prototype.applyToRemoteDocument = function (t, e) {\n          return this.apply(t);\n        }, t.prototype.apply = function (t) {\n          for (var e = to(t), n = function n(t) {\n            e = e.filter(function (e) {\n              return !e.isEqual(t);\n            });\n          }, r = 0, i = this.elements; r < i.length; r++) {\n            n(i[r]);\n          }\n\n          return new vi(e);\n        }, t.prototype.isEqual = function (e) {\n          return e instanceof t && Or(e.elements, this.elements);\n        }, t;\n      }();\n\n      function to(t) {\n        return t instanceof vi ? t.internalValue.slice() : [];\n      }\n\n      var eo,\n          no = function () {\n        function t(t) {\n          this.count = t;\n        }\n\n        return t.prototype.isEqual = function (t) {\n          return t && t.count === this.count;\n        }, t;\n      }();\n\n      function ro(t) {\n        switch (t) {\n          case or.OK:\n            return er(\"Treated status OK as error\");\n\n          case or.CANCELLED:\n          case or.UNKNOWN:\n          case or.DEADLINE_EXCEEDED:\n          case or.RESOURCE_EXHAUSTED:\n          case or.INTERNAL:\n          case or.UNAVAILABLE:\n          case or.UNAUTHENTICATED:\n            return !1;\n\n          case or.INVALID_ARGUMENT:\n          case or.NOT_FOUND:\n          case or.ALREADY_EXISTS:\n          case or.PERMISSION_DENIED:\n          case or.FAILED_PRECONDITION:\n          case or.ABORTED:\n          case or.OUT_OF_RANGE:\n          case or.UNIMPLEMENTED:\n          case or.DATA_LOSS:\n            return !0;\n\n          default:\n            return er(\"Unknown status code: \" + t);\n        }\n      }\n\n      function io(t) {\n        if (void 0 === t) return $n(\"GRPC error has no .code\"), or.UNKNOWN;\n\n        switch (t) {\n          case eo.OK:\n            return or.OK;\n\n          case eo.CANCELLED:\n            return or.CANCELLED;\n\n          case eo.UNKNOWN:\n            return or.UNKNOWN;\n\n          case eo.DEADLINE_EXCEEDED:\n            return or.DEADLINE_EXCEEDED;\n\n          case eo.RESOURCE_EXHAUSTED:\n            return or.RESOURCE_EXHAUSTED;\n\n          case eo.INTERNAL:\n            return or.INTERNAL;\n\n          case eo.UNAVAILABLE:\n            return or.UNAVAILABLE;\n\n          case eo.UNAUTHENTICATED:\n            return or.UNAUTHENTICATED;\n\n          case eo.INVALID_ARGUMENT:\n            return or.INVALID_ARGUMENT;\n\n          case eo.NOT_FOUND:\n            return or.NOT_FOUND;\n\n          case eo.ALREADY_EXISTS:\n            return or.ALREADY_EXISTS;\n\n          case eo.PERMISSION_DENIED:\n            return or.PERMISSION_DENIED;\n\n          case eo.FAILED_PRECONDITION:\n            return or.FAILED_PRECONDITION;\n\n          case eo.ABORTED:\n            return or.ABORTED;\n\n          case eo.OUT_OF_RANGE:\n            return or.OUT_OF_RANGE;\n\n          case eo.UNIMPLEMENTED:\n            return or.UNIMPLEMENTED;\n\n          case eo.DATA_LOSS:\n            return or.DATA_LOSS;\n\n          default:\n            return er(\"Unknown status code: \" + t);\n        }\n      }\n\n      !function (t) {\n        t[t.OK = 0] = \"OK\", t[t.CANCELLED = 1] = \"CANCELLED\", t[t.UNKNOWN = 2] = \"UNKNOWN\", t[t.INVALID_ARGUMENT = 3] = \"INVALID_ARGUMENT\", t[t.DEADLINE_EXCEEDED = 4] = \"DEADLINE_EXCEEDED\", t[t.NOT_FOUND = 5] = \"NOT_FOUND\", t[t.ALREADY_EXISTS = 6] = \"ALREADY_EXISTS\", t[t.PERMISSION_DENIED = 7] = \"PERMISSION_DENIED\", t[t.UNAUTHENTICATED = 16] = \"UNAUTHENTICATED\", t[t.RESOURCE_EXHAUSTED = 8] = \"RESOURCE_EXHAUSTED\", t[t.FAILED_PRECONDITION = 9] = \"FAILED_PRECONDITION\", t[t.ABORTED = 10] = \"ABORTED\", t[t.OUT_OF_RANGE = 11] = \"OUT_OF_RANGE\", t[t.UNIMPLEMENTED = 12] = \"UNIMPLEMENTED\", t[t.INTERNAL = 13] = \"INTERNAL\", t[t.UNAVAILABLE = 14] = \"UNAVAILABLE\", t[t.DATA_LOSS = 15] = \"DATA_LOSS\";\n      }(eo || (eo = {}));\n      var oo = new $r(Hr.comparator);\n\n      function so() {\n        return oo;\n      }\n\n      function ao() {\n        return so();\n      }\n\n      var uo = new $r(Hr.comparator);\n\n      function co() {\n        return uo;\n      }\n\n      var ho = new $r(Hr.comparator);\n\n      function lo() {\n        return ho;\n      }\n\n      var fo = new Ui(Hr.comparator);\n\n      function po() {\n        for (var t = [], e = 0; e < arguments.length; e++) {\n          t[e] = arguments[e];\n        }\n\n        for (var n = fo, r = 0, i = t; r < i.length; r++) {\n          var o = i[r];\n          n = n.add(o);\n        }\n\n        return n;\n      }\n\n      var mo = new Ui(Mr);\n\n      function yo() {\n        return mo;\n      }\n\n      var go,\n          vo,\n          bo = function () {\n        function t(t) {\n          this.comparator = t ? function (e, n) {\n            return t(e, n) || Hr.comparator(e.key, n.key);\n          } : function (t, e) {\n            return Hr.comparator(t.key, e.key);\n          }, this.keyedMap = co(), this.sortedSet = new $r(this.comparator);\n        }\n\n        return t.emptySet = function (e) {\n          return new t(e.comparator);\n        }, t.prototype.has = function (t) {\n          return null != this.keyedMap.get(t);\n        }, t.prototype.get = function (t) {\n          return this.keyedMap.get(t);\n        }, t.prototype.first = function () {\n          return this.sortedSet.minKey();\n        }, t.prototype.last = function () {\n          return this.sortedSet.maxKey();\n        }, t.prototype.isEmpty = function () {\n          return this.sortedSet.isEmpty();\n        }, t.prototype.indexOf = function (t) {\n          var e = this.keyedMap.get(t);\n          return e ? this.sortedSet.indexOf(e) : -1;\n        }, Object.defineProperty(t.prototype, \"size\", {\n          get: function get() {\n            return this.sortedSet.size;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.forEach = function (t) {\n          this.sortedSet.inorderTraversal(function (e, n) {\n            return t(e), !1;\n          });\n        }, t.prototype.add = function (t) {\n          var e = this.delete(t.key);\n          return e.copy(e.keyedMap.insert(t.key, t), e.sortedSet.insert(t, null));\n        }, t.prototype.delete = function (t) {\n          var e = this.get(t);\n          return e ? this.copy(this.keyedMap.remove(t), this.sortedSet.remove(e)) : this;\n        }, t.prototype.isEqual = function (e) {\n          if (!(e instanceof t)) return !1;\n          if (this.size !== e.size) return !1;\n\n          for (var n = this.sortedSet.getIterator(), r = e.sortedSet.getIterator(); n.hasNext();) {\n            var i = n.getNext().key,\n                o = r.getNext().key;\n            if (!i.isEqual(o)) return !1;\n          }\n\n          return !0;\n        }, t.prototype.toString = function () {\n          var t = [];\n          return this.forEach(function (e) {\n            t.push(e.toString());\n          }), 0 === t.length ? \"DocumentSet ()\" : \"DocumentSet (\\n  \" + t.join(\"  \\n\") + \"\\n)\";\n        }, t.prototype.copy = function (e, n) {\n          var r = new t();\n          return r.comparator = this.comparator, r.keyedMap = e, r.sortedSet = n, r;\n        }, t;\n      }();\n\n      !function (t) {\n        t[t.Added = 0] = \"Added\", t[t.Removed = 1] = \"Removed\", t[t.Modified = 2] = \"Modified\", t[t.Metadata = 3] = \"Metadata\";\n      }(go || (go = {})), function (t) {\n        t[t.Local = 0] = \"Local\", t[t.Synced = 1] = \"Synced\";\n      }(vo || (vo = {}));\n\n      var wo,\n          Eo = function () {\n        function t() {\n          this.changeMap = new $r(Hr.comparator);\n        }\n\n        return t.prototype.track = function (t) {\n          var e = t.doc.key,\n              n = this.changeMap.get(e);\n          n ? t.type !== go.Added && n.type === go.Metadata ? this.changeMap = this.changeMap.insert(e, t) : t.type === go.Metadata && n.type !== go.Removed ? this.changeMap = this.changeMap.insert(e, {\n            type: n.type,\n            doc: t.doc\n          }) : t.type === go.Modified && n.type === go.Modified ? this.changeMap = this.changeMap.insert(e, {\n            type: go.Modified,\n            doc: t.doc\n          }) : t.type === go.Modified && n.type === go.Added ? this.changeMap = this.changeMap.insert(e, {\n            type: go.Added,\n            doc: t.doc\n          }) : t.type === go.Removed && n.type === go.Added ? this.changeMap = this.changeMap.remove(e) : t.type === go.Removed && n.type === go.Modified ? this.changeMap = this.changeMap.insert(e, {\n            type: go.Removed,\n            doc: n.doc\n          }) : t.type === go.Added && n.type === go.Removed ? this.changeMap = this.changeMap.insert(e, {\n            type: go.Modified,\n            doc: t.doc\n          }) : er(\"unsupported combination of changes: \" + JSON.stringify(t) + \" after \" + JSON.stringify(n)) : this.changeMap = this.changeMap.insert(e, t);\n        }, t.prototype.getChanges = function () {\n          var t = [];\n          return this.changeMap.inorderTraversal(function (e, n) {\n            t.push(n);\n          }), t;\n        }, t;\n      }(),\n          So = function () {\n        function t(t, e, n, r, i, o, s, a) {\n          this.query = t, this.docs = e, this.oldDocs = n, this.docChanges = r, this.mutatedKeys = i, this.fromCache = o, this.syncStateChanged = s, this.excludesMetadataChanges = a;\n        }\n\n        return t.fromInitialDocuments = function (e, n, r, i) {\n          var o = [];\n          return n.forEach(function (t) {\n            o.push({\n              type: go.Added,\n              doc: t\n            });\n          }), new t(e, n, bo.emptySet(n), o, r, i, !0, !1);\n        }, Object.defineProperty(t.prototype, \"hasPendingWrites\", {\n          get: function get() {\n            return !this.mutatedKeys.isEmpty();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.isEqual = function (t) {\n          if (!(this.fromCache === t.fromCache && this.syncStateChanged === t.syncStateChanged && this.mutatedKeys.isEqual(t.mutatedKeys) && this.query.isEqual(t.query) && this.docs.isEqual(t.docs) && this.oldDocs.isEqual(t.oldDocs))) return !1;\n          var e = this.docChanges,\n              n = t.docChanges;\n          if (e.length !== n.length) return !1;\n\n          for (var r = 0; r < e.length; r++) {\n            if (e[r].type !== n[r].type || !e[r].doc.isEqual(n[r].doc)) return !1;\n          }\n\n          return !0;\n        }, t;\n      }(),\n          To = function () {\n        function t(t, e, n, r, i) {\n          this.snapshotVersion = t, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = r, this.resolvedLimboDocuments = i;\n        }\n\n        return t.createSynthesizedRemoteEventForCurrentChange = function (e, n) {\n          var r,\n              i = ((r = {})[e] = Io.createSynthesizedTargetChangeForCurrentChange(e, n), r);\n          return new t(qi.MIN, i, yo(), so(), po());\n        }, t;\n      }(),\n          Io = function () {\n        function t(t, e, n, r, i) {\n          this.resumeToken = t, this.current = e, this.addedDocuments = n, this.modifiedDocuments = r, this.removedDocuments = i;\n        }\n\n        return t.createSynthesizedTargetChangeForCurrentChange = function (e, n) {\n          return new t(ir(), n, po(), po(), po());\n        }, t;\n      }(),\n          Co = function () {\n        return function (t, e, n, r) {\n          this.updatedTargetIds = t, this.removedTargetIds = e, this.key = n, this.newDoc = r;\n        };\n      }(),\n          Do = function () {\n        return function (t, e) {\n          this.targetId = t, this.existenceFilter = e;\n        };\n      }();\n\n      !function (t) {\n        t[t.NoChange = 0] = \"NoChange\", t[t.Added = 1] = \"Added\", t[t.Removed = 2] = \"Removed\", t[t.Current = 3] = \"Current\", t[t.Reset = 4] = \"Reset\";\n      }(wo || (wo = {}));\n\n      var No = function () {\n        return function (t, e, n, r) {\n          void 0 === n && (n = ir()), void 0 === r && (r = null), this.state = t, this.targetIds = e, this.resumeToken = n, this.cause = r;\n        };\n      }(),\n          Ao = function () {\n        function t() {\n          this.pendingResponses = 0, this.documentChanges = Mo(), this._resumeToken = ir(), this._current = !1, this._hasPendingChanges = !0;\n        }\n\n        return Object.defineProperty(t.prototype, \"current\", {\n          get: function get() {\n            return this._current;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"resumeToken\", {\n          get: function get() {\n            return this._resumeToken;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"isPending\", {\n          get: function get() {\n            return 0 !== this.pendingResponses;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"hasPendingChanges\", {\n          get: function get() {\n            return this._hasPendingChanges;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.updateResumeToken = function (t) {\n          t.length > 0 && (this._hasPendingChanges = !0, this._resumeToken = t);\n        }, t.prototype.toTargetChange = function () {\n          var t = po(),\n              e = po(),\n              n = po();\n          return this.documentChanges.forEach(function (r, i) {\n            switch (i) {\n              case go.Added:\n                t = t.add(r);\n                break;\n\n              case go.Modified:\n                e = e.add(r);\n                break;\n\n              case go.Removed:\n                n = n.add(r);\n                break;\n\n              default:\n                er(\"Encountered invalid change type: \" + i);\n            }\n          }), new Io(this._resumeToken, this._current, t, e, n);\n        }, t.prototype.clearPendingChanges = function () {\n          this._hasPendingChanges = !1, this.documentChanges = Mo();\n        }, t.prototype.addDocumentChange = function (t, e) {\n          this._hasPendingChanges = !0, this.documentChanges = this.documentChanges.insert(t, e);\n        }, t.prototype.removeDocumentChange = function (t) {\n          this._hasPendingChanges = !0, this.documentChanges = this.documentChanges.remove(t);\n        }, t.prototype.recordPendingTargetRequest = function () {\n          this.pendingResponses += 1;\n        }, t.prototype.recordTargetResponse = function () {\n          this.pendingResponses -= 1;\n        }, t.prototype.markCurrent = function () {\n          this._hasPendingChanges = !0, this._current = !0;\n        }, t;\n      }(),\n          ko = function () {\n        function t(t) {\n          this.metadataProvider = t, this.targetStates = {}, this.pendingDocumentUpdates = so(), this.pendingDocumentTargetMapping = Ro(), this.pendingTargetResets = new Ui(Mr);\n        }\n\n        return t.prototype.handleDocumentChange = function (t) {\n          for (var e = 0, n = t.updatedTargetIds; e < n.length; e++) {\n            var r = n[e];\n            t.newDoc instanceof Yr ? this.addDocumentToTarget(r, t.newDoc) : t.newDoc instanceof Jr && this.removeDocumentFromTarget(r, t.key, t.newDoc);\n          }\n\n          for (var i = 0, o = t.removedTargetIds; i < o.length; i++) {\n            r = o[i];\n            this.removeDocumentFromTarget(r, t.key, t.newDoc);\n          }\n        }, t.prototype.handleTargetChange = function (t) {\n          var e = this;\n          this.forEachTarget(t, function (n) {\n            var r = e.ensureTargetState(n);\n\n            switch (t.state) {\n              case wo.NoChange:\n                e.isActiveTarget(n) && r.updateResumeToken(t.resumeToken);\n                break;\n\n              case wo.Added:\n                r.recordTargetResponse(), r.isPending || r.clearPendingChanges(), r.updateResumeToken(t.resumeToken);\n                break;\n\n              case wo.Removed:\n                r.recordTargetResponse(), r.isPending || e.removeTarget(n), nr(!t.cause, \"WatchChangeAggregator does not handle errored targets\");\n                break;\n\n              case wo.Current:\n                e.isActiveTarget(n) && (r.markCurrent(), r.updateResumeToken(t.resumeToken));\n                break;\n\n              case wo.Reset:\n                e.isActiveTarget(n) && (e.resetTarget(n), r.updateResumeToken(t.resumeToken));\n                break;\n\n              default:\n                er(\"Unknown target watch change state: \" + t.state);\n            }\n          });\n        }, t.prototype.forEachTarget = function (t, e) {\n          t.targetIds.length > 0 ? t.targetIds.forEach(e) : hr(this.targetStates, e);\n        }, t.prototype.handleExistenceFilter = function (t) {\n          var e = t.targetId,\n              n = t.existenceFilter.count,\n              r = this.queryDataForActiveTarget(e);\n\n          if (r) {\n            var i = r.query;\n            if (i.isDocumentQuery()) {\n              if (0 === n) {\n                var o = new Hr(i.path);\n                this.removeDocumentFromTarget(e, o, new Jr(o, qi.forDeletedDoc()));\n              } else nr(1 === n, \"Single document existence filter with count: \" + n);\n            } else this.getCurrentDocumentCountForTarget(e) !== n && (this.resetTarget(e), this.pendingTargetResets = this.pendingTargetResets.add(e));\n          }\n        }, t.prototype.createRemoteEvent = function (t) {\n          var e = this,\n              n = {};\n          hr(this.targetStates, function (r, i) {\n            var o = e.queryDataForActiveTarget(r);\n\n            if (o) {\n              if (i.current && o.query.isDocumentQuery()) {\n                var s = new Hr(o.query.path);\n                null !== e.pendingDocumentUpdates.get(s) || e.targetContainsDocument(r, s) || e.removeDocumentFromTarget(r, s, new Jr(s, t));\n              }\n\n              i.hasPendingChanges && (n[r] = i.toTargetChange(), i.clearPendingChanges());\n            }\n          });\n          var r = po();\n          this.pendingDocumentTargetMapping.forEach(function (t, n) {\n            var i = !0;\n            n.forEachWhile(function (t) {\n              var n = e.queryDataForActiveTarget(t);\n              return !n || n.purpose === Ci.LimboResolution || (i = !1, !1);\n            }), i && (r = r.add(t));\n          });\n          var i = new To(t, n, this.pendingTargetResets, this.pendingDocumentUpdates, r);\n          return this.pendingDocumentUpdates = so(), this.pendingDocumentTargetMapping = Ro(), this.pendingTargetResets = new Ui(Mr), i;\n        }, t.prototype.addDocumentToTarget = function (t, e) {\n          if (this.isActiveTarget(t)) {\n            var n = this.targetContainsDocument(t, e.key) ? go.Modified : go.Added;\n            this.ensureTargetState(t).addDocumentChange(e.key, n), this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(e.key, e), this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(e.key, this.ensureDocumentTargetMapping(e.key).add(t));\n          }\n        }, t.prototype.removeDocumentFromTarget = function (t, e, n) {\n          if (this.isActiveTarget(t)) {\n            var r = this.ensureTargetState(t);\n            this.targetContainsDocument(t, e) ? r.addDocumentChange(e, go.Removed) : r.removeDocumentChange(e), this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(e, this.ensureDocumentTargetMapping(e).delete(t)), n && (this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(e, n));\n          }\n        }, t.prototype.removeTarget = function (t) {\n          delete this.targetStates[t];\n        }, t.prototype.getCurrentDocumentCountForTarget = function (t) {\n          var e = this.ensureTargetState(t).toTargetChange();\n          return this.metadataProvider.getRemoteKeysForTarget(t).size + e.addedDocuments.size - e.removedDocuments.size;\n        }, t.prototype.recordPendingTargetRequest = function (t) {\n          this.ensureTargetState(t).recordPendingTargetRequest();\n        }, t.prototype.ensureTargetState = function (t) {\n          return this.targetStates[t] || (this.targetStates[t] = new Ao()), this.targetStates[t];\n        }, t.prototype.ensureDocumentTargetMapping = function (t) {\n          var e = this.pendingDocumentTargetMapping.get(t);\n          return e || (e = new Ui(Mr), this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(t, e)), e;\n        }, t.prototype.isActiveTarget = function (t) {\n          return null !== this.queryDataForActiveTarget(t);\n        }, t.prototype.queryDataForActiveTarget = function (t) {\n          var e = this.targetStates[t];\n          return e && e.isPending ? null : this.metadataProvider.getQueryDataForTarget(t);\n        }, t.prototype.resetTarget = function (t) {\n          var e = this;\n          nr(!this.targetStates[t].isPending, \"Should only reset active targets\"), this.targetStates[t] = new Ao(), this.metadataProvider.getRemoteKeysForTarget(t).forEach(function (n) {\n            e.removeDocumentFromTarget(t, n, null);\n          });\n        }, t.prototype.targetContainsDocument = function (t, e) {\n          return this.metadataProvider.getRemoteKeysForTarget(t).has(e);\n        }, t;\n      }();\n\n      function Ro() {\n        return new $r(Hr.comparator);\n      }\n\n      function Mo() {\n        return new $r(Hr.comparator);\n      }\n\n      var Oo,\n          _o,\n          Po = ((Oo = {})[Oi.ASCENDING.name] = \"ASCENDING\", Oo[Oi.DESCENDING.name] = \"DESCENDING\", Oo),\n          Lo = ((_o = {})[Ai.LESS_THAN.name] = \"LESS_THAN\", _o[Ai.LESS_THAN_OR_EQUAL.name] = \"LESS_THAN_OR_EQUAL\", _o[Ai.GREATER_THAN.name] = \"GREATER_THAN\", _o[Ai.GREATER_THAN_OR_EQUAL.name] = \"GREATER_THAN_OR_EQUAL\", _o[Ai.EQUAL.name] = \"EQUAL\", _o[Ai.ARRAY_CONTAINS.name] = \"ARRAY_CONTAINS\", _o),\n          xo = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\n\n      function qo(t, e) {\n        nr(!Ti(t), e + \" is missing\");\n      }\n\n      function Fo(t) {\n        return \"number\" == typeof t ? t : \"string\" == typeof t ? Number(t) : er(\"can't parse \" + t);\n      }\n\n      var Bo = function () {\n        function t(t, e) {\n          this.databaseId = t, this.options = e;\n        }\n\n        return t.prototype.emptyByteString = function () {\n          return this.options.useProto3Json ? \"\" : new Uint8Array(0);\n        }, t.prototype.unsafeCastProtoByteString = function (t) {\n          return t;\n        }, t.prototype.fromRpcStatus = function (t) {\n          var e = void 0 === t.code ? or.UNKNOWN : io(t.code);\n          return new sr(e, t.message || \"\");\n        }, t.prototype.toInt32Value = function (t) {\n          return Ti(t) ? void 0 : {\n            value: t\n          };\n        }, t.prototype.fromInt32Value = function (t) {\n          var e;\n          return Ti(e = \"object\" == typeof t ? t.value : t) ? null : e;\n        }, t.prototype.toTimestamp = function (t) {\n          return {\n            seconds: t.seconds,\n            nanos: t.nanoseconds\n          };\n        }, t.prototype.fromTimestamp = function (t) {\n          if (\"string\" == typeof t) return this.fromIso8601String(t);\n          nr(!!t, \"Cannot deserialize null or undefined timestamp.\");\n          var e = Fo(t.seconds || \"0\"),\n              n = t.nanos || 0;\n          return new Ur(e, n);\n        }, t.prototype.fromIso8601String = function (t) {\n          var e = 0,\n              n = xo.exec(t);\n\n          if (nr(!!n, \"invalid timestamp: \" + t), n[1]) {\n            var r = n[1];\n            r = (r + \"000000000\").substr(0, 9), e = Number(r);\n          }\n\n          var i = new Date(t),\n              o = Math.floor(i.getTime() / 1e3);\n          return new Ur(o, e);\n        }, t.prototype.toBytes = function (t) {\n          return this.options.useProto3Json ? t.toBase64() : this.unsafeCastProtoByteString(t.toUint8Array());\n        }, t.prototype.fromBlob = function (t) {\n          return \"string\" == typeof t ? (nr(this.options.useProto3Json, \"Expected bytes to be passed in as Uint8Array, but got a string instead.\"), qr.fromBase64String(t)) : (nr(!this.options.useProto3Json, \"Expected bytes to be passed in as string, but got something else instead.\"), qr.fromUint8Array(t));\n        }, t.prototype.toVersion = function (t) {\n          return this.toTimestamp(t.toTimestamp());\n        }, t.prototype.fromVersion = function (t) {\n          return nr(!!t, \"Trying to deserialize version that isn't set\"), qi.fromTimestamp(this.fromTimestamp(t));\n        }, t.prototype.toResourceName = function (t, e) {\n          return this.fullyQualifiedPrefixPath(t).child(\"documents\").child(e).canonicalString();\n        }, t.prototype.fromResourceName = function (t) {\n          var e = jr.fromString(t);\n          return nr(this.isValidResourceName(e), \"Tried to deserialize invalid key \" + e.toString()), e;\n        }, t.prototype.toName = function (t) {\n          return this.toResourceName(this.databaseId, t.path);\n        }, t.prototype.fromName = function (t) {\n          var e = this.fromResourceName(t);\n          return nr(e.get(1) === this.databaseId.projectId, \"Tried to deserialize key from different project: \" + e.get(1) + \" vs \" + this.databaseId.projectId), nr(!e.get(3) && !this.databaseId.database || e.get(3) === this.databaseId.database, \"Tried to deserialize key from different database: \" + e.get(3) + \" vs \" + this.databaseId.database), new Hr(this.extractLocalPathFromResourceName(e));\n        }, t.prototype.toQueryPath = function (t) {\n          return this.toResourceName(this.databaseId, t);\n        }, t.prototype.fromQueryPath = function (t) {\n          var e = this.fromResourceName(t);\n          return 4 === e.length ? jr.EMPTY_PATH : this.extractLocalPathFromResourceName(e);\n        }, Object.defineProperty(t.prototype, \"encodedDatabaseId\", {\n          get: function get() {\n            return new jr([\"projects\", this.databaseId.projectId, \"databases\", this.databaseId.database]).canonicalString();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.fullyQualifiedPrefixPath = function (t) {\n          return new jr([\"projects\", t.projectId, \"databases\", t.database]);\n        }, t.prototype.extractLocalPathFromResourceName = function (t) {\n          return nr(t.length > 4 && \"documents\" === t.get(4), \"tried to deserialize invalid key \" + t.toString()), t.popFirst(5);\n        }, t.prototype.isValidResourceName = function (t) {\n          return t.length >= 4 && \"projects\" === t.get(0) && \"databases\" === t.get(2);\n        }, t.prototype.toValue = function (t) {\n          if (t instanceof oi) return {\n            nullValue: \"NULL_VALUE\"\n          };\n          if (t instanceof si) return {\n            booleanValue: t.value()\n          };\n          if (t instanceof ci) return {\n            integerValue: \"\" + t.value()\n          };\n\n          if (t instanceof hi) {\n            var e = t.value();\n\n            if (this.options.useProto3Json) {\n              if (isNaN(e)) return {\n                doubleValue: \"NaN\"\n              };\n              if (e === 1 / 0) return {\n                doubleValue: \"Infinity\"\n              };\n              if (e === -1 / 0) return {\n                doubleValue: \"-Infinity\"\n              };\n            }\n\n            return {\n              doubleValue: t.value()\n            };\n          }\n\n          return t instanceof li ? {\n            stringValue: t.value()\n          } : t instanceof gi ? {\n            mapValue: this.toMapValue(t)\n          } : t instanceof vi ? {\n            arrayValue: this.toArrayValue(t)\n          } : t instanceof fi ? {\n            timestampValue: this.toTimestamp(t.internalValue)\n          } : t instanceof yi ? {\n            geoPointValue: {\n              latitude: t.value().latitude,\n              longitude: t.value().longitude\n            }\n          } : t instanceof pi ? {\n            bytesValue: this.toBytes(t.value())\n          } : t instanceof mi ? {\n            referenceValue: this.toResourceName(t.databaseId, t.key.path)\n          } : er(\"Unknown FieldValue \" + JSON.stringify(t));\n        }, t.prototype.fromValue = function (t) {\n          var e = this,\n              n = t.value_type;\n          if (Uo(t, n, \"nullValue\")) return oi.INSTANCE;\n          if (Uo(t, n, \"booleanValue\")) return si.of(t.booleanValue);\n          if (Uo(t, n, \"integerValue\")) return new ci(Fo(t.integerValue));\n\n          if (Uo(t, n, \"doubleValue\")) {\n            if (this.options.useProto3Json) {\n              if (\"NaN\" === t.doubleValue) return hi.NAN;\n              if (\"Infinity\" === t.doubleValue) return hi.POSITIVE_INFINITY;\n              if (\"-Infinity\" === t.doubleValue) return hi.NEGATIVE_INFINITY;\n            }\n\n            return new hi(t.doubleValue);\n          }\n\n          if (Uo(t, n, \"stringValue\")) return new li(t.stringValue);\n          if (Uo(t, n, \"mapValue\")) return this.fromFields(t.mapValue.fields || {});\n\n          if (Uo(t, n, \"arrayValue\")) {\n            qo(t.arrayValue, \"arrayValue\");\n            var r = t.arrayValue.values || [];\n            return new vi(r.map(function (t) {\n              return e.fromValue(t);\n            }));\n          }\n\n          if (Uo(t, n, \"timestampValue\")) return qo(t.timestampValue, \"timestampValue\"), new fi(this.fromTimestamp(t.timestampValue));\n\n          if (Uo(t, n, \"geoPointValue\")) {\n            qo(t.geoPointValue, \"geoPointValue\");\n            var i = t.geoPointValue.latitude || 0,\n                o = t.geoPointValue.longitude || 0;\n            return new yi(new Br(i, o));\n          }\n\n          if (Uo(t, n, \"bytesValue\")) {\n            qo(t.bytesValue, \"bytesValue\");\n            var s = this.fromBlob(t.bytesValue);\n            return new pi(s);\n          }\n\n          if (Uo(t, n, \"referenceValue\")) {\n            qo(t.referenceValue, \"referenceValue\");\n            var a = this.fromResourceName(t.referenceValue),\n                u = new Kr(a.get(1), a.get(3)),\n                c = new Hr(this.extractLocalPathFromResourceName(a));\n            return new mi(u, c);\n          }\n\n          return er(\"Unknown Value proto \" + JSON.stringify(t));\n        }, t.prototype.toMutationDocument = function (t, e) {\n          return {\n            name: this.toName(t),\n            fields: this.toFields(e)\n          };\n        }, t.prototype.toDocument = function (t) {\n          return nr(!t.hasLocalMutations, \"Can't serialize documents with mutations.\"), {\n            name: this.toName(t.key),\n            fields: this.toFields(t.data),\n            updateTime: this.toTimestamp(t.version.toTimestamp())\n          };\n        }, t.prototype.fromDocument = function (t, e) {\n          return new Yr(this.fromName(t.name), this.fromVersion(t.updateTime), this.fromFields(t.fields || {}), {\n            hasCommittedMutations: !!e\n          });\n        }, t.prototype.toFields = function (t) {\n          var e = this,\n              n = {};\n          return t.forEach(function (t, r) {\n            n[t] = e.toValue(r);\n          }), n;\n        }, t.prototype.fromFields = function (t) {\n          var e = this,\n              n = t,\n              r = gi.EMPTY;\n          return lr(n, function (t, n) {\n            r = r.set(new Gr([t]), e.fromValue(n));\n          }), r;\n        }, t.prototype.toMapValue = function (t) {\n          return {\n            fields: this.toFields(t)\n          };\n        }, t.prototype.toArrayValue = function (t) {\n          var e = this,\n              n = [];\n          return t.forEach(function (t) {\n            n.push(e.toValue(t));\n          }), {\n            values: n\n          };\n        }, t.prototype.fromFound = function (t) {\n          nr(!!t.found, \"Tried to deserialize a found document from a missing document.\"), qo(t.found.name, \"doc.found.name\"), qo(t.found.updateTime, \"doc.found.updateTime\");\n          var e = this.fromName(t.found.name),\n              n = this.fromVersion(t.found.updateTime),\n              r = this.fromFields(t.found.fields || {});\n          return new Yr(e, n, r, {}, t.found);\n        }, t.prototype.fromMissing = function (t) {\n          nr(!!t.missing, \"Tried to deserialize a missing document from a found document.\"), nr(!!t.readTime, \"Tried to deserialize a missing document without a read time.\");\n          var e = this.fromName(t.missing),\n              n = this.fromVersion(t.readTime);\n          return new Jr(e, n);\n        }, t.prototype.fromMaybeDocument = function (t) {\n          var e = t.result;\n          return Uo(t, e, \"found\") ? this.fromFound(t) : Uo(t, e, \"missing\") ? this.fromMissing(t) : er(\"invalid batch get response: \" + JSON.stringify(t));\n        }, t.prototype.toWatchTargetChangeState = function (t) {\n          switch (t) {\n            case wo.Added:\n              return \"ADD\";\n\n            case wo.Current:\n              return \"CURRENT\";\n\n            case wo.NoChange:\n              return \"NO_CHANGE\";\n\n            case wo.Removed:\n              return \"REMOVE\";\n\n            case wo.Reset:\n              return \"RESET\";\n\n            default:\n              return er(\"Unknown WatchTargetChangeState: \" + t);\n          }\n        }, t.prototype.toTestWatchChange = function (t) {\n          if (t instanceof Do) return {\n            filter: {\n              count: t.existenceFilter.count,\n              targetId: t.targetId\n            }\n          };\n\n          if (t instanceof Co) {\n            if (t.newDoc instanceof Yr) {\n              var e = t.newDoc;\n              return {\n                documentChange: {\n                  document: {\n                    name: this.toName(e.key),\n                    fields: this.toFields(e.data),\n                    updateTime: this.toVersion(e.version)\n                  },\n                  targetIds: t.updatedTargetIds,\n                  removedTargetIds: t.removedTargetIds\n                }\n              };\n            }\n\n            if (t.newDoc instanceof Jr) {\n              e = t.newDoc;\n              return {\n                documentDelete: {\n                  document: this.toName(e.key),\n                  readTime: this.toVersion(e.version),\n                  removedTargetIds: t.removedTargetIds\n                }\n              };\n            }\n\n            if (null === t.newDoc) return {\n              documentRemove: {\n                document: this.toName(t.key),\n                removedTargetIds: t.removedTargetIds\n              }\n            };\n          }\n\n          if (t instanceof No) {\n            var n = void 0;\n            return t.cause && (n = {\n              code: function (t) {\n                if (void 0 === t) return eo.OK;\n\n                switch (t) {\n                  case or.OK:\n                    return eo.OK;\n\n                  case or.CANCELLED:\n                    return eo.CANCELLED;\n\n                  case or.UNKNOWN:\n                    return eo.UNKNOWN;\n\n                  case or.DEADLINE_EXCEEDED:\n                    return eo.DEADLINE_EXCEEDED;\n\n                  case or.RESOURCE_EXHAUSTED:\n                    return eo.RESOURCE_EXHAUSTED;\n\n                  case or.INTERNAL:\n                    return eo.INTERNAL;\n\n                  case or.UNAVAILABLE:\n                    return eo.UNAVAILABLE;\n\n                  case or.UNAUTHENTICATED:\n                    return eo.UNAUTHENTICATED;\n\n                  case or.INVALID_ARGUMENT:\n                    return eo.INVALID_ARGUMENT;\n\n                  case or.NOT_FOUND:\n                    return eo.NOT_FOUND;\n\n                  case or.ALREADY_EXISTS:\n                    return eo.ALREADY_EXISTS;\n\n                  case or.PERMISSION_DENIED:\n                    return eo.PERMISSION_DENIED;\n\n                  case or.FAILED_PRECONDITION:\n                    return eo.FAILED_PRECONDITION;\n\n                  case or.ABORTED:\n                    return eo.ABORTED;\n\n                  case or.OUT_OF_RANGE:\n                    return eo.OUT_OF_RANGE;\n\n                  case or.UNIMPLEMENTED:\n                    return eo.UNIMPLEMENTED;\n\n                  case or.DATA_LOSS:\n                    return eo.DATA_LOSS;\n\n                  default:\n                    return er(\"Unknown status code: \" + t);\n                }\n              }(t.cause.code),\n              message: t.cause.message\n            }), {\n              targetChange: {\n                targetChangeType: this.toWatchTargetChangeState(t.state),\n                targetIds: t.targetIds,\n                resumeToken: this.unsafeCastProtoByteString(t.resumeToken),\n                cause: n\n              }\n            };\n          }\n\n          return er(\"Unrecognized watch change: \" + JSON.stringify(t));\n        }, t.prototype.fromWatchChange = function (t) {\n          var e,\n              n = t.response_type;\n\n          if (Uo(t, n, \"targetChange\")) {\n            qo(t.targetChange, \"targetChange\");\n            var r = this.fromWatchTargetChangeState(t.targetChange.targetChangeType || \"NO_CHANGE\"),\n                i = t.targetChange.targetIds || [],\n                o = t.targetChange.resumeToken || this.emptyByteString(),\n                s = t.targetChange.cause,\n                a = s && this.fromRpcStatus(s);\n            e = new No(r, i, o, a || null);\n          } else if (Uo(t, n, \"documentChange\")) {\n            qo(t.documentChange, \"documentChange\"), qo(t.documentChange.document, \"documentChange.name\"), qo(t.documentChange.document.name, \"documentChange.document.name\"), qo(t.documentChange.document.updateTime, \"documentChange.document.updateTime\");\n            var u = t.documentChange,\n                c = this.fromName(u.document.name),\n                h = this.fromVersion(u.document.updateTime),\n                l = this.fromFields(u.document.fields || {}),\n                f = new Yr(c, h, l, {}, u.document),\n                d = u.targetIds || [],\n                p = u.removedTargetIds || [];\n            e = new Co(d, p, f.key, f);\n          } else if (Uo(t, n, \"documentDelete\")) {\n            qo(t.documentDelete, \"documentDelete\"), qo(t.documentDelete.document, \"documentDelete.document\");\n            var m = t.documentDelete;\n            c = this.fromName(m.document), h = m.readTime ? this.fromVersion(m.readTime) : qi.forDeletedDoc(), f = new Jr(c, h), p = m.removedTargetIds || [];\n            e = new Co([], p, f.key, f);\n          } else if (Uo(t, n, \"documentRemove\")) {\n            qo(t.documentRemove, \"documentRemove\"), qo(t.documentRemove.document, \"documentRemove\");\n            var y = t.documentRemove;\n            c = this.fromName(y.document), p = y.removedTargetIds || [];\n            e = new Co([], p, c, null);\n          } else {\n            if (!Uo(t, n, \"filter\")) return er(\"Unknown change type \" + JSON.stringify(t));\n            qo(t.filter, \"filter\"), qo(t.filter.targetId, \"filter.targetId\");\n            var g = t.filter,\n                v = g.count || 0,\n                b = new no(v),\n                w = g.targetId;\n            e = new Do(w, b);\n          }\n\n          return e;\n        }, t.prototype.fromWatchTargetChangeState = function (t) {\n          return \"NO_CHANGE\" === t ? wo.NoChange : \"ADD\" === t ? wo.Added : \"REMOVE\" === t ? wo.Removed : \"CURRENT\" === t ? wo.Current : \"RESET\" === t ? wo.Reset : er(\"Got unexpected TargetChange.state: \" + t);\n        }, t.prototype.versionFromListenResponse = function (t) {\n          if (!Uo(t, t.response_type, \"targetChange\")) return qi.MIN;\n          var e = t.targetChange;\n          return e.targetIds && e.targetIds.length ? qi.MIN : e.readTime ? this.fromVersion(e.readTime) : qi.MIN;\n        }, t.prototype.toMutation = function (t) {\n          var e,\n              n = this;\n          if (t instanceof Gi) e = {\n            update: this.toMutationDocument(t.key, t.value)\n          };else if (t instanceof Yi) e = {\n            delete: this.toName(t.key)\n          };else if (t instanceof Hi) e = {\n            update: this.toMutationDocument(t.key, t.data),\n            updateMask: this.toDocumentMask(t.fieldMask)\n          };else {\n            if (!(t instanceof Xi)) return er(\"Unknown mutation type \" + t.type);\n            e = {\n              transform: {\n                document: this.toName(t.key),\n                fieldTransforms: t.fieldTransforms.map(function (t) {\n                  return n.toFieldTransform(t);\n                })\n              }\n            };\n          }\n          return t.precondition.isNone || (e.currentDocument = this.toPrecondition(t.precondition)), e;\n        }, t.prototype.fromMutation = function (t) {\n          var e = this,\n              n = t.currentDocument ? this.fromPrecondition(t.currentDocument) : ji.NONE;\n\n          if (t.update) {\n            qo(t.update.name, \"name\");\n            var r = this.fromName(t.update.name),\n                i = this.fromFields(t.update.fields || {});\n\n            if (t.updateMask) {\n              var o = this.fromDocumentMask(t.updateMask);\n              return new Hi(r, i, o, n);\n            }\n\n            return new Gi(r, i, n);\n          }\n\n          if (t.delete) {\n            r = this.fromName(t.delete);\n            return new Yi(r, n);\n          }\n\n          if (t.transform) {\n            r = this.fromName(t.transform.document);\n            var s = t.transform.fieldTransforms.map(function (t) {\n              return e.fromFieldTransform(t);\n            });\n            return nr(!0 === n.exists, 'Transforms only support precondition \"exists == true\"'), new Xi(r, s);\n          }\n\n          return er(\"unknown mutation proto: \" + JSON.stringify(t));\n        }, t.prototype.toPrecondition = function (t) {\n          return nr(!t.isNone, \"Can't serialize an empty precondition\"), void 0 !== t.updateTime ? {\n            updateTime: this.toVersion(t.updateTime)\n          } : void 0 !== t.exists ? {\n            exists: t.exists\n          } : er(\"Unknown precondition\");\n        }, t.prototype.fromPrecondition = function (t) {\n          return void 0 !== t.updateTime ? ji.updateTime(this.fromVersion(t.updateTime)) : void 0 !== t.exists ? ji.exists(t.exists) : ji.NONE;\n        }, t.prototype.fromWriteResult = function (t, e) {\n          var n = this,\n              r = t.updateTime ? this.fromVersion(t.updateTime) : this.fromVersion(e),\n              i = null;\n          return t.transformResults && t.transformResults.length > 0 && (i = t.transformResults.map(function (t) {\n            return n.fromValue(t);\n          })), new Wi(r, i);\n        }, t.prototype.fromWriteResults = function (t, e) {\n          var n = this;\n          return t && t.length > 0 ? (nr(void 0 !== e, \"Received a write result without a commit time\"), t.map(function (t) {\n            return n.fromWriteResult(t, e);\n          })) : [];\n        }, t.prototype.toFieldTransform = function (t) {\n          var e = this,\n              n = t.transform;\n          if (n instanceof Ji) return {\n            fieldPath: t.field.canonicalString(),\n            setToServerValue: \"REQUEST_TIME\"\n          };\n          if (n instanceof Zi) return {\n            fieldPath: t.field.canonicalString(),\n            appendMissingElements: {\n              values: n.elements.map(function (t) {\n                return e.toValue(t);\n              })\n            }\n          };\n          if (n instanceof $i) return {\n            fieldPath: t.field.canonicalString(),\n            removeAllFromArray: {\n              values: n.elements.map(function (t) {\n                return e.toValue(t);\n              })\n            }\n          };\n          throw er(\"Unknown transform: \" + t.transform);\n        }, t.prototype.fromFieldTransform = function (t) {\n          var e = this,\n              n = t.transform_type,\n              r = null;\n          if (Uo(t, n, \"setToServerValue\")) nr(\"REQUEST_TIME\" === t.setToServerValue, \"Unknown server value transform proto: \" + JSON.stringify(t)), r = Ji.instance;else if (Uo(t, n, \"appendMissingElements\")) {\n            var i = t.appendMissingElements.values || [];\n            r = new Zi(i.map(function (t) {\n              return e.fromValue(t);\n            }));\n          } else if (Uo(t, n, \"removeAllFromArray\")) {\n            i = t.removeAllFromArray.values || [];\n            r = new $i(i.map(function (t) {\n              return e.fromValue(t);\n            }));\n          } else er(\"Unknown transform proto: \" + JSON.stringify(t));\n          var o = Gr.fromServerFormat(t.fieldPath);\n          return new Ki(o, r);\n        }, t.prototype.toDocumentsTarget = function (t) {\n          return {\n            documents: [this.toQueryPath(t.path)]\n          };\n        }, t.prototype.fromDocumentsTarget = function (t) {\n          var e = t.documents.length;\n          nr(1 === e, \"DocumentsTarget contained other than 1 document: \" + e);\n          var n = t.documents[0];\n          return Di.atPath(this.fromQueryPath(n));\n        }, t.prototype.toQueryTarget = function (t) {\n          var e = {\n            structuredQuery: {}\n          };\n          if (t.path.isEmpty()) e.parent = this.toQueryPath(jr.EMPTY_PATH);else {\n            var n = t.path;\n            nr(n.length % 2 != 0, \"Document queries with filters are not supported.\"), e.parent = this.toQueryPath(n.popLast()), e.structuredQuery.from = [{\n              collectionId: n.lastSegment()\n            }];\n          }\n          var r = this.toFilter(t.filters);\n          r && (e.structuredQuery.where = r);\n          var i = this.toOrder(t.orderBy);\n          i && (e.structuredQuery.orderBy = i);\n          var o = this.toInt32Value(t.limit);\n          return void 0 !== o && (e.structuredQuery.limit = o), t.startAt && (e.structuredQuery.startAt = this.toCursor(t.startAt)), t.endAt && (e.structuredQuery.endAt = this.toCursor(t.endAt)), e;\n        }, t.prototype.fromQueryTarget = function (t) {\n          var e = this.fromQueryPath(t.parent),\n              n = t.structuredQuery,\n              r = n.from ? n.from.length : 0;\n\n          if (r > 0) {\n            nr(1 === r, \"StructuredQuery.from with more than one collection is not supported.\");\n            var i = n.from[0];\n            e = e.child(i.collectionId);\n          }\n\n          var o = [];\n          n.where && (o = this.fromFilter(n.where));\n          var s = [];\n          n.orderBy && (s = this.fromOrder(n.orderBy));\n          var a = null;\n          n.limit && (a = this.fromInt32Value(n.limit));\n          var u = null;\n          n.startAt && (u = this.fromCursor(n.startAt));\n          var c = null;\n          return n.endAt && (c = this.fromCursor(n.endAt)), new Di(e, s, o, a, u, c);\n        }, t.prototype.toListenRequestLabels = function (t) {\n          var e = this.toLabel(t.purpose);\n          return null == e ? null : {\n            \"goog-listen-tags\": e\n          };\n        }, t.prototype.toLabel = function (t) {\n          switch (t) {\n            case Ci.Listen:\n              return null;\n\n            case Ci.ExistenceFilterMismatch:\n              return \"existence-filter-mismatch\";\n\n            case Ci.LimboResolution:\n              return \"limbo-document\";\n\n            default:\n              return er(\"Unrecognized query purpose: \" + t);\n          }\n        }, t.prototype.toTarget = function (t) {\n          var e,\n              n = t.query;\n          return (e = n.isDocumentQuery() ? {\n            documents: this.toDocumentsTarget(n)\n          } : {\n            query: this.toQueryTarget(n)\n          }).targetId = t.targetId, t.resumeToken.length > 0 && (e.resumeToken = this.unsafeCastProtoByteString(t.resumeToken)), e;\n        }, t.prototype.toFilter = function (t) {\n          var e = this;\n\n          if (0 !== t.length) {\n            var n = t.map(function (t) {\n              return t instanceof ki ? e.toRelationFilter(t) : e.toUnaryFilter(t);\n            });\n            return 1 === n.length ? n[0] : {\n              compositeFilter: {\n                op: \"AND\",\n                filters: n\n              }\n            };\n          }\n        }, t.prototype.fromFilter = function (t) {\n          var e = this;\n          return t ? void 0 !== t.unaryFilter ? [this.fromUnaryFilter(t)] : void 0 !== t.fieldFilter ? [this.fromRelationFilter(t)] : void 0 !== t.compositeFilter ? t.compositeFilter.filters.map(function (t) {\n            return e.fromFilter(t);\n          }).reduce(function (t, e) {\n            return t.concat(e);\n          }) : er(\"Unknown filter: \" + JSON.stringify(t)) : [];\n        }, t.prototype.toOrder = function (t) {\n          var e = this;\n          if (0 !== t.length) return t.map(function (t) {\n            return e.toPropertyOrder(t);\n          });\n        }, t.prototype.fromOrder = function (t) {\n          var e = this;\n          return t.map(function (t) {\n            return e.fromPropertyOrder(t);\n          });\n        }, t.prototype.toCursor = function (t) {\n          var e = this;\n          return {\n            before: t.before,\n            values: t.position.map(function (t) {\n              return e.toValue(t);\n            })\n          };\n        }, t.prototype.fromCursor = function (t) {\n          var e = this,\n              n = !!t.before,\n              r = t.values.map(function (t) {\n            return e.fromValue(t);\n          });\n          return new _i(r, n);\n        }, t.prototype.toDirection = function (t) {\n          return Po[t.name];\n        }, t.prototype.fromDirection = function (t) {\n          switch (t) {\n            case \"ASCENDING\":\n              return Oi.ASCENDING;\n\n            case \"DESCENDING\":\n              return Oi.DESCENDING;\n\n            default:\n              return;\n          }\n        }, t.prototype.toOperatorName = function (t) {\n          return Lo[t.name];\n        }, t.prototype.fromOperatorName = function (t) {\n          switch (t) {\n            case \"EQUAL\":\n              return Ai.EQUAL;\n\n            case \"GREATER_THAN\":\n              return Ai.GREATER_THAN;\n\n            case \"GREATER_THAN_OR_EQUAL\":\n              return Ai.GREATER_THAN_OR_EQUAL;\n\n            case \"LESS_THAN\":\n              return Ai.LESS_THAN;\n\n            case \"LESS_THAN_OR_EQUAL\":\n              return Ai.LESS_THAN_OR_EQUAL;\n\n            case \"ARRAY_CONTAINS\":\n              return Ai.ARRAY_CONTAINS;\n\n            case \"OPERATOR_UNSPECIFIED\":\n              return er(\"Unspecified relation\");\n\n            default:\n              return er(\"Unknown relation\");\n          }\n        }, t.prototype.toFieldPathReference = function (t) {\n          return {\n            fieldPath: t.canonicalString()\n          };\n        }, t.prototype.fromFieldPathReference = function (t) {\n          return Gr.fromServerFormat(t.fieldPath);\n        }, t.prototype.toPropertyOrder = function (t) {\n          return {\n            field: this.toFieldPathReference(t.field),\n            direction: this.toDirection(t.dir)\n          };\n        }, t.prototype.fromPropertyOrder = function (t) {\n          return new Pi(this.fromFieldPathReference(t.field), this.fromDirection(t.direction));\n        }, t.prototype.toRelationFilter = function (t) {\n          return t instanceof ki ? {\n            fieldFilter: {\n              field: this.toFieldPathReference(t.field),\n              op: this.toOperatorName(t.op),\n              value: this.toValue(t.value)\n            }\n          } : er(\"Unrecognized filter: \" + JSON.stringify(t));\n        }, t.prototype.fromRelationFilter = function (t) {\n          return new ki(this.fromFieldPathReference(t.fieldFilter.field), this.fromOperatorName(t.fieldFilter.op), this.fromValue(t.fieldFilter.value));\n        }, t.prototype.toUnaryFilter = function (t) {\n          return t instanceof Mi ? {\n            unaryFilter: {\n              field: this.toFieldPathReference(t.field),\n              op: \"IS_NAN\"\n            }\n          } : t instanceof Ri ? {\n            unaryFilter: {\n              field: this.toFieldPathReference(t.field),\n              op: \"IS_NULL\"\n            }\n          } : er(\"Unrecognized filter: \" + JSON.stringify(t));\n        }, t.prototype.fromUnaryFilter = function (t) {\n          switch (t.unaryFilter.op) {\n            case \"IS_NAN\":\n              var e = this.fromFieldPathReference(t.unaryFilter.field);\n              return new Mi(e);\n\n            case \"IS_NULL\":\n              var n = this.fromFieldPathReference(t.unaryFilter.field);\n              return new Ri(n);\n\n            case \"OPERATOR_UNSPECIFIED\":\n              return er(\"Unspecified filter\");\n\n            default:\n              return er(\"Unknown filter\");\n          }\n        }, t.prototype.toDocumentMask = function (t) {\n          var e = [];\n          return t.fields.forEach(function (t) {\n            return e.push(t.canonicalString());\n          }), {\n            fieldPaths: e\n          };\n        }, t.prototype.fromDocumentMask = function (t) {\n          var e = (t.fieldPaths || []).map(function (t) {\n            return Gr.fromServerFormat(t);\n          });\n          return Qi.fromArray(e);\n        }, t;\n      }();\n\n      function Uo(t, e, n) {\n        return e === n || !e && n in t;\n      }\n\n      var Vo = function () {\n        function t(t) {\n          this.sendFn = t.sendFn, this.closeFn = t.closeFn;\n        }\n\n        return t.prototype.onOpen = function (t) {\n          nr(!this.wrappedOnOpen, \"Called onOpen on stream twice!\"), this.wrappedOnOpen = t;\n        }, t.prototype.onClose = function (t) {\n          nr(!this.wrappedOnClose, \"Called onClose on stream twice!\"), this.wrappedOnClose = t;\n        }, t.prototype.onMessage = function (t) {\n          nr(!this.wrappedOnMessage, \"Called onMessage on stream twice!\"), this.wrappedOnMessage = t;\n        }, t.prototype.close = function () {\n          this.closeFn();\n        }, t.prototype.send = function (t) {\n          this.sendFn(t);\n        }, t.prototype.callOnOpen = function () {\n          nr(void 0 !== this.wrappedOnOpen, \"Cannot call onOpen because no callback was set\"), this.wrappedOnOpen();\n        }, t.prototype.callOnClose = function (t) {\n          nr(void 0 !== this.wrappedOnClose, \"Cannot call onClose because no callback was set\"), this.wrappedOnClose(t);\n        }, t.prototype.callOnMessage = function (t) {\n          nr(void 0 !== this.wrappedOnMessage, \"Cannot call onMessage because no callback was set\"), this.wrappedOnMessage(t);\n        }, t;\n      }(),\n          Qo = \"Connection\",\n          Ko = {\n        BatchGetDocuments: \"batchGet\",\n        Commit: \"commit\"\n      },\n          Wo = \"gl-js/ fire/\" + Hn,\n          jo = function () {\n        function t(t) {\n          this.databaseId = t.databaseId, this.pool = new Vn();\n          var e = t.ssl ? \"https\" : \"http\";\n          this.baseUrl = e + \"://\" + t.host;\n        }\n\n        return t.prototype.modifyHeadersForRequest = function (t, e) {\n          if (e) for (var n in e.authHeaders) {\n            e.authHeaders.hasOwnProperty(n) && (t[n] = e.authHeaders[n]);\n          }\n          t[\"X-Goog-Api-Client\"] = Wo;\n        }, t.prototype.invokeRPC = function (t, e, n) {\n          var r = this,\n              i = this.makeUrl(t);\n          return new Promise(function (o, s) {\n            r.pool.getObject(function (a) {\n              a.listenOnce(Bn.COMPLETE, function () {\n                try {\n                  switch (a.getLastErrorCode()) {\n                    case Fn.NO_ERROR:\n                      var e = a.getResponseJson();\n                      Zn(Qo, \"XHR received:\", JSON.stringify(e)), o(e);\n                      break;\n\n                    case Fn.TIMEOUT:\n                      Zn(Qo, 'RPC \"' + t + '\" timed out'), s(new sr(or.DEADLINE_EXCEEDED, \"Request time out\"));\n                      break;\n\n                    case Fn.HTTP_ERROR:\n                      var n = a.getStatus();\n                      Zn(Qo, 'RPC \"' + t + '\" failed with status:', n, \"response text:\", a.getResponseText()), n > 0 ? s(new sr(function (t) {\n                        switch (t) {\n                          case 200:\n                            return or.OK;\n\n                          case 400:\n                            return or.INVALID_ARGUMENT;\n\n                          case 401:\n                            return or.UNAUTHENTICATED;\n\n                          case 403:\n                            return or.PERMISSION_DENIED;\n\n                          case 404:\n                            return or.NOT_FOUND;\n\n                          case 409:\n                            return or.ABORTED;\n\n                          case 416:\n                            return or.OUT_OF_RANGE;\n\n                          case 429:\n                            return or.RESOURCE_EXHAUSTED;\n\n                          case 499:\n                            return or.CANCELLED;\n\n                          case 500:\n                            return or.UNKNOWN;\n\n                          case 501:\n                            return or.UNIMPLEMENTED;\n\n                          case 503:\n                            return or.UNAVAILABLE;\n\n                          case 504:\n                            return or.DEADLINE_EXCEEDED;\n\n                          default:\n                            return t >= 200 && t < 300 ? or.OK : t >= 400 && t < 500 ? or.FAILED_PRECONDITION : t >= 500 && t < 600 ? or.INTERNAL : or.UNKNOWN;\n                        }\n                      }(n), \"Server responded with status \" + a.getStatusText())) : (Zn(Qo, 'RPC \"' + t + '\" failed'), s(new sr(or.UNAVAILABLE, \"Connection failed.\")));\n                      break;\n\n                    default:\n                      er('RPC \"' + t + '\" failed with unanticipated webchannel error ' + a.getLastErrorCode() + \": \" + a.getLastError() + \", giving up.\");\n                  }\n                } finally {\n                  Zn(Qo, 'RPC \"' + t + '\" completed.'), r.pool.releaseObject(a);\n                }\n              });\n              var u = JSON.stringify(e);\n              Zn(Qo, \"XHR sending: \", i + \" \" + u);\n              var c = {\n                \"Content-Type\": \"text/plain\"\n              };\n              r.modifyHeadersForRequest(c, n), a.send(i, \"POST\", u, c, 15);\n            });\n          });\n        }, t.prototype.invokeStreamingRPC = function (t, e, n) {\n          return this.invokeRPC(t, e, n);\n        }, t.prototype.openStream = function (t, e) {\n          var n = [this.baseUrl, \"/\", \"google.firestore.v1.Firestore\", \"/\", t, \"/channel\"],\n              r = qn(),\n              i = {\n            backgroundChannelTest: !0,\n            httpSessionIdParam: \"gsessionid\",\n            initMessageHeaders: {},\n            messageUrlParams: {\n              database: \"projects/\" + this.databaseId.projectId + \"/databases/\" + this.databaseId.database\n            },\n            sendRawJson: !0,\n            supportsCrossDomainXhr: !0\n          };\n          this.modifyHeadersForRequest(i.initMessageHeaders, e), \"object\" == typeof navigator && \"ReactNative\" === navigator.product || (i.httpHeadersOverwriteParam = \"$httpHeaders\");\n          var o = n.join(\"\");\n          Zn(Qo, \"Creating WebChannel: \" + o + \" \" + i);\n\n          var s = r.createWebChannel(o, i),\n              a = !1,\n              u = !1,\n              c = new Vo({\n            sendFn: function sendFn(t) {\n              u ? Zn(Qo, \"Not sending because WebChannel is closed:\", t) : (a || (Zn(Qo, \"Opening WebChannel transport.\"), s.open(), a = !0), Zn(Qo, \"WebChannel sending:\", t), s.send(t));\n            },\n            closeFn: function closeFn() {\n              return s.close();\n            }\n          }),\n              h = function h(t, e) {\n            s.listen(t, function (t) {\n              try {\n                e(t);\n              } catch (t) {\n                setTimeout(function () {\n                  throw t;\n                }, 0);\n              }\n            });\n          };\n\n          return h(Un.EventType.OPEN, function () {\n            u || Zn(Qo, \"WebChannel transport opened.\");\n          }), h(Un.EventType.CLOSE, function () {\n            u || (u = !0, Zn(Qo, \"WebChannel transport closed\"), c.callOnClose());\n          }), h(Un.EventType.ERROR, function (t) {\n            u || (u = !0, Zn(Qo, \"WebChannel transport errored:\", t), c.callOnClose(new sr(or.UNAVAILABLE, \"The operation could not be completed\")));\n          }), h(Un.EventType.MESSAGE, function (t) {\n            if (!u) {\n              var e = t.data[0];\n              nr(!!e, \"Got a webchannel message without data.\");\n              var n = e.error || e[0] && e[0].error;\n\n              if (n) {\n                Zn(Qo, \"WebChannel received error:\", n);\n\n                var r = n.status,\n                    i = function (t) {\n                  var e = eo[t];\n                  if (void 0 !== e) return io(e);\n                }(r),\n                    o = n.message;\n\n                void 0 === i && (i = or.INTERNAL, o = \"Unknown error status: \" + r + \" with message \" + n.message), u = !0, c.callOnClose(new sr(i, o)), s.close();\n              } else Zn(Qo, \"WebChannel received:\", e), c.callOnMessage(e);\n            }\n          }), setTimeout(function () {\n            c.callOnOpen();\n          }, 0), c;\n        }, t.prototype.makeUrl = function (t) {\n          var e = Ko[t];\n          nr(void 0 !== e, \"Unknown REST mapping for: \" + t);\n          var n = [this.baseUrl, \"/\", \"v1\"];\n          return n.push(\"/projects/\"), n.push(this.databaseId.projectId), n.push(\"/databases/\"), n.push(this.databaseId.database), n.push(\"/documents\"), n.push(\":\"), n.push(e), n.join(\"\");\n        }, t;\n      }(),\n          zo = function () {\n        function t() {\n          this.emptyByteString = \"\", this.base64Available = \"undefined\" != typeof atob;\n        }\n\n        return Object.defineProperty(t.prototype, \"document\", {\n          get: function get() {\n            return \"undefined\" != typeof document ? document : null;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"window\", {\n          get: function get() {\n            return \"undefined\" != typeof window ? window : null;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.loadConnection = function (t) {\n          return Promise.resolve(new jo(t));\n        }, t.prototype.newSerializer = function (t) {\n          return new Bo(t, {\n            useProto3Json: !0\n          });\n        }, t.prototype.formatJSON = function (t) {\n          return JSON.stringify(t);\n        }, t.prototype.atob = function (t) {\n          return atob(t);\n        }, t.prototype.btoa = function (t) {\n          return btoa(t);\n        }, t;\n      }();\n\n      rr.setPlatform(new zo());\n\n      var Go,\n          Ho = function () {\n        function t(t, e) {\n          var n = this;\n          this.previousValue = t, e && (e.sequenceNumberHandler = function (t) {\n            return n.setPreviousValue(t);\n          }, this.writeNewSequenceNumber = function (t) {\n            return e.writeSequenceNumber(t);\n          });\n        }\n\n        return t.prototype.setPreviousValue = function (t) {\n          return this.previousValue = Math.max(t, this.previousValue), this.previousValue;\n        }, t.prototype.next = function () {\n          var t = ++this.previousValue;\n          return this.writeNewSequenceNumber && this.writeNewSequenceNumber(t), t;\n        }, t.INVALID = -1, t;\n      }(),\n          Xo = function () {\n        return function () {\n          var t = this;\n          this.promise = new Promise(function (e, n) {\n            t.resolve = e, t.reject = n;\n          });\n        };\n      }();\n\n      !function (t) {\n        t.All = \"all\", t.ListenStreamIdle = \"listen_stream_idle\", t.ListenStreamConnectionBackoff = \"listen_stream_connection_backoff\", t.WriteStreamIdle = \"write_stream_idle\", t.WriteStreamConnectionBackoff = \"write_stream_connection_backoff\", t.OnlineStateTimeout = \"online_state_timeout\", t.ClientMetadataRefresh = \"client_metadata_refresh\", t.LruGarbageCollection = \"lru_garbage_collection\";\n      }(Go || (Go = {}));\n\n      var Yo = function () {\n        function t(t, e, n, r, i) {\n          this.asyncQueue = t, this.timerId = e, this.targetTimeMs = n, this.op = r, this.removalCallback = i, this.deferred = new Xo(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.catch = this.deferred.promise.catch.bind(this.deferred.promise), this.deferred.promise.catch(function (t) {});\n        }\n\n        return t.createAndSchedule = function (e, n, r, i, o) {\n          var s = new t(e, n, Date.now() + r, i, o);\n          return s.start(r), s;\n        }, t.prototype.start = function (t) {\n          var e = this;\n          this.timerHandle = setTimeout(function () {\n            return e.handleDelayElapsed();\n          }, t);\n        }, t.prototype.skipDelay = function () {\n          return this.handleDelayElapsed();\n        }, t.prototype.cancel = function (t) {\n          null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new sr(or.CANCELLED, \"Operation cancelled\" + (t ? \": \" + t : \"\"))));\n        }, t.prototype.handleDelayElapsed = function () {\n          var t = this;\n          this.asyncQueue.enqueueAndForget(function () {\n            return null !== t.timerHandle ? (t.clearTimeout(), t.op().then(function (e) {\n              return t.deferred.resolve(e);\n            })) : Promise.resolve();\n          });\n        }, t.prototype.clearTimeout = function () {\n          null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);\n        }, t;\n      }(),\n          Jo = function () {\n        function t() {\n          this.tail = Promise.resolve(), this.delayedOperations = [], this.operationInProgress = !1;\n        }\n\n        return t.prototype.enqueueAndForget = function (t) {\n          this.enqueue(t);\n        }, t.prototype.enqueue = function (t) {\n          var e = this;\n          this.verifyNotFailed();\n          var n = this.tail.then(function () {\n            return e.operationInProgress = !0, t().catch(function (t) {\n              e.failure = t, e.operationInProgress = !1;\n              var n = t.stack || t.message || \"\";\n              throw $n(\"INTERNAL UNHANDLED ERROR: \", n), n.indexOf(\"Firestore Test Simulated Error\") < 0 && setTimeout(function () {\n                throw t;\n              }, 0), t;\n            }).then(function (t) {\n              return e.operationInProgress = !1, t;\n            });\n          });\n          return this.tail = n, n;\n        }, t.prototype.enqueueAfterDelay = function (t, e, n) {\n          var r = this;\n          this.verifyNotFailed(), nr(e >= 0, \"Attempted to schedule an operation with a negative delay of \" + e), nr(!this.containsDelayedOperation(t), \"Attempted to schedule multiple operations with timer id \" + t + \".\");\n          var i = Yo.createAndSchedule(this, t, e, n, function (t) {\n            return r.removeDelayedOperation(t);\n          });\n          return this.delayedOperations.push(i), i;\n        }, t.prototype.verifyNotFailed = function () {\n          this.failure && er(\"AsyncQueue is already failed: \" + (this.failure.stack || this.failure.message));\n        }, t.prototype.verifyOperationInProgress = function () {\n          nr(this.operationInProgress, \"verifyOpInProgress() called when no op in progress on this queue.\");\n        }, t.prototype.drain = function () {\n          return this.enqueue(function () {\n            return Promise.resolve();\n          });\n        }, t.prototype.containsDelayedOperation = function (t) {\n          for (var e = 0, n = this.delayedOperations; e < n.length; e++) {\n            if (n[e].timerId === t) return !0;\n          }\n\n          return !1;\n        }, t.prototype.runDelayedOperationsEarly = function (t) {\n          var e = this;\n          return this.drain().then(function () {\n            nr(t === Go.All || e.containsDelayedOperation(t), \"Attempted to drain to missing operation \" + t), e.delayedOperations.sort(function (t, e) {\n              return t.targetTimeMs - e.targetTimeMs;\n            });\n\n            for (var n = 0, r = e.delayedOperations; n < r.length; n++) {\n              var i = r[n];\n              if (i.skipDelay(), t !== Go.All && i.timerId === t) break;\n            }\n\n            return e.drain();\n          });\n        }, t.prototype.removeDelayedOperation = function (t) {\n          var e = this.delayedOperations.indexOf(t);\n          nr(e >= 0, \"Delayed operation not found.\"), this.delayedOperations.splice(e, 1);\n        }, t;\n      }(),\n          Zo = \"\u0001\",\n          $o = \"\u0001\",\n          ts = \"\u0010\",\n          es = \"\u0011\";\n\n      function ns(t) {\n        for (var e = \"\", n = 0; n < t.length; n++) {\n          e.length > 0 && (e = is(e)), e = rs(t.get(n), e);\n        }\n\n        return is(e);\n      }\n\n      function rs(t, e) {\n        for (var n = e, r = t.length, i = 0; i < r; i++) {\n          var o = t.charAt(i);\n\n          switch (o) {\n            case \"\\0\":\n              n += Zo + ts;\n              break;\n\n            case Zo:\n              n += Zo + es;\n              break;\n\n            default:\n              n += o;\n          }\n        }\n\n        return n;\n      }\n\n      function is(t) {\n        return t + Zo + $o;\n      }\n\n      function os(t) {\n        var e = t.length;\n        if (nr(e >= 2, \"Invalid path \" + t), 2 === e) return nr(t.charAt(0) === Zo && t.charAt(1) === $o, \"Non-empty path \" + t + \" had length 2\"), jr.EMPTY_PATH;\n\n        for (var n = e - 2, r = [], i = \"\", o = 0; o < e;) {\n          var s = t.indexOf(Zo, o);\n\n          switch ((s < 0 || s > n) && er('Invalid encoded resource path: \"' + t + '\"'), t.charAt(s + 1)) {\n            case $o:\n              var a = t.substring(o, s),\n                  u = void 0;\n              0 === i.length ? u = a : (u = i += a, i = \"\"), r.push(u);\n              break;\n\n            case ts:\n              i += t.substring(o, s), i += \"\\0\";\n              break;\n\n            case es:\n              i += t.substring(o, s + 1);\n              break;\n\n            default:\n              er('Invalid encoded resource path: \"' + t + '\"');\n          }\n\n          o = s + 2;\n        }\n\n        return new jr(r);\n      }\n\n      var ss,\n          as = function () {\n        function t(t, e, n) {\n          this.batchId = t, this.localWriteTime = e, this.mutations = n, nr(n.length > 0, \"Cannot create an empty mutation batch\");\n        }\n\n        return t.prototype.applyToRemoteDocument = function (t, e, n) {\n          e && nr(e.key.isEqual(t), \"applyToRemoteDocument: key \" + t + \" should match maybeDoc key\\n        \" + e.key);\n          var r = n.mutationResults;\n          nr(r.length === this.mutations.length, \"Mismatch between mutations length\\n      (\" + this.mutations.length + \") and mutation results length\\n      (\" + r.length + \").\");\n\n          for (var i = 0; i < this.mutations.length; i++) {\n            var o = this.mutations[i];\n\n            if (o.key.isEqual(t)) {\n              var s = r[i];\n              e = o.applyToRemoteDocument(e, s);\n            }\n          }\n\n          return e;\n        }, t.prototype.applyToLocalView = function (t, e) {\n          e && nr(e.key.isEqual(t), \"applyToLocalDocument: key \" + t + \" should match maybeDoc key\\n        \" + e.key);\n\n          for (var n = e, r = 0; r < this.mutations.length; r++) {\n            var i = this.mutations[r];\n            i.key.isEqual(t) && (e = i.applyToLocalView(e, n, this.localWriteTime));\n          }\n\n          return e;\n        }, t.prototype.keys = function () {\n          for (var t = po(), e = 0, n = this.mutations; e < n.length; e++) {\n            var r = n[e];\n            t = t.add(r.key);\n          }\n\n          return t;\n        }, t.prototype.isEqual = function (t) {\n          return this.batchId === t.batchId && Or(this.mutations, t.mutations);\n        }, t;\n      }(),\n          us = function () {\n        function t(t, e, n, r, i) {\n          this.batch = t, this.commitVersion = e, this.mutationResults = n, this.streamToken = r, this.docVersions = i;\n        }\n\n        return t.from = function (e, n, r, i) {\n          nr(e.mutations.length === r.length, \"Mutations sent \" + e.mutations.length + \" must equal results received \" + r.length);\n\n          for (var o = lo(), s = e.mutations, a = 0; a < s.length; a++) {\n            o = o.insert(s[a].key, r[a].version);\n          }\n\n          return new t(e, n, r, i, o);\n        }, t;\n      }(),\n          cs = 1;\n\n      !function (t) {\n        t[t.QueryCache = 0] = \"QueryCache\", t[t.SyncEngine = 1] = \"SyncEngine\";\n      }(ss || (ss = {}));\n\n      var hs = function () {\n        function t(t, e) {\n          this.generatorId = t, nr((t & cs) === t, \"Generator ID \" + t + \" contains more than \" + cs + \" reserved bits\"), this.seek(void 0 !== e ? e : this.generatorId);\n        }\n\n        return t.prototype.next = function () {\n          var t = this.nextId;\n          return this.nextId += 1 << cs, t;\n        }, t.prototype.after = function (t) {\n          return this.seek(t + (1 << cs)), this.next();\n        }, t.prototype.seek = function (t) {\n          nr((t & cs) === this.generatorId, \"Cannot supply target ID from different generator ID\"), this.nextId = t;\n        }, t.forQueryCache = function () {\n          return new t(ss.QueryCache, 2);\n        }, t.forSyncEngine = function () {\n          return new t(ss.SyncEngine);\n        }, t;\n      }(),\n          ls = function () {\n        function t(t) {\n          var e = this;\n          this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = !1, this.callbackAttached = !1, t(function (t) {\n            e.isDone = !0, e.result = t, e.nextCallback && e.nextCallback(t);\n          }, function (t) {\n            e.isDone = !0, e.error = t, e.catchCallback && e.catchCallback(t);\n          });\n        }\n\n        return t.prototype.catch = function (t) {\n          return this.next(void 0, t);\n        }, t.prototype.next = function (e, n) {\n          var r = this;\n          return this.callbackAttached && er(\"Called next() or catch() twice for PersistencePromise\"), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(n, this.error) : this.wrapSuccess(e, this.result) : new t(function (t, i) {\n            r.nextCallback = function (n) {\n              r.wrapSuccess(e, n).next(t, i);\n            }, r.catchCallback = function (e) {\n              r.wrapFailure(n, e).next(t, i);\n            };\n          });\n        }, t.prototype.toPromise = function () {\n          var t = this;\n          return new Promise(function (e, n) {\n            t.next(e, n);\n          });\n        }, t.prototype.wrapUserFunction = function (e) {\n          try {\n            var n = e();\n            return n instanceof t ? n : t.resolve(n);\n          } catch (e) {\n            return t.reject(e);\n          }\n        }, t.prototype.wrapSuccess = function (e, n) {\n          return e ? this.wrapUserFunction(function () {\n            return e(n);\n          }) : t.resolve(n);\n        }, t.prototype.wrapFailure = function (e, n) {\n          return e ? this.wrapUserFunction(function () {\n            return e(n);\n          }) : t.reject(n);\n        }, t.resolve = function (e) {\n          return new t(function (t, n) {\n            t(e);\n          });\n        }, t.reject = function (e) {\n          return new t(function (t, n) {\n            n(e);\n          });\n        }, t.waitFor = function (e) {\n          return new t(function (t, n) {\n            var r = 0,\n                i = 0,\n                o = !1;\n            e.forEach(function (e) {\n              ++r, e.next(function () {\n                ++i, o && i === r && t();\n              }, function (t) {\n                return n(t);\n              });\n            }), o = !0, i === r && t();\n          });\n        }, t.or = function (e) {\n          for (var n = t.resolve(!1), r = function r(e) {\n            n = n.next(function (n) {\n              return n ? t.resolve(n) : e();\n            });\n          }, i = 0, o = e; i < o.length; i++) {\n            r(o[i]);\n          }\n\n          return n;\n        }, t.forEach = function (t, e) {\n          var n = this,\n              r = [];\n          return t.forEach(function (t, i) {\n            r.push(e.call(n, t, i));\n          }), this.waitFor(r);\n        }, t;\n      }(),\n          fs = function () {\n        function t(t) {\n          this.db = t;\n        }\n\n        return t.openOrCreate = function (e, n, r) {\n          return nr(t.isAvailable(), \"IndexedDB not supported in current environment.\"), Zn(\"SimpleDb\", \"Opening database:\", e), new ls(function (i, o) {\n            var s = window.indexedDB.open(e, n);\n            s.onsuccess = function (e) {\n              var n = e.target.result;\n              i(new t(n));\n            }, s.onblocked = function () {\n              o(new sr(or.FAILED_PRECONDITION, \"Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed.\"));\n            }, s.onerror = function (t) {\n              var e = t.target.error;\n              \"VersionError\" === e.name ? o(new sr(or.FAILED_PRECONDITION, \"A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.\")) : o(e);\n            }, s.onupgradeneeded = function (t) {\n              Zn(\"SimpleDb\", 'Database \"' + e + '\" requires upgrade from version:', t.oldVersion);\n              var n = t.target.result,\n                  i = new ps(s.transaction);\n              r.createOrUpgrade(n, i, t.oldVersion, Os).next(function () {\n                Zn(\"SimpleDb\", \"Database upgrade to version \" + Os + \" complete\");\n              });\n            };\n          }).toPromise();\n        }, t.delete = function (t) {\n          return Zn(\"SimpleDb\", \"Removing database:\", t), ys(window.indexedDB.deleteDatabase(t)).toPromise();\n        }, t.isAvailable = function () {\n          if (\"undefined\" == typeof window || null == window.indexedDB) return !1;\n          if (void 0 === window.navigator) return \"YES\" === process.env.USE_MOCK_PERSISTENCE;\n          var t = window.navigator.userAgent;\n          return !(t.indexOf(\"MSIE \") > 0 || t.indexOf(\"Trident/\") > 0 || t.indexOf(\"Edge/\") > 0);\n        }, t.getStore = function (t, e) {\n          return t.store(e);\n        }, t.prototype.runTransaction = function (t, e, n) {\n          var r = ps.open(this.db, t, e),\n              i = n(r).catch(function (t) {\n            return r.abort(t), ls.reject(t);\n          }).toPromise();\n          return r.completionPromise.then(function () {\n            return i;\n          });\n        }, t.prototype.close = function () {\n          this.db.close();\n        }, t;\n      }(),\n          ds = function () {\n        function t(t) {\n          this.dbCursor = t, this.shouldStop = !1, this.nextKey = null;\n        }\n\n        return Object.defineProperty(t.prototype, \"isDone\", {\n          get: function get() {\n            return this.shouldStop;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"skipToKey\", {\n          get: function get() {\n            return this.nextKey;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"cursor\", {\n          set: function set(t) {\n            this.dbCursor = t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.done = function () {\n          this.shouldStop = !0;\n        }, t.prototype.skip = function (t) {\n          this.nextKey = t;\n        }, t.prototype.delete = function () {\n          return ys(this.dbCursor.delete());\n        }, t;\n      }(),\n          ps = function () {\n        function t(t) {\n          var e = this;\n          this.transaction = t, this.aborted = !1, this.completionDeferred = new Xo(), this.transaction.oncomplete = function () {\n            e.completionDeferred.resolve();\n          }, this.transaction.onabort = function () {\n            t.error ? e.completionDeferred.reject(t.error) : e.completionDeferred.resolve();\n          }, this.transaction.onerror = function (t) {\n            e.completionDeferred.reject(t.target.error);\n          };\n        }\n\n        return t.open = function (e, n, r) {\n          return new t(e.transaction(r, n));\n        }, Object.defineProperty(t.prototype, \"completionPromise\", {\n          get: function get() {\n            return this.completionDeferred.promise;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.abort = function (t) {\n          t && this.completionDeferred.reject(t), this.aborted || (Zn(\"SimpleDb\", \"Aborting transaction:\", t ? t.message : \"Client-initiated abort\"), this.aborted = !0, this.transaction.abort());\n        }, t.prototype.store = function (t) {\n          var e = this.transaction.objectStore(t);\n          return nr(!!e, \"Object store not part of transaction: \" + t), new ms(e);\n        }, t;\n      }(),\n          ms = function () {\n        function t(t) {\n          this.store = t;\n        }\n\n        return t.prototype.put = function (t, e) {\n          var n;\n          return void 0 !== e ? (Zn(\"SimpleDb\", \"PUT\", this.store.name, t, e), n = this.store.put(e, t)) : (Zn(\"SimpleDb\", \"PUT\", this.store.name, \"<auto-key>\", t), n = this.store.put(t)), ys(n);\n        }, t.prototype.add = function (t) {\n          return Zn(\"SimpleDb\", \"ADD\", this.store.name, t, t), ys(this.store.add(t));\n        }, t.prototype.get = function (t) {\n          var e = this;\n          return ys(this.store.get(t)).next(function (n) {\n            return void 0 === n && (n = null), Zn(\"SimpleDb\", \"GET\", e.store.name, t, n), n;\n          });\n        }, t.prototype.delete = function (t) {\n          return Zn(\"SimpleDb\", \"DELETE\", this.store.name, t), ys(this.store.delete(t));\n        }, t.prototype.count = function () {\n          return Zn(\"SimpleDb\", \"COUNT\", this.store.name), ys(this.store.count());\n        }, t.prototype.loadAll = function (t, e) {\n          var n = this.cursor(this.options(t, e)),\n              r = [];\n          return this.iterateCursor(n, function (t, e) {\n            r.push(e);\n          }).next(function () {\n            return r;\n          });\n        }, t.prototype.deleteAll = function (t, e) {\n          Zn(\"SimpleDb\", \"DELETE ALL\", this.store.name);\n          var n = this.options(t, e);\n          n.keysOnly = !1;\n          var r = this.cursor(n);\n          return this.iterateCursor(r, function (t, e, n) {\n            return n.delete();\n          });\n        }, t.prototype.iterate = function (t, e) {\n          var n;\n          e ? n = t : (n = {}, e = t);\n          var r = this.cursor(n);\n          return this.iterateCursor(r, e);\n        }, t.prototype.iterateSerial = function (t) {\n          var e = this.cursor({});\n          return new ls(function (n, r) {\n            e.onerror = function (t) {\n              r(t.target.error);\n            }, e.onsuccess = function (e) {\n              var r = e.target.result;\n              r ? t(r.primaryKey, r.value).next(function (t) {\n                t ? r.continue() : n();\n              }) : n();\n            };\n          });\n        }, t.prototype.iterateCursor = function (t, e) {\n          var n = [];\n          return new ls(function (r, i) {\n            t.onerror = function (t) {\n              i(t.target.error);\n            }, t.onsuccess = function (t) {\n              var i = t.target.result;\n\n              if (i) {\n                var o = new ds(i),\n                    s = e(i.primaryKey, i.value, o);\n\n                if (s instanceof ls) {\n                  var a = s.catch(function (t) {\n                    return o.done(), ls.reject(t);\n                  });\n                  n.push(a);\n                }\n\n                o.isDone ? r() : null === o.skipToKey ? i.continue() : i.continue(o.skipToKey);\n              } else r();\n            };\n          }).next(function () {\n            return ls.waitFor(n);\n          });\n        }, t.prototype.options = function (t, e) {\n          var n = void 0;\n          return void 0 !== t && (\"string\" == typeof t ? n = t : (nr(void 0 === e, \"3rd argument must not be defined if 2nd is a range.\"), e = t)), {\n            index: n,\n            range: e\n          };\n        }, t.prototype.cursor = function (t) {\n          var e = \"next\";\n\n          if (t.reverse && (e = \"prev\"), t.index) {\n            var n = this.store.index(t.index);\n            return t.keysOnly ? n.openKeyCursor(t.range, e) : n.openCursor(t.range, e);\n          }\n\n          return this.store.openCursor(t.range, e);\n        }, t;\n      }();\n\n      function ys(t) {\n        return new ls(function (e, n) {\n          t.onsuccess = function (t) {\n            var n = t.target.result;\n            e(n);\n          }, t.onerror = function (t) {\n            n(t.target.error);\n          };\n        });\n      }\n\n      var gs = function () {\n        function t(t, e) {\n          this.referenceDelegate = t, this.serializer = e, this.targetIdGenerator = hs.forQueryCache();\n        }\n\n        return t.prototype.allocateTargetId = function (t) {\n          var e = this;\n          return this.retrieveMetadata(t).next(function (n) {\n            return n.highestTargetId = e.targetIdGenerator.after(n.highestTargetId), e.saveMetadata(t, n).next(function () {\n              return n.highestTargetId;\n            });\n          });\n        }, t.prototype.getLastRemoteSnapshotVersion = function (t) {\n          return this.retrieveMetadata(t).next(function (t) {\n            return qi.fromTimestamp(new Ur(t.lastRemoteSnapshotVersion.seconds, t.lastRemoteSnapshotVersion.nanoseconds));\n          });\n        }, t.prototype.getHighestSequenceNumber = function (t) {\n          return ws(t.simpleDbTransaction);\n        }, t.prototype.setTargetsMetadata = function (t, e, n) {\n          var r = this;\n          return this.retrieveMetadata(t).next(function (i) {\n            return i.highestListenSequenceNumber = e, n && (i.lastRemoteSnapshotVersion = n.toTimestamp()), e > i.highestListenSequenceNumber && (i.highestListenSequenceNumber = e), r.saveMetadata(t, i);\n          });\n        }, t.prototype.addQueryData = function (t, e) {\n          var n = this;\n          return this.saveQueryData(t, e).next(function () {\n            return n.retrieveMetadata(t).next(function (r) {\n              return r.targetCount += 1, n.updateMetadataFromQueryData(e, r), n.saveMetadata(t, r);\n            });\n          });\n        }, t.prototype.updateQueryData = function (t, e) {\n          return this.saveQueryData(t, e);\n        }, t.prototype.removeQueryData = function (t, e) {\n          var n = this;\n          return this.removeMatchingKeysForTargetId(t, e.targetId).next(function () {\n            return vs(t).delete(e.targetId);\n          }).next(function () {\n            return n.retrieveMetadata(t);\n          }).next(function (e) {\n            return nr(e.targetCount > 0, \"Removing from an empty query cache\"), e.targetCount -= 1, n.saveMetadata(t, e);\n          });\n        }, t.prototype.removeTargets = function (t, e, n) {\n          var r = this,\n              i = 0,\n              o = [];\n          return vs(t).iterate(function (s, a) {\n            var u = r.serializer.fromDbTarget(a);\n            u.sequenceNumber <= e && void 0 === n[u.targetId] && (i++, o.push(r.removeQueryData(t, u)));\n          }).next(function () {\n            return ls.waitFor(o);\n          }).next(function () {\n            return i;\n          });\n        }, t.prototype.forEachTarget = function (t, e) {\n          var n = this;\n          return vs(t).iterate(function (t, r) {\n            var i = n.serializer.fromDbTarget(r);\n            e(i);\n          });\n        }, t.prototype.retrieveMetadata = function (t) {\n          return bs(t.simpleDbTransaction);\n        }, t.prototype.saveMetadata = function (t, e) {\n          return (n = t, ma.getStore(n, js.store)).put(js.key, e);\n          var n;\n        }, t.prototype.saveQueryData = function (t, e) {\n          return vs(t).put(this.serializer.toDbTarget(e));\n        }, t.prototype.updateMetadataFromQueryData = function (t, e) {\n          var n = !1;\n          return t.targetId > e.highestTargetId && (e.highestTargetId = t.targetId, n = !0), t.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t.sequenceNumber, n = !0), n;\n        }, t.prototype.getQueryCount = function (t) {\n          return this.retrieveMetadata(t).next(function (t) {\n            return t.targetCount;\n          });\n        }, t.prototype.getQueryData = function (t, e) {\n          var n = this,\n              r = e.canonicalId(),\n              i = IDBKeyRange.bound([r, Number.NEGATIVE_INFINITY], [r, Number.POSITIVE_INFINITY]),\n              o = null;\n          return vs(t).iterate({\n            range: i,\n            index: Ks.queryTargetsIndexName\n          }, function (t, r, i) {\n            var s = n.serializer.fromDbTarget(r);\n            e.isEqual(s.query) && (o = s, i.done());\n          }).next(function () {\n            return o;\n          });\n        }, t.prototype.addMatchingKeys = function (t, e, n) {\n          var r = this,\n              i = [],\n              o = Es(t);\n          return e.forEach(function (e) {\n            var s = ns(e.path);\n            i.push(o.put(new Ws(n, s))), i.push(r.referenceDelegate.addReference(t, e));\n          }), ls.waitFor(i);\n        }, t.prototype.removeMatchingKeys = function (t, e, n) {\n          var r = this,\n              i = Es(t);\n          return ls.forEach(e, function (e) {\n            var o = ns(e.path);\n            return ls.waitFor([i.delete([n, o]), r.referenceDelegate.removeReference(t, e)]);\n          });\n        }, t.prototype.removeMatchingKeysForTargetId = function (t, e) {\n          var n = Es(t),\n              r = IDBKeyRange.bound([e], [e + 1], !1, !0);\n          return n.delete(r);\n        }, t.prototype.getMatchingKeysForTargetId = function (t, e) {\n          var n = IDBKeyRange.bound([e], [e + 1], !1, !0),\n              r = Es(t),\n              i = po();\n          return r.iterate({\n            range: n,\n            keysOnly: !0\n          }, function (t, e, n) {\n            var r = os(t[1]),\n                o = new Hr(r);\n            i = i.add(o);\n          }).next(function () {\n            return i;\n          });\n        }, t.prototype.containsKey = function (t, e) {\n          var n,\n              r = ns(e.path),\n              i = IDBKeyRange.bound([r], [(n = r, n + \"\\0\")], !1, !0),\n              o = 0;\n          return Es(t).iterate({\n            index: Ws.documentTargetsIndex,\n            keysOnly: !0,\n            range: i\n          }, function (t, e, n) {\n            var r = t[0];\n            t[1];\n            0 !== r && (o++, n.done());\n          }).next(function () {\n            return o > 0;\n          });\n        }, t.prototype.getQueryDataForTarget = function (t, e) {\n          var n = this;\n          return vs(t).get(e).next(function (t) {\n            return t ? n.serializer.fromDbTarget(t) : null;\n          });\n        }, t;\n      }();\n\n      function vs(t) {\n        return ma.getStore(t, Ks.store);\n      }\n\n      function bs(t) {\n        return fs.getStore(t, js.store).get(js.key).next(function (t) {\n          return nr(null !== t, \"Missing metadata row.\"), t;\n        });\n      }\n\n      function ws(t) {\n        return bs(t).next(function (t) {\n          return t.highestListenSequenceNumber;\n        });\n      }\n\n      function Es(t) {\n        return ma.getStore(t, Ws.store);\n      }\n\n      var Ss = function () {\n        function t(t) {\n          this.mapKeyFn = t, this.inner = {};\n        }\n\n        return t.prototype.get = function (t) {\n          var e = this.mapKeyFn(t),\n              n = this.inner[e];\n          if (void 0 !== n) for (var r = 0, i = n; r < i.length; r++) {\n            var o = i[r],\n                s = o[0],\n                a = o[1];\n            if (s.isEqual(t)) return a;\n          }\n        }, t.prototype.has = function (t) {\n          return void 0 !== this.get(t);\n        }, t.prototype.set = function (t, e) {\n          var n = this.mapKeyFn(t),\n              r = this.inner[n];\n\n          if (void 0 !== r) {\n            for (var i = 0; i < r.length; i++) {\n              if (r[i][0].isEqual(t)) return void (r[i] = [t, e]);\n            }\n\n            r.push([t, e]);\n          } else this.inner[n] = [[t, e]];\n        }, t.prototype.delete = function (t) {\n          var e = this.mapKeyFn(t),\n              n = this.inner[e];\n          if (void 0 === n) return !1;\n\n          for (var r = 0; r < n.length; r++) {\n            if (n[r][0].isEqual(t)) return 1 === n.length ? delete this.inner[e] : n.splice(r, 1), !0;\n          }\n\n          return !1;\n        }, t.prototype.forEach = function (t) {\n          lr(this.inner, function (e, n) {\n            for (var r = 0, i = n; r < i.length; r++) {\n              var o = i[r],\n                  s = o[0],\n                  a = o[1];\n              t(s, a);\n            }\n          });\n        }, t.prototype.isEmpty = function () {\n          return fr(this.inner);\n        }, t;\n      }(),\n          Ts = function () {\n        function t() {\n          this.changes = so(), this.documentSizes = new Ss(function (t) {\n            return t.toString();\n          });\n        }\n\n        return t.prototype.addEntry = function (t) {\n          var e = this.assertChanges();\n          this.changes = e.insert(t.key, t);\n        }, t.prototype.getEntry = function (t, e) {\n          var n = this,\n              r = this.assertChanges().get(e);\n          return r ? ls.resolve(r) : this.getFromCache(t, e).next(function (t) {\n            return null === t ? (n.documentSizes.set(e, 0), null) : (n.documentSizes.set(e, t.size), t.maybeDocument);\n          });\n        }, t.prototype.getEntries = function (t, e) {\n          var n = this;\n          return this.getAllFromCache(t, e).next(function (t) {\n            var e = t.maybeDocuments;\n            return t.sizeMap.forEach(function (t, e) {\n              n.documentSizes.set(t, e);\n            }), e;\n          });\n        }, t.prototype.apply = function (t) {\n          var e = this.applyChanges(t);\n          return this.changes = null, e;\n        }, t.prototype.assertChanges = function () {\n          return nr(null !== this.changes, \"Changes have already been applied.\"), this.changes;\n        }, t;\n      }(),\n          Is = \"The remote document changelog no longer contains all changes for all local query views. It may be necessary to rebuild these views.\",\n          Cs = function () {\n        function t(t, e) {\n          this.serializer = t, this.keepDocumentChangeLog = e, this._lastProcessedDocumentChangeId = 0;\n        }\n\n        return Object.defineProperty(t.prototype, \"lastProcessedDocumentChangeId\", {\n          get: function get() {\n            return this._lastProcessedDocumentChangeId;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.start = function (t) {\n          var e = fs.getStore(t, Gs.store);\n          return this.synchronizeLastDocumentChangeId(e);\n        }, t.prototype.addEntries = function (t, e, n) {\n          var r = [];\n\n          if (e.length > 0) {\n            for (var i = As(t), o = po(), s = 0, a = e; s < a.length; s++) {\n              var u = a[s],\n                  c = u.key,\n                  h = u.doc;\n              r.push(i.put(Rs(c), h)), o = o.add(c);\n            }\n\n            this.keepDocumentChangeLog && r.push(ks(t).put({\n              changes: this.serializer.toDbResourcePaths(o)\n            })), r.push(this.updateSize(t, n));\n          }\n\n          return ls.waitFor(r);\n        }, t.prototype.removeEntry = function (t, e) {\n          var n = As(t),\n              r = Rs(e);\n          return n.get(r).next(function (t) {\n            return t ? n.delete(r).next(function () {\n              return Ms(t);\n            }) : ls.resolve(0);\n          });\n        }, t.prototype.getEntry = function (t, e) {\n          var n = this;\n          return As(t).get(Rs(e)).next(function (t) {\n            return t ? n.serializer.fromDbRemoteDocument(t) : null;\n          });\n        }, t.prototype.getSizedEntry = function (t, e) {\n          var n = this;\n          return As(t).get(Rs(e)).next(function (t) {\n            return t ? {\n              maybeDocument: n.serializer.fromDbRemoteDocument(t),\n              size: Ms(t)\n            } : null;\n          });\n        }, t.prototype.getEntries = function (t, e) {\n          var n = this,\n              r = ao();\n          return this.forEachDbEntry(t, e, function (t, e) {\n            r = e ? r.insert(t, n.serializer.fromDbRemoteDocument(e)) : r.insert(t, null);\n          }).next(function () {\n            return r;\n          });\n        }, t.prototype.getSizedEntries = function (t, e) {\n          var n = this,\n              r = ao(),\n              i = new $r(Hr.comparator);\n          return this.forEachDbEntry(t, e, function (t, e) {\n            e ? (r = r.insert(t, n.serializer.fromDbRemoteDocument(e)), i = i.insert(t, Ms(e))) : (r = r.insert(t, null), i = i.insert(t, 0));\n          }).next(function () {\n            return {\n              maybeDocuments: r,\n              sizeMap: i\n            };\n          });\n        }, t.prototype.forEachDbEntry = function (t, e, n) {\n          if (e.isEmpty()) return ls.resolve();\n          var r = IDBKeyRange.bound(e.first().path.toArray(), e.last().path.toArray()),\n              i = e.getIterator(),\n              o = i.getNext();\n          return As(t).iterate({\n            range: r\n          }, function (t, e, r) {\n            for (var s = Hr.fromSegments(t); o && Hr.comparator(o, s) < 0;) {\n              n(o, null), o = i.getNext();\n            }\n\n            o && o.isEqual(s) && (n(o, e), o = i.hasNext() ? i.getNext() : null), o ? r.skip(o.path.toArray()) : r.done();\n          }).next(function () {\n            for (; o;) {\n              n(o, null), o = i.hasNext() ? i.getNext() : null;\n            }\n          });\n        }, t.prototype.getDocumentsMatchingQuery = function (t, e) {\n          var n = this,\n              r = co(),\n              i = e.path.toArray(),\n              o = IDBKeyRange.lowerBound(i);\n          return As(t).iterate({\n            range: o\n          }, function (t, i, o) {\n            var s = n.serializer.fromDbRemoteDocument(i);\n            e.path.isPrefixOf(s.key.path) ? s instanceof Yr && e.matches(s) && (r = r.insert(s.key, s)) : o.done();\n          }).next(function () {\n            return r;\n          });\n        }, t.prototype.getNewDocumentChanges = function (t) {\n          var e = this;\n          nr(this.keepDocumentChangeLog, \"Can only call getNewDocumentChanges() when document change log is enabled\");\n          var n = po(),\n              r = so(),\n              i = IDBKeyRange.lowerBound(this._lastProcessedDocumentChangeId + 1),\n              o = !0,\n              s = ks(t);\n          return s.iterate({\n            range: i\n          }, function (t, r) {\n            if (o && (o = !1, e._lastProcessedDocumentChangeId + 1 !== r.id)) return e.synchronizeLastDocumentChangeId(s).next(function () {\n              return ls.reject(new sr(or.DATA_LOSS, Is));\n            });\n            n = n.unionWith(e.serializer.fromDbResourcePaths(r.changes)), e._lastProcessedDocumentChangeId = r.id;\n          }).next(function () {\n            var i = [];\n            return n.forEach(function (n) {\n              i.push(e.getEntry(t, n).next(function (t) {\n                var e = t || new Jr(n, qi.forDeletedDoc());\n                r = r.insert(n, e);\n              }));\n            }), ls.waitFor(i);\n          }).next(function () {\n            return r;\n          });\n        }, t.prototype.removeDocumentChangesThroughChangeId = function (t, e) {\n          var n = IDBKeyRange.upperBound(e);\n          return ks(t).delete(n);\n        }, t.prototype.synchronizeLastDocumentChangeId = function (t) {\n          var e = this;\n          return this._lastProcessedDocumentChangeId = 0, t.iterate({\n            keysOnly: !0,\n            reverse: !0\n          }, function (t, n, r) {\n            e._lastProcessedDocumentChangeId = t, r.done();\n          });\n        }, t.prototype.newChangeBuffer = function () {\n          return new Ns(this);\n        }, t.prototype.getSize = function (t) {\n          return this.getMetadata(t).next(function (t) {\n            return t.byteSize;\n          });\n        }, t.prototype.getMetadata = function (t) {\n          return Ds(t).get(Qs.key).next(function (t) {\n            return nr(!!t, \"Missing document cache metadata\"), t;\n          });\n        }, t.prototype.setMetadata = function (t, e) {\n          return Ds(t).put(Qs.key, e);\n        }, t.prototype.updateSize = function (t, e) {\n          var n = this;\n          return this.getMetadata(t).next(function (r) {\n            return r.byteSize += e, n.setMetadata(t, r);\n          });\n        }, t;\n      }();\n\n      function Ds(t) {\n        return ma.getStore(t, Qs.store);\n      }\n\n      var Ns = function (t) {\n        function e(e) {\n          var n = t.call(this) || this;\n          return n.documentCache = e, n;\n        }\n\n        return s(e, t), e.prototype.applyChanges = function (t) {\n          var e = this,\n              n = 0,\n              r = [];\n          return this.assertChanges().forEach(function (t, i) {\n            var o = e.documentCache.serializer.toDbRemoteDocument(i),\n                s = e.documentSizes.get(t);\n            nr(void 0 !== s, \"Attempting to change document \" + t.toString() + \" without having read it first\");\n            var a = Ms(o);\n            n += a - s, r.push({\n              key: t,\n              doc: o\n            });\n          }), this.documentCache.addEntries(t, r, n);\n        }, e.prototype.getFromCache = function (t, e) {\n          return this.documentCache.getSizedEntry(t, e);\n        }, e.prototype.getAllFromCache = function (t, e) {\n          return this.documentCache.getSizedEntries(t, e);\n        }, e;\n      }(Ts);\n\n      function As(t) {\n        return ma.getStore(t, Vs.store);\n      }\n\n      function ks(t) {\n        return ma.getStore(t, Gs.store);\n      }\n\n      function Rs(t) {\n        return t.path.toArray();\n      }\n\n      function Ms(t) {\n        var e;\n        if (t.document) e = t.document;else if (t.unknownDocument) e = t.unknownDocument;else {\n          if (!t.noDocument) throw er(\"Unknown remote document type\");\n          e = t.noDocument;\n        }\n        return JSON.stringify(e).length;\n      }\n\n      var Os = 7,\n          _s = function () {\n        function t(t) {\n          this.serializer = t;\n        }\n\n        return t.prototype.createOrUpgrade = function (t, e, n, r) {\n          var i = this;\n          nr(n < r && n >= 0 && r <= Os, \"Unexpected schema upgrade from v\" + n + \" to v{toVersion}.\"), n < 1 && r >= 1 && (function (t) {\n            t.createObjectStore(Ls.store);\n          }(t), function (t) {\n            t.createObjectStore(xs.store, {\n              keyPath: xs.keyPath\n            }), t.createObjectStore(qs.store, {\n              keyPath: qs.keyPath,\n              autoIncrement: !0\n            }).createIndex(qs.userMutationsIndex, qs.userMutationsKeyPath, {\n              unique: !0\n            }), t.createObjectStore(Fs.store);\n          }(t), zs(t), function (t) {\n            t.createObjectStore(Vs.store);\n          }(t));\n          var o = ls.resolve();\n          return n < 3 && r >= 3 && (0 !== n && (!function (t) {\n            t.deleteObjectStore(Ws.store), t.deleteObjectStore(Ks.store), t.deleteObjectStore(js.store);\n          }(t), zs(t)), o = o.next(function () {\n            return function (t) {\n              var e = t.store(js.store),\n                  n = new js(0, 0, qi.MIN.toTimestamp(), 0);\n              return e.put(js.key, n);\n            }(e);\n          })), n < 4 && r >= 4 && (0 !== n && (o = o.next(function () {\n            return function (t, e) {\n              return e.store(qs.store).loadAll().next(function (n) {\n                t.deleteObjectStore(qs.store);\n                var r = t.createObjectStore(qs.store, {\n                  keyPath: qs.keyPath,\n                  autoIncrement: !0\n                });\n                r.createIndex(qs.userMutationsIndex, qs.userMutationsKeyPath, {\n                  unique: !0\n                });\n                var i = e.store(qs.store),\n                    o = n.map(function (t) {\n                  return i.put(t);\n                });\n                return ls.waitFor(o);\n              });\n            }(t, e);\n          })), o = o.next(function () {\n            !function (t) {\n              t.createObjectStore(Hs.store, {\n                keyPath: Hs.keyPath\n              });\n            }(t), function (t) {\n              t.createObjectStore(Gs.store, {\n                keyPath: \"id\",\n                autoIncrement: !0\n              });\n            }(t);\n          })), n < 5 && r >= 5 && (o = o.next(function () {\n            return i.removeAcknowledgedMutations(e);\n          })), n < 6 && r >= 6 && (o = o.next(function () {\n            return function (t) {\n              t.createObjectStore(Qs.store);\n            }(t), i.addDocumentGlobal(e);\n          })), n < 7 && r >= 7 && (o = o.next(function () {\n            return i.ensureSequenceNumbers(e);\n          })), o;\n        }, t.prototype.addDocumentGlobal = function (t) {\n          var e = 0;\n          return t.store(Vs.store).iterate(function (t, n) {\n            e += Ms(n);\n          }).next(function () {\n            var n = new Qs(e);\n            return t.store(Qs.store).put(Qs.key, n);\n          });\n        }, t.prototype.removeAcknowledgedMutations = function (t) {\n          var e = this,\n              n = t.store(xs.store),\n              r = t.store(qs.store);\n          return n.loadAll().next(function (n) {\n            return ls.forEach(n, function (n) {\n              var i = IDBKeyRange.bound([n.userId, -1], [n.userId, n.lastAcknowledgedBatchId]);\n              return r.loadAll(qs.userMutationsIndex, i).next(function (r) {\n                return ls.forEach(r, function (r) {\n                  nr(r.userId === n.userId, \"Cannot process batch \" + r.batchId + \" from unexpected user\");\n                  var i = e.serializer.fromDbMutationBatch(r);\n                  return Zs(t, n.userId, i).next(function () {});\n                });\n              });\n            });\n          });\n        }, t.prototype.ensureSequenceNumbers = function (t) {\n          var e = t.store(Ws.store),\n              n = t.store(Vs.store);\n          return ws(t).next(function (t) {\n            var r = [];\n            return n.iterate(function (n, i) {\n              var o = new jr(n),\n                  s = function (t) {\n                return [0, ns(t)];\n              }(o);\n\n              r.push(e.get(s).next(function (n) {\n                return n ? ls.resolve() : function (n) {\n                  return e.put(new Ws(0, ns(n), t));\n                }(o);\n              }));\n            }).next(function () {\n              return ls.waitFor(r);\n            });\n          });\n        }, t;\n      }();\n\n      var Ps = function () {\n        return function (t, e) {\n          this.seconds = t, this.nanoseconds = e;\n        };\n      }(),\n          Ls = function () {\n        function t(t, e, n) {\n          this.ownerId = t, this.allowTabSynchronization = e, this.leaseTimestampMs = n;\n        }\n\n        return t.store = \"owner\", t.key = \"owner\", t;\n      }();\n\n      var xs = function () {\n        function t(t, e, n) {\n          this.userId = t, this.lastAcknowledgedBatchId = e, this.lastStreamToken = n;\n        }\n\n        return t.store = \"mutationQueues\", t.keyPath = \"userId\", t;\n      }(),\n          qs = function () {\n        function t(t, e, n, r) {\n          this.userId = t, this.batchId = e, this.localWriteTimeMs = n, this.mutations = r;\n        }\n\n        return t.store = \"mutations\", t.keyPath = \"batchId\", t.userMutationsIndex = \"userMutationsIndex\", t.userMutationsKeyPath = [\"userId\", \"batchId\"], t;\n      }();\n\n      var Fs = function () {\n        function t() {}\n\n        return t.prefixForUser = function (t) {\n          return [t];\n        }, t.prefixForPath = function (t, e) {\n          return [t, ns(e)];\n        }, t.key = function (t, e, n) {\n          return [t, ns(e), n];\n        }, t.store = \"documentMutations\", t.PLACEHOLDER = new t(), t;\n      }();\n\n      var Bs = function () {\n        return function (t, e) {\n          this.path = t, this.readTime = e;\n        };\n      }(),\n          Us = function () {\n        return function (t, e) {\n          this.path = t, this.version = e;\n        };\n      }(),\n          Vs = function () {\n        function t(t, e, n, r) {\n          this.unknownDocument = t, this.noDocument = e, this.document = n, this.hasCommittedMutations = r;\n        }\n\n        return t.store = \"remoteDocuments\", t;\n      }(),\n          Qs = function () {\n        function t(t) {\n          this.byteSize = t;\n        }\n\n        return t.store = \"remoteDocumentGlobal\", t.key = \"remoteDocumentGlobalKey\", t;\n      }();\n\n      var Ks = function () {\n        function t(t, e, n, r, i, o) {\n          this.targetId = t, this.canonicalId = e, this.readTime = n, this.resumeToken = r, this.lastListenSequenceNumber = i, this.query = o;\n        }\n\n        return t.store = \"targets\", t.keyPath = \"targetId\", t.queryTargetsIndexName = \"queryTargetsIndex\", t.queryTargetsKeyPath = [\"canonicalId\", \"targetId\"], t;\n      }(),\n          Ws = function () {\n        function t(t, e, n) {\n          this.targetId = t, this.path = e, this.sequenceNumber = n, nr(0 === t == (void 0 !== n), \"A target-document row must either have targetId == 0 and a defined sequence number, or a non-zero targetId and no sequence number\");\n        }\n\n        return t.store = \"targetDocuments\", t.keyPath = [\"targetId\", \"path\"], t.documentTargetsIndex = \"documentTargetsIndex\", t.documentTargetsKeyPath = [\"path\", \"targetId\"], t;\n      }(),\n          js = function () {\n        function t(t, e, n, r) {\n          this.highestTargetId = t, this.highestListenSequenceNumber = e, this.lastRemoteSnapshotVersion = n, this.targetCount = r;\n        }\n\n        return t.key = \"targetGlobalKey\", t.store = \"targetGlobal\", t;\n      }();\n\n      function zs(t) {\n        t.createObjectStore(Ws.store, {\n          keyPath: Ws.keyPath\n        }).createIndex(Ws.documentTargetsIndex, Ws.documentTargetsKeyPath, {\n          unique: !0\n        }), t.createObjectStore(Ks.store, {\n          keyPath: Ks.keyPath\n        }).createIndex(Ks.queryTargetsIndexName, Ks.queryTargetsKeyPath, {\n          unique: !0\n        }), t.createObjectStore(js.store);\n      }\n\n      var Gs = function () {\n        function t(t) {\n          this.changes = t;\n        }\n\n        return t.store = \"remoteDocumentChanges\", t.keyPath = \"id\", t;\n      }();\n\n      var Hs = function () {\n        function t(t, e, n, r, i) {\n          this.clientId = t, this.updateTimeMs = e, this.networkEnabled = n, this.inForeground = r, this.lastProcessedDocumentChangeId = i;\n        }\n\n        return t.store = \"clientMetadata\", t.keyPath = \"clientId\", t;\n      }();\n\n      var Xs = [xs.store, qs.store, Fs.store, Vs.store, Ks.store, Ls.store, js.store, Ws.store].concat([Hs.store, Gs.store]).concat([Qs.store]),\n          Ys = function () {\n        function t(t, e, n) {\n          this.userId = t, this.serializer = e, this.referenceDelegate = n, this.documentKeysByBatchId = {};\n        }\n\n        return t.forUser = function (e, n, r) {\n          return nr(\"\" !== e.uid, \"UserID must not be an empty string.\"), new t(e.isAuthenticated() ? e.uid : \"\", n, r);\n        }, t.prototype.checkEmpty = function (t) {\n          var e = !0,\n              n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);\n          return ta(t).iterate({\n            index: qs.userMutationsIndex,\n            range: n\n          }, function (t, n, r) {\n            e = !1, r.done();\n          }).next(function () {\n            return e;\n          });\n        }, t.prototype.acknowledgeBatch = function (t, e, n) {\n          return this.getMutationQueueMetadata(t).next(function (e) {\n            return e.lastStreamToken = $s(n), na(t).put(e);\n          });\n        }, t.prototype.getLastStreamToken = function (t) {\n          return this.getMutationQueueMetadata(t).next(function (t) {\n            return t.lastStreamToken;\n          });\n        }, t.prototype.setLastStreamToken = function (t, e) {\n          return this.getMutationQueueMetadata(t).next(function (n) {\n            return n.lastStreamToken = $s(e), na(t).put(n);\n          });\n        }, t.prototype.addMutationBatch = function (t, e, n) {\n          var r = this,\n              i = ea(t),\n              o = ta(t);\n          return o.add({}).next(function (t) {\n            nr(\"number\" == typeof t, \"Auto-generated key is not a number\");\n            var s = new as(t, e, n),\n                a = r.serializer.toDbMutationBatch(r.userId, s);\n            r.documentKeysByBatchId[t] = s.keys();\n\n            for (var u = [], c = 0, h = n; c < h.length; c++) {\n              var l = h[c],\n                  f = Fs.key(r.userId, l.key.path, t);\n              u.push(o.put(a)), u.push(i.put(f, Fs.PLACEHOLDER));\n            }\n\n            return ls.waitFor(u).next(function () {\n              return s;\n            });\n          });\n        }, t.prototype.lookupMutationBatch = function (t, e) {\n          var n = this;\n          return ta(t).get(e).next(function (t) {\n            return t ? (nr(t.userId === n.userId, \"Unexpected user '\" + t.userId + \"' for mutation batch \" + e), n.serializer.fromDbMutationBatch(t)) : null;\n          });\n        }, t.prototype.lookupMutationKeys = function (t, e) {\n          var n = this;\n          return this.documentKeysByBatchId[e] ? ls.resolve(this.documentKeysByBatchId[e]) : this.lookupMutationBatch(t, e).next(function (t) {\n            if (t) {\n              var r = t.keys();\n              return n.documentKeysByBatchId[e] = r, r;\n            }\n\n            return null;\n          });\n        }, t.prototype.getNextMutationBatchAfterBatchId = function (t, e) {\n          var n = this;\n          return this.getMutationQueueMetadata(t).next(function (r) {\n            var i = e + 1,\n                o = IDBKeyRange.lowerBound([n.userId, i]),\n                s = null;\n            return ta(t).iterate({\n              index: qs.userMutationsIndex,\n              range: o\n            }, function (t, e, r) {\n              e.userId === n.userId && (nr(e.batchId >= i, \"Should have found mutation after \" + i), s = n.serializer.fromDbMutationBatch(e)), r.done();\n            }).next(function () {\n              return s;\n            });\n          });\n        }, t.prototype.getAllMutationBatches = function (t) {\n          var e = this,\n              n = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);\n          return ta(t).loadAll(qs.userMutationsIndex, n).next(function (t) {\n            return t.map(function (t) {\n              return e.serializer.fromDbMutationBatch(t);\n            });\n          });\n        }, t.prototype.getAllMutationBatchesAffectingDocumentKey = function (t, e) {\n          var n = this,\n              r = Fs.prefixForPath(this.userId, e.path),\n              i = IDBKeyRange.lowerBound(r),\n              o = [];\n          return ea(t).iterate({\n            range: i\n          }, function (r, i, s) {\n            var a = r[0],\n                u = r[1],\n                c = r[2],\n                h = os(u);\n            if (a === n.userId && e.path.isEqual(h)) return ta(t).get(c).next(function (t) {\n              if (!t) throw er(\"Dangling document-mutation reference found: \" + r + \" which points to \" + c);\n              nr(t.userId === n.userId, \"Unexpected user '\" + t.userId + \"' for mutation batch \" + c), o.push(n.serializer.fromDbMutationBatch(t));\n            });\n            s.done();\n          }).next(function () {\n            return o;\n          });\n        }, t.prototype.getAllMutationBatchesAffectingDocumentKeys = function (t, e) {\n          var n = this,\n              r = new Ui(Mr),\n              i = [];\n          return e.forEach(function (e) {\n            var o = Fs.prefixForPath(n.userId, e.path),\n                s = IDBKeyRange.lowerBound(o),\n                a = ea(t).iterate({\n              range: s\n            }, function (t, i, o) {\n              var s = t[0],\n                  a = t[1],\n                  u = t[2],\n                  c = os(a);\n              s === n.userId && e.path.isEqual(c) ? r = r.add(u) : o.done();\n            });\n            i.push(a);\n          }), ls.waitFor(i).next(function () {\n            return n.lookupMutationBatches(t, r);\n          });\n        }, t.prototype.getAllMutationBatchesAffectingQuery = function (t, e) {\n          var n = this;\n          nr(!e.isDocumentQuery(), \"Document queries shouldn't go down this path\");\n          var r = e.path,\n              i = r.length + 1,\n              o = Fs.prefixForPath(this.userId, r),\n              s = IDBKeyRange.lowerBound(o),\n              a = new Ui(Mr);\n          return ea(t).iterate({\n            range: s\n          }, function (t, e, o) {\n            var s = t[0],\n                u = t[1],\n                c = t[2],\n                h = os(u);\n            s === n.userId && r.isPrefixOf(h) ? h.length === i && (a = a.add(c)) : o.done();\n          }).next(function () {\n            return n.lookupMutationBatches(t, a);\n          });\n        }, t.prototype.lookupMutationBatches = function (t, e) {\n          var n = this,\n              r = [],\n              i = [];\n          return e.forEach(function (e) {\n            i.push(ta(t).get(e).next(function (t) {\n              if (null === t) throw er(\"Dangling document-mutation reference found, which points to \" + e);\n              nr(t.userId === n.userId, \"Unexpected user '\" + t.userId + \"' for mutation batch \" + e), r.push(n.serializer.fromDbMutationBatch(t));\n            }));\n          }), ls.waitFor(i).next(function () {\n            return r;\n          });\n        }, t.prototype.removeMutationBatch = function (t, e) {\n          var n = this;\n          return Zs(t.simpleDbTransaction, this.userId, e).next(function (r) {\n            return n.removeCachedMutationKeys(e.batchId), ls.forEach(r, function (e) {\n              return n.referenceDelegate.removeMutationReference(t, e);\n            });\n          });\n        }, t.prototype.removeCachedMutationKeys = function (t) {\n          delete this.documentKeysByBatchId[t];\n        }, t.prototype.performConsistencyCheck = function (t) {\n          var e = this;\n          return this.checkEmpty(t).next(function (n) {\n            if (!n) return ls.resolve();\n            var r = IDBKeyRange.lowerBound(Fs.prefixForUser(e.userId)),\n                i = [];\n            return ea(t).iterate({\n              range: r\n            }, function (t, n, r) {\n              if (t[0] === e.userId) {\n                var o = os(t[1]);\n                i.push(o);\n              } else r.done();\n            }).next(function () {\n              nr(0 === i.length, \"Document leak -- detected dangling mutation references when queue is empty. Dangling keys: \" + i.map(function (t) {\n                return t.canonicalString();\n              }));\n            });\n          });\n        }, t.prototype.containsKey = function (t, e) {\n          return Js(t, this.userId, e);\n        }, t.prototype.getMutationQueueMetadata = function (t) {\n          var e = this;\n          return na(t).get(this.userId).next(function (t) {\n            return t || new xs(e.userId, -1, \"\");\n          });\n        }, t;\n      }();\n\n      function Js(t, e, n) {\n        var r = Fs.prefixForPath(e, n.path),\n            i = r[1],\n            o = IDBKeyRange.lowerBound(r),\n            s = !1;\n        return ea(t).iterate({\n          range: o,\n          keysOnly: !0\n        }, function (t, n, r) {\n          var o = t[0],\n              a = t[1];\n          t[2];\n          o === e && a === i && (s = !0), r.done();\n        }).next(function () {\n          return s;\n        });\n      }\n\n      function Zs(t, e, n) {\n        var r = t.store(qs.store),\n            i = t.store(Fs.store),\n            o = [],\n            s = IDBKeyRange.only(n.batchId),\n            a = 0,\n            u = r.iterate({\n          range: s\n        }, function (t, e, n) {\n          return a++, n.delete();\n        });\n        o.push(u.next(function () {\n          nr(1 === a, \"Dangling document-mutation reference found: Missing batch \" + n.batchId);\n        }));\n\n        for (var c = [], h = 0, l = n.mutations; h < l.length; h++) {\n          var f = l[h],\n              d = Fs.key(e, f.key.path, n.batchId);\n          o.push(i.delete(d)), c.push(f.key);\n        }\n\n        return ls.waitFor(o).next(function () {\n          return c;\n        });\n      }\n\n      function $s(t) {\n        return t instanceof Uint8Array ? (nr(\"YES\" === process.env.USE_MOCK_PERSISTENCE, \"Persisting non-string stream tokens is only supported with mock persistence.\"), t.toString()) : t;\n      }\n\n      function ta(t) {\n        return ma.getStore(t, qs.store);\n      }\n\n      function ea(t) {\n        return ma.getStore(t, Fs.store);\n      }\n\n      function na(t) {\n        return ma.getStore(t, xs.store);\n      }\n\n      var ra = function () {\n        function t(t) {\n          this.remoteSerializer = t;\n        }\n\n        return t.prototype.fromDbRemoteDocument = function (t) {\n          if (t.document) return this.remoteSerializer.fromDocument(t.document, !!t.hasCommittedMutations);\n\n          if (t.noDocument) {\n            var e = Hr.fromSegments(t.noDocument.path),\n                n = this.fromDbTimestamp(t.noDocument.readTime);\n            return new Jr(e, n, {\n              hasCommittedMutations: !!t.hasCommittedMutations\n            });\n          }\n\n          if (t.unknownDocument) {\n            e = Hr.fromSegments(t.unknownDocument.path), n = this.fromDbTimestamp(t.unknownDocument.version);\n            return new Zr(e, n);\n          }\n\n          return er(\"Unexpected DbRemoteDocument\");\n        }, t.prototype.toDbRemoteDocument = function (t) {\n          if (t instanceof Yr) {\n            var e = t.proto ? t.proto : this.remoteSerializer.toDocument(t),\n                n = t.hasCommittedMutations;\n            return new Vs(null, null, e, n);\n          }\n\n          if (t instanceof Jr) {\n            var r = t.key.path.toArray(),\n                i = this.toDbTimestamp(t.version);\n            n = t.hasCommittedMutations;\n            return new Vs(null, new Bs(r, i), null, n);\n          }\n\n          if (t instanceof Zr) {\n            r = t.key.path.toArray(), i = this.toDbTimestamp(t.version);\n            return new Vs(new Us(r, i), null, null, !0);\n          }\n\n          return er(\"Unexpected MaybeDocumment\");\n        }, t.prototype.toDbTimestamp = function (t) {\n          var e = t.toTimestamp();\n          return new Ps(e.seconds, e.nanoseconds);\n        }, t.prototype.fromDbTimestamp = function (t) {\n          var e = new Ur(t.seconds, t.nanoseconds);\n          return qi.fromTimestamp(e);\n        }, t.prototype.toDbMutationBatch = function (t, e) {\n          var n = this,\n              r = e.mutations.map(function (t) {\n            return n.remoteSerializer.toMutation(t);\n          });\n          return new qs(t, e.batchId, e.localWriteTime.toMillis(), r);\n        }, t.prototype.fromDbMutationBatch = function (t) {\n          var e = this,\n              n = t.mutations.map(function (t) {\n            return e.remoteSerializer.fromMutation(t);\n          }),\n              r = Ur.fromMillis(t.localWriteTimeMs);\n          return new as(t.batchId, r, n);\n        }, t.prototype.toDbResourcePaths = function (t) {\n          var e = [];\n          return t.forEach(function (t) {\n            e.push(ns(t.path));\n          }), e;\n        }, t.prototype.fromDbResourcePaths = function (t) {\n          for (var e = po(), n = 0, r = t; n < r.length; n++) {\n            var i = r[n];\n            e = e.add(new Hr(os(i)));\n          }\n\n          return e;\n        }, t.prototype.fromDbTarget = function (t) {\n          var e,\n              n = this.fromDbTimestamp(t.readTime);\n          return e = void 0 !== t.query.documents ? this.remoteSerializer.fromDocumentsTarget(t.query) : this.remoteSerializer.fromQueryTarget(t.query), new Bi(e, t.targetId, Ci.Listen, t.lastListenSequenceNumber, n, t.resumeToken);\n        }, t.prototype.toDbTarget = function (t) {\n          nr(Ci.Listen === t.purpose, \"Only queries with purpose \" + Ci.Listen + \" may be stored, got \" + t.purpose);\n          var e,\n              n,\n              r = this.toDbTimestamp(t.snapshotVersion);\n          return e = t.query.isDocumentQuery() ? this.remoteSerializer.toDocumentsTarget(t.query) : this.remoteSerializer.toQueryTarget(t.query), t.resumeToken instanceof Uint8Array ? (nr(\"YES\" === process.env.USE_MOCK_PERSISTENCE, \"Persisting non-string stream tokens is only supported with mock persistence .\"), n = t.resumeToken.toString()) : n = t.resumeToken, new Ks(t.targetId, t.query.canonicalId(), r, n, t.sequenceNumber, e);\n        }, t;\n      }();\n\n      function ia(t, e) {\n        var n = t[0],\n            r = t[1],\n            i = e[0],\n            o = e[1],\n            s = Mr(n, i);\n        return 0 === s ? Mr(r, o) : s;\n      }\n\n      var oa = function () {\n        function t(t) {\n          this.maxElements = t, this.buffer = new Ui(ia), this.previousIndex = 0;\n        }\n\n        return t.prototype.nextIndex = function () {\n          return ++this.previousIndex;\n        }, t.prototype.addElement = function (t) {\n          var e = [t, this.nextIndex()];\n          if (this.buffer.size < this.maxElements) this.buffer = this.buffer.add(e);else {\n            var n = this.buffer.last();\n            ia(e, n) < 0 && (this.buffer = this.buffer.delete(n).add(e));\n          }\n        }, Object.defineProperty(t.prototype, \"maxValue\", {\n          get: function get() {\n            return this.buffer.last()[0];\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t;\n      }(),\n          sa = {\n        didRun: !1,\n        sequenceNumbersCollected: 0,\n        targetsRemoved: 0,\n        documentsRemoved: 0\n      },\n          aa = function () {\n        function t(t, e, n) {\n          this.cacheSizeCollectionThreshold = t, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;\n        }\n\n        return t.withCacheSize = function (e) {\n          return new t(e, t.DEFAULT_COLLECTION_PERCENTILE, t.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\n        }, t.COLLECTION_DISABLED = -1, t.MINIMUM_CACHE_SIZE_BYTES = 1048576, t.DEFAULT_CACHE_SIZE_BYTES = 41943040, t.DEFAULT_COLLECTION_PERCENTILE = 10, t.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, t.DEFAULT = new t(t.DEFAULT_CACHE_SIZE_BYTES, t.DEFAULT_COLLECTION_PERCENTILE, t.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), t.DISABLED = new t(t.COLLECTION_DISABLED, 0, 0), t;\n      }(),\n          ua = function () {\n        function t(t, e, n) {\n          this.garbageCollector = t, this.asyncQueue = e, this.localStore = n, this.gcTask = null;\n        }\n\n        return t.prototype.start = function () {\n          nr(null === this.gcTask, \"Cannot start an already started LruScheduler\"), this.garbageCollector.params.cacheSizeCollectionThreshold !== aa.COLLECTION_DISABLED && this.scheduleGC();\n        }, t.prototype.stop = function () {\n          this.gcTask && (this.gcTask.cancel(), this.gcTask = null);\n        }, Object.defineProperty(t.prototype, \"started\", {\n          get: function get() {\n            return null !== this.gcTask;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.scheduleGC = function () {\n          var t = this;\n          nr(null === this.gcTask, \"Cannot schedule GC while a task is pending\");\n          var e = this.hasRun ? 3e5 : 6e4;\n          Zn(\"LruGarbageCollector\", \"Garbage collection scheduled in \" + e + \"ms\"), this.gcTask = this.asyncQueue.enqueueAfterDelay(Go.LruGarbageCollection, e, function () {\n            return t.gcTask = null, t.hasRun = !0, t.localStore.collectGarbage(t.garbageCollector).then(function () {\n              return t.scheduleGC();\n            }).catch(ya);\n          });\n        }, t;\n      }(),\n          ca = function () {\n        function t(t, e) {\n          this.delegate = t, this.params = e;\n        }\n\n        return t.prototype.calculateTargetCount = function (t, e) {\n          return this.delegate.getSequenceNumberCount(t).next(function (t) {\n            return Math.floor(e / 100 * t);\n          });\n        }, t.prototype.nthSequenceNumber = function (t, e) {\n          var n = this;\n          if (0 === e) return ls.resolve(Ho.INVALID);\n          var r = new oa(e);\n          return this.delegate.forEachTarget(t, function (t) {\n            return r.addElement(t.sequenceNumber);\n          }).next(function () {\n            return n.delegate.forEachOrphanedDocumentSequenceNumber(t, function (t) {\n              return r.addElement(t);\n            });\n          }).next(function () {\n            return r.maxValue;\n          });\n        }, t.prototype.removeTargets = function (t, e, n) {\n          return this.delegate.removeTargets(t, e, n);\n        }, t.prototype.removeOrphanedDocuments = function (t, e) {\n          return this.delegate.removeOrphanedDocuments(t, e);\n        }, t.prototype.collect = function (t, e) {\n          var n = this;\n          return this.params.cacheSizeCollectionThreshold === aa.COLLECTION_DISABLED ? (Zn(\"LruGarbageCollector\", \"Garbage collection skipped; disabled\"), ls.resolve(sa)) : this.getCacheSize(t).next(function (r) {\n            return r < n.params.cacheSizeCollectionThreshold ? (Zn(\"LruGarbageCollector\", \"Garbage collection skipped; Cache size \" + r + \" is lower than threshold \" + n.params.cacheSizeCollectionThreshold), sa) : n.runGarbageCollection(t, e);\n          });\n        }, t.prototype.getCacheSize = function (t) {\n          return this.delegate.getCacheSize(t);\n        }, t.prototype.runGarbageCollection = function (t, e) {\n          var n,\n              r,\n              i,\n              o,\n              s,\n              a,\n              u,\n              c,\n              h = this;\n          return o = Date.now(), this.calculateTargetCount(t, this.params.percentileToCollect).next(function (e) {\n            return e > h.params.maximumSequenceNumbersToCollect ? (Zn(\"LruGarbageCollector\", \"Capping sequence numbers to collect down to the maximum of \" + h.params.maximumSequenceNumbersToCollect + \" from \" + e), r = h.params.maximumSequenceNumbersToCollect) : r = e, s = Date.now(), h.nthSequenceNumber(t, r);\n          }).next(function (r) {\n            return n = r, a = Date.now(), h.removeTargets(t, n, e);\n          }).next(function (e) {\n            return i = e, u = Date.now(), h.removeOrphanedDocuments(t, n);\n          }).next(function (t) {\n            (c = Date.now(), Yn() <= jn.DEBUG) && Zn(\"LruGarbageCollector\", \"LRU Garbage Collection\\n\\tCounted targets in \" + (s - o) + \"ms\\n\\tDetermined least recently used \" + r + \" in \" + (a - s) + \"ms\\n\\tRemoved \" + i + \" targets in \" + (u - a) + \"ms\\n\\tRemoved \" + t + \" documents in \" + (c - u) + \"ms\\nTotal Duration: \" + (c - o) + \"ms\");\n            return ls.resolve({\n              didRun: !0,\n              sequenceNumbersCollected: r,\n              targetsRemoved: i,\n              documentsRemoved: t\n            });\n          });\n        }, t;\n      }(),\n          ha = \"IndexedDbPersistence\",\n          la = \"The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.\",\n          fa = \"Another tab has exclusive access to the persistence layer. To allow shared access, make sure to invoke `enablePersistence()` with `experimentalTabSynchronization:true` in all tabs.\",\n          da = \"This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.\",\n          pa = function (t) {\n        function e(e, n) {\n          var r = t.call(this) || this;\n          return r.simpleDbTransaction = e, r.currentSequenceNumber = n, r;\n        }\n\n        return s(e, t), e;\n      }(function () {\n        return function () {};\n      }()),\n          ma = function () {\n        function t(e, n, r, i, o, s, a) {\n          if (this.persistenceKey = e, this.clientId = n, this.queue = i, this.multiClientParams = a, this._started = !1, this.isPrimary = !1, this.networkEnabled = !0, this.inForeground = !1, this.lastGarbageCollectionTime = Number.NEGATIVE_INFINITY, this.primaryStateListener = function (t) {\n            return Promise.resolve();\n          }, !t.isAvailable()) throw new sr(or.UNIMPLEMENTED, da);\n          if (this.referenceDelegate = new ba(this, s), this.dbName = e + t.MAIN_DATABASE, this.serializer = new ra(o), this.document = r.document, this.allowTabSynchronization = void 0 !== a, this.queryCache = new gs(this.referenceDelegate, this.serializer), this.remoteDocumentCache = new Cs(this.serializer, this.allowTabSynchronization), !r.window || !r.window.localStorage) throw new sr(or.UNIMPLEMENTED, \"IndexedDB persistence is only available on platforms that support LocalStorage.\");\n          this.window = r.window, this.webStorage = this.window.localStorage;\n        }\n\n        return t.getStore = function (t, e) {\n          if (t instanceof pa) return fs.getStore(t.simpleDbTransaction, e);\n          throw er(\"IndexedDbPersistence must use instances of IndexedDbTransaction\");\n        }, t.createIndexedDbPersistence = function (e, n, r, i, o, s) {\n          return a(this, void 0, void 0, function () {\n            var a;\n            return u(this, function (u) {\n              switch (u.label) {\n                case 0:\n                  return [4, (a = new t(e, n, r, i, o, s)).start()];\n\n                case 1:\n                  return u.sent(), [2, a];\n              }\n            });\n          });\n        }, t.createMultiClientIndexedDbPersistence = function (e, n, r, i, o, s, c) {\n          return a(this, void 0, void 0, function () {\n            var a;\n            return u(this, function (u) {\n              switch (u.label) {\n                case 0:\n                  return [4, (a = new t(e, n, r, i, o, s, c)).start()];\n\n                case 1:\n                  return u.sent(), [2, a];\n              }\n            });\n          });\n        }, t.prototype.start = function () {\n          var t = this;\n          return nr(!this.started, \"IndexedDbPersistence double-started!\"), nr(null !== this.window, \"Expected 'window' to be defined\"), fs.openOrCreate(this.dbName, Os, new _s(this.serializer)).then(function (e) {\n            t.simpleDb = e;\n          }).then(function () {\n            return t.startRemoteDocumentCache();\n          }).then(function () {\n            return t.attachVisibilityHandler(), t.attachWindowUnloadHook(), t.updateClientMetadataAndTryBecomePrimary().then(function () {\n              return t.scheduleClientMetadataAndPrimaryLeaseRefreshes();\n            });\n          }).then(function () {\n            return t.simpleDb.runTransaction(\"readonly\", [js.store], function (e) {\n              return ws(e).next(function (e) {\n                var n = t.multiClientParams ? t.multiClientParams.sequenceNumberSyncer : void 0;\n                t.listenSequence = new Ho(e, n);\n              });\n            });\n          }).then(function () {\n            t._started = !0;\n          }).catch(function (e) {\n            return t.simpleDb && t.simpleDb.close(), Promise.reject(e);\n          });\n        }, t.prototype.startRemoteDocumentCache = function () {\n          var t = this;\n          return this.simpleDb.runTransaction(\"readonly\", Xs, function (e) {\n            return t.remoteDocumentCache.start(e);\n          });\n        }, t.prototype.setPrimaryStateListener = function (t) {\n          var e = this;\n          return this.primaryStateListener = function (n) {\n            return a(e, void 0, void 0, function () {\n              return u(this, function (e) {\n                return this.started ? [2, t(n)] : [2];\n              });\n            });\n          }, t(this.isPrimary);\n        }, t.prototype.setNetworkEnabled = function (t) {\n          var e = this;\n          this.networkEnabled !== t && (this.networkEnabled = t, this.queue.enqueueAndForget(function () {\n            return a(e, void 0, void 0, function () {\n              return u(this, function (t) {\n                switch (t.label) {\n                  case 0:\n                    return this.started ? [4, this.updateClientMetadataAndTryBecomePrimary()] : [3, 2];\n\n                  case 1:\n                    t.sent(), t.label = 2;\n\n                  case 2:\n                    return [2];\n                }\n              });\n            });\n          }));\n        }, t.prototype.updateClientMetadataAndTryBecomePrimary = function () {\n          var t = this;\n          return this.simpleDb.runTransaction(\"readwrite\", Xs, function (e) {\n            return va(e).put(new Hs(t.clientId, Date.now(), t.networkEnabled, t.inForeground, t.remoteDocumentCache.lastProcessedDocumentChangeId)).next(function () {\n              if (t.isPrimary) return t.verifyPrimaryLease(e).next(function (e) {\n                e || (t.isPrimary = !1, t.queue.enqueueAndForget(function () {\n                  return t.primaryStateListener(!1);\n                }));\n              });\n            }).next(function () {\n              return t.canActAsPrimary(e);\n            }).next(function (n) {\n              var r = t.isPrimary;\n              return t.isPrimary = n, r !== t.isPrimary && t.queue.enqueueAndForget(function () {\n                return t.primaryStateListener(t.isPrimary);\n              }), r && !t.isPrimary ? t.releasePrimaryLeaseIfHeld(e) : t.isPrimary ? t.acquireOrExtendPrimaryLease(e) : void 0;\n            });\n          });\n        }, t.prototype.verifyPrimaryLease = function (t) {\n          var e = this;\n          return ga(t).get(Ls.key).next(function (t) {\n            return ls.resolve(e.isLocalClient(t));\n          });\n        }, t.prototype.removeClientMetadata = function (t) {\n          return va(t).delete(this.clientId);\n        }, t.prototype.maybeGarbageCollectMultiClientState = function () {\n          return a(this, void 0, void 0, function () {\n            var e,\n                n,\n                r = this;\n            return u(this, function (i) {\n              switch (i.label) {\n                case 0:\n                  return !this.isPrimary || this.isWithinAge(this.lastGarbageCollectionTime, 18e5) ? [3, 2] : (this.lastGarbageCollectionTime = Date.now(), n = [], [4, this.runTransaction(\"maybeGarbageCollectMultiClientState\", \"readwrite-primary\", function (i) {\n                    var o = t.getStore(i, Hs.store);\n                    return o.loadAll().next(function (t) {\n                      e = r.filterActiveClients(t, 18e5), n = t.filter(function (t) {\n                        return -1 === e.indexOf(t);\n                      });\n                    }).next(function () {\n                      return ls.forEach(n, function (t) {\n                        return o.delete(t.clientId);\n                      });\n                    }).next(function () {\n                      if ((e = e.filter(function (t) {\n                        return t.clientId !== r.clientId;\n                      })).length > 0) {\n                        var t = e.map(function (t) {\n                          return t.lastProcessedDocumentChangeId || 0;\n                        }),\n                            n = Math.min.apply(Math, t);\n                        return r.remoteDocumentCache.removeDocumentChangesThroughChangeId(i, n);\n                      }\n                    });\n                  })]);\n\n                case 1:\n                  i.sent(), n.forEach(function (t) {\n                    r.window.localStorage.removeItem(r.zombiedClientLocalStorageKey(t.clientId));\n                  }), i.label = 2;\n\n                case 2:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.scheduleClientMetadataAndPrimaryLeaseRefreshes = function () {\n          var t = this;\n          this.clientMetadataRefresher = this.queue.enqueueAfterDelay(Go.ClientMetadataRefresh, 4e3, function () {\n            return t.updateClientMetadataAndTryBecomePrimary().then(function () {\n              return t.maybeGarbageCollectMultiClientState();\n            }).then(function () {\n              return t.scheduleClientMetadataAndPrimaryLeaseRefreshes();\n            });\n          });\n        }, t.prototype.isLocalClient = function (t) {\n          return !!t && t.ownerId === this.clientId;\n        }, t.prototype.canActAsPrimary = function (t) {\n          var e = this;\n          return ga(t).get(Ls.key).next(function (n) {\n            if (null !== n && e.isWithinAge(n.leaseTimestampMs, 5e3) && !e.isClientZombied(n.ownerId)) {\n              if (e.isLocalClient(n) && e.networkEnabled) return !0;\n\n              if (!e.isLocalClient(n)) {\n                if (!n.allowTabSynchronization) throw new sr(or.FAILED_PRECONDITION, fa);\n                return !1;\n              }\n            }\n\n            return !(!e.networkEnabled || !e.inForeground) || va(t).loadAll().next(function (t) {\n              return void 0 === e.filterActiveClients(t, 5e3).find(function (t) {\n                if (e.clientId !== t.clientId) {\n                  var n = !e.networkEnabled && t.networkEnabled,\n                      r = !e.inForeground && t.inForeground,\n                      i = e.networkEnabled === t.networkEnabled;\n                  if (n || r && i) return !0;\n                }\n\n                return !1;\n              });\n            });\n          }).next(function (t) {\n            return e.isPrimary !== t && Zn(ha, \"Client \" + (t ? \"is\" : \"is not\") + \" eligible for a primary lease.\"), t;\n          });\n        }, t.prototype.shutdown = function (t) {\n          return a(this, void 0, void 0, function () {\n            var e = this;\n            return u(this, function (n) {\n              switch (n.label) {\n                case 0:\n                  return this._started = !1, this.markClientZombied(), this.clientMetadataRefresher && this.clientMetadataRefresher.cancel(), this.detachVisibilityHandler(), this.detachWindowUnloadHook(), [4, this.simpleDb.runTransaction(\"readwrite\", [Ls.store, Hs.store], function (t) {\n                    return e.releasePrimaryLeaseIfHeld(t).next(function () {\n                      return e.removeClientMetadata(t);\n                    });\n                  })];\n\n                case 1:\n                  return n.sent(), this.simpleDb.close(), this.removeClientZombiedEntry(), t ? [4, fs.delete(this.dbName)] : [3, 3];\n\n                case 2:\n                  n.sent(), n.label = 3;\n\n                case 3:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.filterActiveClients = function (t, e) {\n          var n = this;\n          return t.filter(function (t) {\n            return n.isWithinAge(t.updateTimeMs, e) && !n.isClientZombied(t.clientId);\n          });\n        }, t.prototype.getActiveClients = function () {\n          var t = this;\n          return this.simpleDb.runTransaction(\"readonly\", [Hs.store], function (e) {\n            return va(e).loadAll().next(function (e) {\n              return t.filterActiveClients(e, 18e5).map(function (t) {\n                return t.clientId;\n              });\n            });\n          });\n        }, Object.defineProperty(t.prototype, \"started\", {\n          get: function get() {\n            return this._started;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.getMutationQueue = function (t) {\n          return nr(this.started, \"Cannot initialize MutationQueue before persistence is started.\"), Ys.forUser(t, this.serializer, this.referenceDelegate);\n        }, t.prototype.getQueryCache = function () {\n          return nr(this.started, \"Cannot initialize QueryCache before persistence is started.\"), this.queryCache;\n        }, t.prototype.getRemoteDocumentCache = function () {\n          return nr(this.started, \"Cannot initialize RemoteDocumentCache before persistence is started.\"), this.remoteDocumentCache;\n        }, t.prototype.runTransaction = function (t, e, n) {\n          var r = this;\n          return Zn(ha, \"Starting transaction:\", t), this.simpleDb.runTransaction(\"readonly\" === e ? \"readonly\" : \"readwrite\", Xs, function (i) {\n            return \"readwrite-primary\" === e ? r.verifyPrimaryLease(i).next(function (e) {\n              if (!e) throw $n(\"Failed to obtain primary lease for action '\" + t + \"'.\"), r.isPrimary = !1, r.queue.enqueueAndForget(function () {\n                return r.primaryStateListener(!1);\n              }), new sr(or.FAILED_PRECONDITION, la);\n              return n(new pa(i, r.listenSequence.next()));\n            }).next(function (t) {\n              return r.acquireOrExtendPrimaryLease(i).next(function () {\n                return t;\n              });\n            }) : r.verifyAllowTabSynchronization(i).next(function () {\n              return n(new pa(i, r.listenSequence.next()));\n            });\n          });\n        }, t.prototype.verifyAllowTabSynchronization = function (t) {\n          var e = this;\n          return ga(t).get(Ls.key).next(function (t) {\n            if (null !== t && e.isWithinAge(t.leaseTimestampMs, 5e3) && !e.isClientZombied(t.ownerId) && !e.isLocalClient(t) && !t.allowTabSynchronization) throw new sr(or.FAILED_PRECONDITION, fa);\n          });\n        }, t.prototype.acquireOrExtendPrimaryLease = function (t) {\n          var e = new Ls(this.clientId, this.allowTabSynchronization, Date.now());\n          return ga(t).put(Ls.key, e);\n        }, t.isAvailable = function () {\n          return fs.isAvailable();\n        }, t.buildStoragePrefix = function (t) {\n          var e = t.databaseId.projectId;\n          return t.databaseId.isDefaultDatabase || (e += \".\" + t.databaseId.database), \"firestore/\" + t.persistenceKey + \"/\" + e + \"/\";\n        }, t.prototype.releasePrimaryLeaseIfHeld = function (t) {\n          var e = this,\n              n = ga(t);\n          return n.get(Ls.key).next(function (t) {\n            return e.isLocalClient(t) ? (Zn(ha, \"Releasing primary lease.\"), n.delete(Ls.key)) : ls.resolve();\n          });\n        }, t.prototype.isWithinAge = function (t, e) {\n          var n = Date.now();\n          return !(t < n - e) && (!(t > n) || ($n(\"Detected an update time that is in the future: \" + t + \" > \" + n), !1));\n        }, t.prototype.attachVisibilityHandler = function () {\n          var t = this;\n          null !== this.document && \"function\" == typeof this.document.addEventListener && (this.documentVisibilityHandler = function () {\n            t.queue.enqueueAndForget(function () {\n              return t.inForeground = \"visible\" === t.document.visibilityState, t.updateClientMetadataAndTryBecomePrimary();\n            });\n          }, this.document.addEventListener(\"visibilitychange\", this.documentVisibilityHandler), this.inForeground = \"visible\" === this.document.visibilityState);\n        }, t.prototype.detachVisibilityHandler = function () {\n          this.documentVisibilityHandler && (nr(null !== this.document && \"function\" == typeof this.document.addEventListener, \"Expected 'document.addEventListener' to be a function\"), this.document.removeEventListener(\"visibilitychange\", this.documentVisibilityHandler), this.documentVisibilityHandler = null);\n        }, t.prototype.attachWindowUnloadHook = function () {\n          var t = this;\n          \"function\" == typeof this.window.addEventListener && (this.windowUnloadHandler = function () {\n            t.markClientZombied(), t.queue.enqueueAndForget(function () {\n              return t.shutdown();\n            });\n          }, this.window.addEventListener(\"unload\", this.windowUnloadHandler));\n        }, t.prototype.detachWindowUnloadHook = function () {\n          this.windowUnloadHandler && (nr(\"function\" == typeof this.window.removeEventListener, \"Expected 'window.removeEventListener' to be a function\"), this.window.removeEventListener(\"unload\", this.windowUnloadHandler), this.windowUnloadHandler = null);\n        }, t.prototype.isClientZombied = function (t) {\n          try {\n            var e = null !== this.webStorage.getItem(this.zombiedClientLocalStorageKey(t));\n            return Zn(ha, \"Client '\" + t + \"' \" + (e ? \"is\" : \"is not\") + \" zombied in LocalStorage\"), e;\n          } catch (t) {\n            return $n(ha, \"Failed to get zombied client id.\", t), !1;\n          }\n        }, t.prototype.markClientZombied = function () {\n          try {\n            this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId), String(Date.now()));\n          } catch (t) {\n            $n(\"Failed to set zombie client id.\", t);\n          }\n        }, t.prototype.removeClientZombiedEntry = function () {\n          try {\n            this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));\n          } catch (t) {}\n        }, t.prototype.zombiedClientLocalStorageKey = function (t) {\n          return \"firestore_zombie_\" + this.persistenceKey + \"_\" + t;\n        }, t.MAIN_DATABASE = \"main\", t;\n      }();\n\n      function ya(t) {\n        return a(this, void 0, void 0, function () {\n          return u(this, function (e) {\n            if (!function (t) {\n              return t.code === or.FAILED_PRECONDITION && t.message === la;\n            }(t)) throw t;\n            return Zn(ha, \"Unexpectedly lost primary lease\"), [2];\n          });\n        });\n      }\n\n      function ga(t) {\n        return t.store(Ls.store);\n      }\n\n      function va(t) {\n        return t.store(Hs.store);\n      }\n\n      var ba = function () {\n        function t(t, e) {\n          this.db = t, this.garbageCollector = new ca(this, e);\n        }\n\n        return t.prototype.getSequenceNumberCount = function (t) {\n          var e = this.orphanedDocmentCount(t);\n          return this.db.getQueryCache().getQueryCount(t).next(function (t) {\n            return e.next(function (e) {\n              return t + e;\n            });\n          });\n        }, t.prototype.orphanedDocmentCount = function (t) {\n          var e = 0;\n          return this.forEachOrphanedDocumentSequenceNumber(t, function (t) {\n            e++;\n          }).next(function () {\n            return e;\n          });\n        }, t.prototype.forEachTarget = function (t, e) {\n          return this.db.getQueryCache().forEachTarget(t, e);\n        }, t.prototype.forEachOrphanedDocumentSequenceNumber = function (t, e) {\n          return this.forEachOrphanedDocument(t, function (t, n) {\n            return e(n);\n          });\n        }, t.prototype.setInMemoryPins = function (t) {\n          this.inMemoryPins = t;\n        }, t.prototype.addReference = function (t, e) {\n          return wa(t, e);\n        }, t.prototype.removeReference = function (t, e) {\n          return wa(t, e);\n        }, t.prototype.removeTargets = function (t, e, n) {\n          return this.db.getQueryCache().removeTargets(t, e, n);\n        }, t.prototype.removeMutationReference = function (t, e) {\n          return wa(t, e);\n        }, t.prototype.isPinned = function (t, e) {\n          return this.inMemoryPins.containsKey(e) ? ls.resolve(!0) : function (t, e) {\n            var n = !1;\n            return na(t).iterateSerial(function (r) {\n              return Js(t, r, e).next(function (t) {\n                return t && (n = !0), ls.resolve(!t);\n              });\n            }).next(function () {\n              return n;\n            });\n          }(t, e);\n        }, t.prototype.removeOrphanedDocuments = function (t, e) {\n          var n = this,\n              r = 0,\n              i = 0,\n              o = [];\n          return this.forEachOrphanedDocument(t, function (s, a) {\n            if (a <= e) {\n              var u = n.isPinned(t, s).next(function (e) {\n                if (!e) return r++, n.removeOrphanedDocument(t, s).next(function (t) {\n                  i += t;\n                });\n              });\n              o.push(u);\n            }\n          }).next(function () {\n            return ls.waitFor(o);\n          }).next(function () {\n            return n.db.getRemoteDocumentCache().updateSize(t, -i);\n          }).next(function () {\n            return r;\n          });\n        }, t.prototype.removeOrphanedDocument = function (t, e) {\n          var n,\n              r = 0,\n              i = this.db.getRemoteDocumentCache();\n          return ls.waitFor([Es(t).delete((n = e, [0, ns(n.path)])), i.removeEntry(t, e).next(function (t) {\n            r += t;\n          })]).next(function () {\n            return r;\n          });\n        }, t.prototype.removeTarget = function (t, e) {\n          var n = e.copy({\n            sequenceNumber: t.currentSequenceNumber\n          });\n          return this.db.getQueryCache().updateQueryData(t, n);\n        }, t.prototype.updateLimboDocument = function (t, e) {\n          return wa(t, e);\n        }, t.prototype.forEachOrphanedDocument = function (t, e) {\n          var n,\n              r = Es(t),\n              i = Ho.INVALID;\n          return r.iterate({\n            index: Ws.documentTargetsIndex\n          }, function (t, r) {\n            var o = t[0],\n                s = (t[1], r.path),\n                a = r.sequenceNumber;\n            0 === o ? (i !== Ho.INVALID && e(new Hr(os(n)), i), i = a, n = s) : i = Ho.INVALID;\n          }).next(function () {\n            i !== Ho.INVALID && e(new Hr(os(n)), i);\n          });\n        }, t.prototype.getCacheSize = function (t) {\n          return this.db.getRemoteDocumentCache().getSize(t);\n        }, t;\n      }();\n\n      function wa(t, e) {\n        return Es(t).put(function (t, e) {\n          return new Ws(0, ns(t.path), e);\n        }(e, t.currentSequenceNumber));\n      }\n\n      var Ea = function () {\n        function t(t, e) {\n          this.remoteDocumentCache = t, this.mutationQueue = e;\n        }\n\n        return t.prototype.getDocument = function (t, e) {\n          var n = this;\n          return this.mutationQueue.getAllMutationBatchesAffectingDocumentKey(t, e).next(function (r) {\n            return n.getDocumentInternal(t, e, r);\n          });\n        }, t.prototype.getDocumentInternal = function (t, e, n) {\n          return this.remoteDocumentCache.getEntry(t, e).next(function (t) {\n            for (var r = 0, i = n; r < i.length; r++) {\n              t = i[r].applyToLocalView(e, t);\n            }\n\n            return t;\n          });\n        }, t.prototype.applyLocalMutationsToDocuments = function (t, e, n) {\n          var r = ao();\n          return e.forEach(function (t, e) {\n            for (var i = 0, o = n; i < o.length; i++) {\n              e = o[i].applyToLocalView(t, e);\n            }\n\n            r = r.insert(t, e);\n          }), r;\n        }, t.prototype.getDocuments = function (t, e) {\n          var n = this;\n          return this.remoteDocumentCache.getEntries(t, e).next(function (e) {\n            return n.getLocalViewOfDocuments(t, e);\n          });\n        }, t.prototype.getLocalViewOfDocuments = function (t, e) {\n          var n = this;\n          return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(t, e).next(function (r) {\n            var i = n.applyLocalMutationsToDocuments(t, e, r),\n                o = so();\n            return i.forEach(function (t, e) {\n              e || (e = new Jr(t, qi.forDeletedDoc())), o = o.insert(t, e);\n            }), o;\n          });\n        }, t.prototype.getDocumentsMatchingQuery = function (t, e) {\n          return Hr.isDocumentKey(e.path) ? this.getDocumentsMatchingDocumentQuery(t, e.path) : this.getDocumentsMatchingCollectionQuery(t, e);\n        }, t.prototype.getDocumentsMatchingDocumentQuery = function (t, e) {\n          return this.getDocument(t, new Hr(e)).next(function (t) {\n            var e = co();\n            return t instanceof Yr && (e = e.insert(t.key, t)), e;\n          });\n        }, t.prototype.getDocumentsMatchingCollectionQuery = function (t, e) {\n          var n,\n              r = this;\n          return this.remoteDocumentCache.getDocumentsMatchingQuery(t, e).next(function (i) {\n            return n = i, r.mutationQueue.getAllMutationBatchesAffectingQuery(t, e);\n          }).next(function (t) {\n            for (var r = 0, i = t; r < i.length; r++) {\n              for (var o = i[r], s = 0, a = o.mutations; s < a.length; s++) {\n                var u = a[s],\n                    c = u.key;\n\n                if (e.path.isImmediateParentOf(c.path)) {\n                  var h = n.get(c),\n                      l = u.applyToLocalView(h, h, o.localWriteTime);\n                  n = l instanceof Yr ? n.insert(c, l) : n.remove(c);\n                }\n              }\n            }\n          }).next(function () {\n            return n.forEach(function (t, r) {\n              e.matches(r) || (n = n.remove(t));\n            }), n;\n          });\n        }, t;\n      }(),\n          Sa = function () {\n        function t() {\n          this.refsByKey = new Ui(Ta.compareByKey), this.refsByTarget = new Ui(Ta.compareByTargetId);\n        }\n\n        return t.prototype.isEmpty = function () {\n          return this.refsByKey.isEmpty();\n        }, t.prototype.addReference = function (t, e) {\n          var n = new Ta(t, e);\n          this.refsByKey = this.refsByKey.add(n), this.refsByTarget = this.refsByTarget.add(n);\n        }, t.prototype.addReferences = function (t, e) {\n          var n = this;\n          t.forEach(function (t) {\n            return n.addReference(t, e);\n          });\n        }, t.prototype.removeReference = function (t, e) {\n          this.removeRef(new Ta(t, e));\n        }, t.prototype.removeReferences = function (t, e) {\n          var n = this;\n          t.forEach(function (t) {\n            return n.removeReference(t, e);\n          });\n        }, t.prototype.removeReferencesForId = function (t) {\n          var e = this,\n              n = Hr.EMPTY,\n              r = new Ta(n, t),\n              i = new Ta(n, t + 1),\n              o = [];\n          return this.refsByTarget.forEachInRange([r, i], function (t) {\n            e.removeRef(t), o.push(t.key);\n          }), o;\n        }, t.prototype.removeAllReferences = function () {\n          var t = this;\n          this.refsByKey.forEach(function (e) {\n            return t.removeRef(e);\n          });\n        }, t.prototype.removeRef = function (t) {\n          this.refsByKey = this.refsByKey.delete(t), this.refsByTarget = this.refsByTarget.delete(t);\n        }, t.prototype.referencesForId = function (t) {\n          var e = Hr.EMPTY,\n              n = new Ta(e, t),\n              r = new Ta(e, t + 1),\n              i = po();\n          return this.refsByTarget.forEachInRange([n, r], function (t) {\n            i = i.add(t.key);\n          }), i;\n        }, t.prototype.containsKey = function (t) {\n          var e = new Ta(t, 0),\n              n = this.refsByKey.firstAfterOrEqual(e);\n          return null !== n && t.isEqual(n.key);\n        }, t;\n      }(),\n          Ta = function () {\n        function t(t, e) {\n          this.key = t, this.targetOrBatchId = e;\n        }\n\n        return t.compareByKey = function (t, e) {\n          return Hr.comparator(t.key, e.key) || Mr(t.targetOrBatchId, e.targetOrBatchId);\n        }, t.compareByTargetId = function (t, e) {\n          return Mr(t.targetOrBatchId, e.targetOrBatchId) || Hr.comparator(t.key, e.key);\n        }, t;\n      }(),\n          Ia = function () {\n        function t(t, e) {\n          this.persistence = t, this.localViewReferences = new Sa(), this.queryDataByTarget = {}, nr(t.started, \"LocalStore was passed an unstarted persistence implementation\"), this.persistence.referenceDelegate.setInMemoryPins(this.localViewReferences), this.mutationQueue = t.getMutationQueue(e), this.remoteDocuments = t.getRemoteDocumentCache(), this.queryCache = t.getQueryCache(), this.localDocuments = new Ea(this.remoteDocuments, this.mutationQueue);\n        }\n\n        return t.prototype.handleUserChange = function (t) {\n          var e = this;\n          return this.persistence.runTransaction(\"Handle user change\", \"readonly\", function (n) {\n            var r;\n            return e.mutationQueue.getAllMutationBatches(n).next(function (i) {\n              return r = i, e.mutationQueue = e.persistence.getMutationQueue(t), e.localDocuments = new Ea(e.remoteDocuments, e.mutationQueue), e.mutationQueue.getAllMutationBatches(n);\n            }).next(function (t) {\n              for (var i = [], o = [], s = po(), a = 0, u = r; a < u.length; a++) {\n                var c = u[a];\n                i.push(c.batchId);\n\n                for (var h = 0, l = c.mutations; h < l.length; h++) {\n                  var f = l[h];\n                  s = s.add(f.key);\n                }\n              }\n\n              for (var d = 0, p = t; d < p.length; d++) {\n                c = p[d];\n                o.push(c.batchId);\n\n                for (var m = 0, y = c.mutations; m < y.length; m++) {\n                  f = y[m];\n                  s = s.add(f.key);\n                }\n              }\n\n              return e.localDocuments.getDocuments(n, s).next(function (t) {\n                return {\n                  affectedDocuments: t,\n                  removedBatchIds: i,\n                  addedBatchIds: o\n                };\n              });\n            });\n          });\n        }, t.prototype.localWrite = function (t) {\n          var e = this;\n          return this.persistence.runTransaction(\"Locally write mutations\", \"readwrite\", function (n) {\n            var r,\n                i = Ur.now();\n            return e.mutationQueue.addMutationBatch(n, i, t).next(function (t) {\n              var i = (r = t).keys();\n              return e.localDocuments.getDocuments(n, i);\n            }).next(function (t) {\n              return {\n                batchId: r.batchId,\n                changes: t\n              };\n            });\n          });\n        }, t.prototype.lookupMutationDocuments = function (t) {\n          var e = this;\n          return this.persistence.runTransaction(\"Lookup mutation documents\", \"readonly\", function (n) {\n            return e.mutationQueue.lookupMutationKeys(n, t).next(function (t) {\n              return t ? e.localDocuments.getDocuments(n, t) : ls.resolve(null);\n            });\n          });\n        }, t.prototype.acknowledgeBatch = function (t) {\n          var e = this;\n          return this.persistence.runTransaction(\"Acknowledge batch\", \"readwrite-primary\", function (n) {\n            var r = t.batch.keys(),\n                i = e.remoteDocuments.newChangeBuffer();\n            return e.mutationQueue.acknowledgeBatch(n, t.batch, t.streamToken).next(function () {\n              return e.applyWriteToRemoteDocuments(n, t, i);\n            }).next(function () {\n              return i.apply(n);\n            }).next(function () {\n              return e.mutationQueue.performConsistencyCheck(n);\n            }).next(function () {\n              return e.localDocuments.getDocuments(n, r);\n            });\n          });\n        }, t.prototype.rejectBatch = function (t) {\n          var e = this;\n          return this.persistence.runTransaction(\"Reject batch\", \"readwrite-primary\", function (n) {\n            var r;\n            return e.mutationQueue.lookupMutationBatch(n, t).next(function (t) {\n              return nr(null !== t, \"Attempt to reject nonexistent batch!\"), r = t.keys(), e.mutationQueue.removeMutationBatch(n, t);\n            }).next(function () {\n              return e.mutationQueue.performConsistencyCheck(n);\n            }).next(function () {\n              return e.localDocuments.getDocuments(n, r);\n            });\n          });\n        }, t.prototype.getLastStreamToken = function () {\n          var t = this;\n          return this.persistence.runTransaction(\"Get last stream token\", \"readonly\", function (e) {\n            return t.mutationQueue.getLastStreamToken(e);\n          });\n        }, t.prototype.setLastStreamToken = function (t) {\n          var e = this;\n          return this.persistence.runTransaction(\"Set last stream token\", \"readwrite-primary\", function (n) {\n            return e.mutationQueue.setLastStreamToken(n, t);\n          });\n        }, t.prototype.getLastRemoteSnapshotVersion = function () {\n          var t = this;\n          return this.persistence.runTransaction(\"Get last remote snapshot version\", \"readonly\", function (e) {\n            return t.queryCache.getLastRemoteSnapshotVersion(e);\n          });\n        }, t.prototype.applyRemoteEvent = function (e) {\n          var n = this,\n              r = this.remoteDocuments.newChangeBuffer();\n          return this.persistence.runTransaction(\"Apply remote event\", \"readwrite-primary\", function (i) {\n            var o = [],\n                s = po();\n            hr(e.targetChanges, function (r, a) {\n              var u = n.queryDataByTarget[r];\n\n              if (u) {\n                a.addedDocuments.forEach(function (t) {\n                  s = s.add(t);\n                }), a.modifiedDocuments.forEach(function (t) {\n                  s = s.add(t);\n                }), o.push(n.queryCache.removeMatchingKeys(i, a.removedDocuments, r).next(function () {\n                  return n.queryCache.addMatchingKeys(i, a.addedDocuments, r);\n                }));\n                var c = a.resumeToken;\n\n                if (c.length > 0) {\n                  var h = u;\n                  u = u.copy({\n                    resumeToken: c,\n                    snapshotVersion: e.snapshotVersion\n                  }), n.queryDataByTarget[r] = u, t.shouldPersistQueryData(h, u, a) && o.push(n.queryCache.updateQueryData(i, u));\n                }\n              }\n            });\n            var a = so(),\n                u = po();\n            e.documentUpdates.forEach(function (t, e) {\n              u = u.add(t);\n            }), o.push(r.getEntries(i, u).next(function (t) {\n              e.documentUpdates.forEach(function (u, c) {\n                var h = t.get(u);\n                null == h || c.version.isEqual(qi.MIN) || s.has(c.key) && !h.hasPendingWrites || c.version.compareTo(h.version) >= 0 ? (r.addEntry(c), a = a.insert(u, c)) : Zn(\"LocalStore\", \"Ignoring outdated watch update for \", u, \". Current version:\", h.version, \" Watch version:\", c.version), e.resolvedLimboDocuments.has(u) && o.push(n.persistence.referenceDelegate.updateLimboDocument(i, u));\n              });\n            }));\n            var c = e.snapshotVersion;\n\n            if (!c.isEqual(qi.MIN)) {\n              var h = n.queryCache.getLastRemoteSnapshotVersion(i).next(function (t) {\n                return nr(c.compareTo(t) >= 0, \"Watch stream reverted to previous snapshot?? \" + c + \" < \" + t), n.queryCache.setTargetsMetadata(i, i.currentSequenceNumber, c);\n              });\n              o.push(h);\n            }\n\n            return ls.waitFor(o).next(function () {\n              return r.apply(i);\n            }).next(function () {\n              return n.localDocuments.getLocalViewOfDocuments(i, a);\n            });\n          });\n        }, t.shouldPersistQueryData = function (t, e, n) {\n          return 0 !== e.resumeToken.length && (0 === t.resumeToken.length || e.snapshotVersion.toMicroseconds() - t.snapshotVersion.toMicroseconds() >= this.RESUME_TOKEN_MAX_AGE_MICROS || n.addedDocuments.size + n.modifiedDocuments.size + n.removedDocuments.size > 0);\n        }, t.prototype.notifyLocalViewChanges = function (t) {\n          var e = this;\n          return this.persistence.runTransaction(\"notifyLocalViewChanges\", \"readwrite\", function (n) {\n            return ls.forEach(t, function (t) {\n              return e.localViewReferences.addReferences(t.addedKeys, t.targetId), e.localViewReferences.removeReferences(t.removedKeys, t.targetId), ls.forEach(t.removedKeys, function (t) {\n                return e.persistence.referenceDelegate.removeReference(n, t);\n              });\n            });\n          });\n        }, t.prototype.nextMutationBatch = function (t) {\n          var e = this;\n          return this.persistence.runTransaction(\"Get next mutation batch\", \"readonly\", function (n) {\n            return void 0 === t && (t = -1), e.mutationQueue.getNextMutationBatchAfterBatchId(n, t);\n          });\n        }, t.prototype.readDocument = function (t) {\n          var e = this;\n          return this.persistence.runTransaction(\"read document\", \"readonly\", function (n) {\n            return e.localDocuments.getDocument(n, t);\n          });\n        }, t.prototype.allocateQuery = function (t) {\n          var e = this;\n          return this.persistence.runTransaction(\"Allocate query\", \"readwrite\", function (n) {\n            var r;\n            return e.queryCache.getQueryData(n, t).next(function (i) {\n              return i ? (r = i, ls.resolve()) : e.queryCache.allocateTargetId(n).next(function (i) {\n                return r = new Bi(t, i, Ci.Listen, n.currentSequenceNumber), e.queryCache.addQueryData(n, r);\n              });\n            }).next(function () {\n              return nr(!e.queryDataByTarget[r.targetId], \"Tried to allocate an already allocated query: \" + t), e.queryDataByTarget[r.targetId] = r, r;\n            });\n          });\n        }, t.prototype.releaseQuery = function (t, e) {\n          var n = this,\n              r = e ? \"readwrite\" : \"readwrite-primary\";\n          return this.persistence.runTransaction(\"Release query\", r, function (r) {\n            return n.queryCache.getQueryData(r, t).next(function (i) {\n              nr(null != i, \"Tried to release nonexistent query: \" + t);\n              var o = i.targetId,\n                  s = n.queryDataByTarget[o],\n                  a = n.localViewReferences.removeReferencesForId(o);\n              return delete n.queryDataByTarget[o], e ? ls.resolve() : ls.forEach(a, function (t) {\n                return n.persistence.referenceDelegate.removeReference(r, t);\n              }).next(function () {\n                return n.persistence.referenceDelegate.removeTarget(r, s);\n              });\n            });\n          });\n        }, t.prototype.executeQuery = function (t) {\n          var e = this;\n          return this.persistence.runTransaction(\"Execute query\", \"readonly\", function (n) {\n            return e.localDocuments.getDocumentsMatchingQuery(n, t);\n          });\n        }, t.prototype.remoteDocumentKeys = function (t) {\n          var e = this;\n          return this.persistence.runTransaction(\"Remote document keys\", \"readonly\", function (n) {\n            return e.queryCache.getMatchingKeysForTargetId(n, t);\n          });\n        }, t.prototype.getActiveClients = function () {\n          return this.persistence.getActiveClients();\n        }, t.prototype.removeCachedMutationBatchMetadata = function (t) {\n          this.mutationQueue.removeCachedMutationKeys(t);\n        }, t.prototype.setNetworkEnabled = function (t) {\n          this.persistence.setNetworkEnabled(t);\n        }, t.prototype.applyWriteToRemoteDocuments = function (t, e, n) {\n          var r = this,\n              i = e.batch,\n              o = i.keys(),\n              s = ls.resolve();\n          return o.forEach(function (r) {\n            s = s.next(function () {\n              return n.getEntry(t, r);\n            }).next(function (t) {\n              var o = t,\n                  s = e.docVersions.get(r);\n              nr(null !== s, \"ackVersions should contain every doc in the write.\"), (!o || o.version.compareTo(s) < 0) && ((o = i.applyToRemoteDocument(r, o, e)) ? n.addEntry(o) : nr(!t, \"Mutation batch \" + i + \" applied to document \" + t + \" resulted in null\"));\n            });\n          }), s.next(function () {\n            return r.mutationQueue.removeMutationBatch(t, i);\n          });\n        }, t.prototype.collectGarbage = function (t) {\n          var e = this;\n          return this.persistence.runTransaction(\"Collect garbage\", \"readwrite-primary\", function (n) {\n            return t.collect(n, e.queryDataByTarget);\n          });\n        }, t.prototype.getQueryForTarget = function (t) {\n          var e = this;\n          return this.queryDataByTarget[t] ? Promise.resolve(this.queryDataByTarget[t].query) : this.persistence.runTransaction(\"Get query data\", \"readonly\", function (n) {\n            return e.queryCache.getQueryDataForTarget(n, t).next(function (t) {\n              return t ? t.query : null;\n            });\n          });\n        }, t.prototype.getNewDocumentChanges = function () {\n          var t = this;\n          return this.persistence.runTransaction(\"Get new document changes\", \"readonly\", function (e) {\n            return t.remoteDocuments.getNewDocumentChanges(e);\n          });\n        }, t.RESUME_TOKEN_MAX_AGE_MICROS = 3e8, t;\n      }(),\n          Ca = function () {\n        function t(t) {\n          this.referenceDelegate = t, this.mutationQueue = [], this.nextBatchId = 1, this.lastStreamToken = ir(), this.batchesByDocumentKey = new Ui(Ta.compareByKey);\n        }\n\n        return t.prototype.checkEmpty = function (t) {\n          return ls.resolve(0 === this.mutationQueue.length);\n        }, t.prototype.acknowledgeBatch = function (t, e, n) {\n          var r = e.batchId,\n              i = this.indexOfExistingBatchId(r, \"acknowledged\");\n          nr(0 === i, \"Can only acknowledge the first batch in the mutation queue\");\n          var o = this.mutationQueue[i];\n          return nr(r === o.batchId, \"Queue ordering failure: expected batch \" + r + \", got batch \" + o.batchId), this.lastStreamToken = n, ls.resolve();\n        }, t.prototype.getLastStreamToken = function (t) {\n          return ls.resolve(this.lastStreamToken);\n        }, t.prototype.setLastStreamToken = function (t, e) {\n          return this.lastStreamToken = e, ls.resolve();\n        }, t.prototype.addMutationBatch = function (t, e, n) {\n          nr(0 !== n.length, \"Mutation batches should not be empty\");\n          var r = this.nextBatchId;\n          (this.nextBatchId++, this.mutationQueue.length > 0) && nr(this.mutationQueue[this.mutationQueue.length - 1].batchId < r, \"Mutation batchIDs must be monotonically increasing order\");\n          var i = new as(r, e, n);\n          this.mutationQueue.push(i);\n\n          for (var o = 0, s = n; o < s.length; o++) {\n            var a = s[o];\n            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new Ta(a.key, r));\n          }\n\n          return ls.resolve(i);\n        }, t.prototype.lookupMutationBatch = function (t, e) {\n          return ls.resolve(this.findMutationBatch(e));\n        }, t.prototype.lookupMutationKeys = function (t, e) {\n          var n = this.findMutationBatch(e);\n          return nr(null != n, \"Failed to find local mutation batch.\"), ls.resolve(n.keys());\n        }, t.prototype.getNextMutationBatchAfterBatchId = function (t, e) {\n          var n = e + 1,\n              r = this.indexOfBatchId(n),\n              i = r < 0 ? 0 : r;\n          return ls.resolve(this.mutationQueue.length > i ? this.mutationQueue[i] : null);\n        }, t.prototype.getAllMutationBatches = function (t) {\n          return ls.resolve(this.mutationQueue.slice());\n        }, t.prototype.getAllMutationBatchesAffectingDocumentKey = function (t, e) {\n          var n = this,\n              r = new Ta(e, 0),\n              i = new Ta(e, Number.POSITIVE_INFINITY),\n              o = [];\n          return this.batchesByDocumentKey.forEachInRange([r, i], function (t) {\n            nr(e.isEqual(t.key), \"Should only iterate over a single key's batches\");\n            var r = n.findMutationBatch(t.targetOrBatchId);\n            nr(null !== r, \"Batches in the index must exist in the main table\"), o.push(r);\n          }), ls.resolve(o);\n        }, t.prototype.getAllMutationBatchesAffectingDocumentKeys = function (t, e) {\n          var n = this,\n              r = new Ui(Mr);\n          return e.forEach(function (t) {\n            var e = new Ta(t, 0),\n                i = new Ta(t, Number.POSITIVE_INFINITY);\n            n.batchesByDocumentKey.forEachInRange([e, i], function (e) {\n              nr(t.isEqual(e.key), \"For each key, should only iterate over a single key's batches\"), r = r.add(e.targetOrBatchId);\n            });\n          }), ls.resolve(this.findMutationBatches(r));\n        }, t.prototype.getAllMutationBatchesAffectingQuery = function (t, e) {\n          var n = e.path,\n              r = n.length + 1,\n              i = n;\n          Hr.isDocumentKey(i) || (i = i.child(\"\"));\n          var o = new Ta(new Hr(i), 0),\n              s = new Ui(Mr);\n          return this.batchesByDocumentKey.forEachWhile(function (t) {\n            var e = t.key.path;\n            return !!n.isPrefixOf(e) && (e.length === r && (s = s.add(t.targetOrBatchId)), !0);\n          }, o), ls.resolve(this.findMutationBatches(s));\n        }, t.prototype.findMutationBatches = function (t) {\n          var e = this,\n              n = [];\n          return t.forEach(function (t) {\n            var r = e.findMutationBatch(t);\n            null !== r && n.push(r);\n          }), n;\n        }, t.prototype.removeMutationBatch = function (t, e) {\n          var n = this;\n          nr(0 === this.indexOfExistingBatchId(e.batchId, \"removed\"), \"Can only remove the first entry of the mutation queue\"), this.mutationQueue.shift();\n          var r = this.batchesByDocumentKey;\n          return ls.forEach(e.mutations, function (i) {\n            var o = new Ta(i.key, e.batchId);\n            return r = r.delete(o), n.referenceDelegate.removeMutationReference(t, i.key);\n          }).next(function () {\n            n.batchesByDocumentKey = r;\n          });\n        }, t.prototype.removeCachedMutationKeys = function (t) {}, t.prototype.containsKey = function (t, e) {\n          var n = new Ta(e, 0),\n              r = this.batchesByDocumentKey.firstAfterOrEqual(n);\n          return ls.resolve(e.isEqual(r && r.key));\n        }, t.prototype.performConsistencyCheck = function (t) {\n          return 0 === this.mutationQueue.length && nr(this.batchesByDocumentKey.isEmpty(), \"Document leak -- detected dangling mutation references when queue is empty.\"), ls.resolve();\n        }, t.prototype.indexOfExistingBatchId = function (t, e) {\n          var n = this.indexOfBatchId(t);\n          return nr(n >= 0 && n < this.mutationQueue.length, \"Batches must exist to be \" + e), n;\n        }, t.prototype.indexOfBatchId = function (t) {\n          return 0 === this.mutationQueue.length ? 0 : t - this.mutationQueue[0].batchId;\n        }, t.prototype.findMutationBatch = function (t) {\n          var e = this.indexOfBatchId(t);\n          if (e < 0 || e >= this.mutationQueue.length) return null;\n          var n = this.mutationQueue[e];\n          return nr(n.batchId === t, \"If found batch must match\"), n;\n        }, t;\n      }(),\n          Da = function () {\n        function t(t) {\n          this.persistence = t, this.queries = new Ss(function (t) {\n            return t.canonicalId();\n          }), this.lastRemoteSnapshotVersion = qi.MIN, this.highestTargetId = 0, this.highestSequenceNumber = 0, this.references = new Sa(), this.targetCount = 0, this.targetIdGenerator = hs.forQueryCache();\n        }\n\n        return t.prototype.getTargetCount = function (t) {\n          return ls.resolve(this.targetCount);\n        }, t.prototype.forEachTarget = function (t, e) {\n          return this.queries.forEach(function (t, n) {\n            return e(n);\n          }), ls.resolve();\n        }, t.prototype.getLastRemoteSnapshotVersion = function (t) {\n          return ls.resolve(this.lastRemoteSnapshotVersion);\n        }, t.prototype.getHighestSequenceNumber = function (t) {\n          return ls.resolve(this.highestSequenceNumber);\n        }, t.prototype.allocateTargetId = function (t) {\n          var e = this.targetIdGenerator.after(this.highestTargetId);\n          return this.highestTargetId = e, ls.resolve(e);\n        }, t.prototype.setTargetsMetadata = function (t, e, n) {\n          return n && (this.lastRemoteSnapshotVersion = n), e > this.highestSequenceNumber && (this.highestSequenceNumber = e), ls.resolve();\n        }, t.prototype.saveQueryData = function (t) {\n          this.queries.set(t.query, t);\n          var e = t.targetId;\n          e > this.highestTargetId && (this.highestTargetId = e), t.sequenceNumber > this.highestSequenceNumber && (this.highestSequenceNumber = t.sequenceNumber);\n        }, t.prototype.addQueryData = function (t, e) {\n          return nr(!this.queries.has(e.query), \"Adding a query that already exists\"), this.saveQueryData(e), this.targetCount += 1, ls.resolve();\n        }, t.prototype.updateQueryData = function (t, e) {\n          return nr(this.queries.has(e.query), \"Updating a non-existent query\"), this.saveQueryData(e), ls.resolve();\n        }, t.prototype.removeQueryData = function (t, e) {\n          return nr(this.targetCount > 0, \"Removing a target from an empty cache\"), nr(this.queries.has(e.query), \"Removing a non-existent target from the cache\"), this.queries.delete(e.query), this.references.removeReferencesForId(e.targetId), this.targetCount -= 1, ls.resolve();\n        }, t.prototype.removeTargets = function (t, e, n) {\n          var r = this,\n              i = 0,\n              o = [];\n          return this.queries.forEach(function (s, a) {\n            a.sequenceNumber <= e && !n[a.targetId] && (r.queries.delete(s), o.push(r.removeMatchingKeysForTargetId(t, a.targetId)), i++);\n          }), ls.waitFor(o).next(function () {\n            return i;\n          });\n        }, t.prototype.getQueryCount = function (t) {\n          return ls.resolve(this.targetCount);\n        }, t.prototype.getQueryData = function (t, e) {\n          var n = this.queries.get(e) || null;\n          return ls.resolve(n);\n        }, t.prototype.getQueryDataForTarget = function (t, e) {\n          return er(\"Not yet implemented.\");\n        }, t.prototype.addMatchingKeys = function (t, e, n) {\n          this.references.addReferences(e, n);\n          var r = this.persistence.referenceDelegate,\n              i = [];\n          return r && e.forEach(function (e) {\n            i.push(r.addReference(t, e));\n          }), ls.waitFor(i);\n        }, t.prototype.removeMatchingKeys = function (t, e, n) {\n          this.references.removeReferences(e, n);\n          var r = this.persistence.referenceDelegate,\n              i = [];\n          return r && e.forEach(function (e) {\n            i.push(r.removeReference(t, e));\n          }), ls.waitFor(i);\n        }, t.prototype.removeMatchingKeysForTargetId = function (t, e) {\n          return this.references.removeReferencesForId(e), ls.resolve();\n        }, t.prototype.getMatchingKeysForTargetId = function (t, e) {\n          var n = this.references.referencesForId(e);\n          return ls.resolve(n);\n        }, t.prototype.containsKey = function (t, e) {\n          return ls.resolve(this.references.containsKey(e));\n        }, t;\n      }();\n\n      var Na,\n          Aa = function () {\n        function t(t) {\n          this.sizer = t, this.docs = new $r(Hr.comparator), this.newDocumentChanges = po(), this.size = 0;\n        }\n\n        return t.prototype.addEntries = function (t, e, n) {\n          for (var r = 0, i = e; r < i.length; r++) {\n            var o = i[r],\n                s = o.maybeDocument.key;\n            this.docs = this.docs.insert(s, o), this.newDocumentChanges = this.newDocumentChanges.add(s);\n          }\n\n          return this.size += n, ls.resolve();\n        }, t.prototype.removeEntry = function (t, e) {\n          var n = this.docs.get(e);\n          return n ? (this.docs = this.docs.remove(e), this.size -= n.size, ls.resolve(n.size)) : ls.resolve(0);\n        }, t.prototype.getEntry = function (t, e) {\n          var n = this.docs.get(e);\n          return ls.resolve(n ? n.maybeDocument : null);\n        }, t.prototype.getSizedEntry = function (t, e) {\n          return ls.resolve(this.docs.get(e));\n        }, t.prototype.getEntries = function (t, e) {\n          var n = this,\n              r = ao();\n          return e.forEach(function (t) {\n            var e = n.docs.get(t);\n            r = r.insert(t, e ? e.maybeDocument : null);\n          }), ls.resolve(r);\n        }, t.prototype.getSizedEntries = function (t, e) {\n          var n = this,\n              r = ao(),\n              i = new $r(Hr.comparator);\n          return e.forEach(function (t) {\n            var e = n.docs.get(t);\n            r = r.insert(t, e ? e.maybeDocument : null), i = i.insert(t, e ? e.size : 0);\n          }), ls.resolve({\n            maybeDocuments: r,\n            sizeMap: i\n          });\n        }, t.prototype.getDocumentsMatchingQuery = function (t, e) {\n          for (var n = co(), r = new Hr(e.path.child(\"\")), i = this.docs.getIteratorFrom(r); i.hasNext();) {\n            var o = i.getNext(),\n                s = o.key,\n                a = o.value.maybeDocument;\n            if (!e.path.isPrefixOf(s.path)) break;\n            a instanceof Yr && e.matches(a) && (n = n.insert(a.key, a));\n          }\n\n          return ls.resolve(n);\n        }, t.prototype.forEachDocumentKey = function (t, e) {\n          return ls.forEach(this.docs, function (t) {\n            return e(t);\n          });\n        }, t.prototype.getNewDocumentChanges = function (t) {\n          var e = this,\n              n = so();\n          return this.newDocumentChanges.forEach(function (t) {\n            var r = e.docs.get(t),\n                i = r ? r.maybeDocument : new Jr(t, qi.forDeletedDoc());\n            n = n.insert(t, i);\n          }), this.newDocumentChanges = po(), ls.resolve(n);\n        }, t.prototype.newChangeBuffer = function () {\n          return new ka(this.sizer, this);\n        }, t.prototype.getSize = function (t) {\n          return ls.resolve(this.size);\n        }, t;\n      }(),\n          ka = function (t) {\n        function e(e, n) {\n          var r = t.call(this) || this;\n          return r.sizer = e, r.documentCache = n, r;\n        }\n\n        return s(e, t), e.prototype.applyChanges = function (t) {\n          var e = this,\n              n = 0,\n              r = [];\n          return this.assertChanges().forEach(function (t, i) {\n            var o = e.documentSizes.get(t);\n            nr(void 0 !== o, \"Attempting to change document \" + t.toString() + \" without having read it first\");\n            var s = e.sizer(i);\n            n += s - o, r.push({\n              maybeDocument: i,\n              size: s\n            });\n          }), this.documentCache.addEntries(t, r, n);\n        }, e.prototype.getFromCache = function (t, e) {\n          return this.documentCache.getSizedEntry(t, e);\n        }, e.prototype.getAllFromCache = function (t, e) {\n          return this.documentCache.getSizedEntries(t, e);\n        }, e;\n      }(Ts),\n          Ra = function () {\n        function t(t, e) {\n          var n = this;\n          this.clientId = t, this.mutationQueues = {}, this.listenSequence = new Ho(0), this._started = !1, this._started = !0, this.referenceDelegate = e(this), this.queryCache = new Da(this);\n          this.remoteDocumentCache = new Aa(function (t) {\n            return n.referenceDelegate.documentSize(t);\n          });\n        }\n\n        return t.createLruPersistence = function (e, n, r) {\n          return new t(e, function (t) {\n            return new _a(t, new ra(n), r);\n          });\n        }, t.createEagerPersistence = function (e) {\n          return new t(e, function (t) {\n            return new Oa(t);\n          });\n        }, t.prototype.shutdown = function (t) {\n          return this._started = !1, Promise.resolve();\n        }, Object.defineProperty(t.prototype, \"started\", {\n          get: function get() {\n            return this._started;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.getActiveClients = function () {\n          return a(this, void 0, void 0, function () {\n            return u(this, function (t) {\n              return [2, [this.clientId]];\n            });\n          });\n        }, t.prototype.setPrimaryStateListener = function (t) {\n          return t(!0);\n        }, t.prototype.setNetworkEnabled = function (t) {}, t.prototype.getMutationQueue = function (t) {\n          var e = this.mutationQueues[t.toKey()];\n          return e || (e = new Ca(this.referenceDelegate), this.mutationQueues[t.toKey()] = e), e;\n        }, t.prototype.getQueryCache = function () {\n          return this.queryCache;\n        }, t.prototype.getRemoteDocumentCache = function () {\n          return this.remoteDocumentCache;\n        }, t.prototype.runTransaction = function (t, e, n) {\n          var r = this;\n          Zn(\"MemoryPersistence\", \"Starting transaction:\", t);\n          var i = new Ma(this.listenSequence.next());\n          return this.referenceDelegate.onTransactionStarted(), n(i).next(function (t) {\n            return r.referenceDelegate.onTransactionCommitted(i).next(function () {\n              return t;\n            });\n          }).toPromise();\n        }, t.prototype.mutationQueuesContainKey = function (t, e) {\n          return ls.or((n = this.mutationQueues, r = [], lr(n, function (t, e) {\n            return r.push(e);\n          }), r).map(function (n) {\n            return function () {\n              return n.containsKey(t, e);\n            };\n          }));\n          var n, r;\n        }, t;\n      }(),\n          Ma = function () {\n        return function (t) {\n          this.currentSequenceNumber = t;\n        };\n      }(),\n          Oa = function () {\n        function t(t) {\n          this.persistence = t;\n        }\n\n        return t.prototype.setInMemoryPins = function (t) {\n          this.inMemoryPins = t;\n        }, t.prototype.addReference = function (t, e) {\n          return this.orphanedDocuments.delete(e), ls.resolve();\n        }, t.prototype.removeReference = function (t, e) {\n          return this.orphanedDocuments.add(e), ls.resolve();\n        }, t.prototype.removeMutationReference = function (t, e) {\n          return this.orphanedDocuments.add(e), ls.resolve();\n        }, t.prototype.removeTarget = function (t, e) {\n          var n = this,\n              r = this.persistence.getQueryCache();\n          return r.getMatchingKeysForTargetId(t, e.targetId).next(function (t) {\n            t.forEach(function (t) {\n              return n.orphanedDocuments.add(t);\n            });\n          }).next(function () {\n            return r.removeQueryData(t, e);\n          });\n        }, t.prototype.onTransactionStarted = function () {\n          this.orphanedDocuments = new Set();\n        }, t.prototype.onTransactionCommitted = function (t) {\n          var e = this,\n              n = this.persistence.getRemoteDocumentCache();\n          return ls.forEach(this.orphanedDocuments, function (r) {\n            return e.isReferenced(t, r).next(function (e) {\n              return e ? ls.resolve() : n.removeEntry(t, r).next(function () {});\n            });\n          });\n        }, t.prototype.updateLimboDocument = function (t, e) {\n          var n = this;\n          return this.isReferenced(t, e).next(function (t) {\n            t ? n.orphanedDocuments.delete(e) : n.orphanedDocuments.add(e);\n          });\n        }, t.prototype.documentSize = function (t) {\n          return 0;\n        }, t.prototype.isReferenced = function (t, e) {\n          var n = this;\n          return ls.or([function () {\n            return n.persistence.getQueryCache().containsKey(t, e);\n          }, function () {\n            return n.persistence.mutationQueuesContainKey(t, e);\n          }, function () {\n            return ls.resolve(n.inMemoryPins.containsKey(e));\n          }]);\n        }, t;\n      }(),\n          _a = function () {\n        function t(t, e, n) {\n          this.persistence = t, this.serializer = e, this.orphanedSequenceNumbers = new Ss(function (t) {\n            return ns(t.path);\n          }), this.garbageCollector = new ca(this, n);\n        }\n\n        return t.prototype.onTransactionStarted = function () {}, t.prototype.onTransactionCommitted = function (t) {\n          return ls.resolve();\n        }, t.prototype.forEachTarget = function (t, e) {\n          return this.persistence.getQueryCache().forEachTarget(t, e);\n        }, t.prototype.getSequenceNumberCount = function (t) {\n          var e = this.orphanedDocumentCount(t);\n          return this.persistence.getQueryCache().getTargetCount(t).next(function (t) {\n            return e.next(function (e) {\n              return t + e;\n            });\n          });\n        }, t.prototype.orphanedDocumentCount = function (t) {\n          var e = 0;\n          return this.forEachOrphanedDocumentSequenceNumber(t, function (t) {\n            e++;\n          }).next(function () {\n            return e;\n          });\n        }, t.prototype.forEachOrphanedDocumentSequenceNumber = function (t, e) {\n          var n = this;\n          return ls.forEach(this.orphanedSequenceNumbers, function (r, i) {\n            return n.isPinned(t, r, i).next(function (t) {\n              return t ? ls.resolve() : e(i);\n            });\n          });\n        }, t.prototype.setInMemoryPins = function (t) {\n          this.inMemoryPins = t;\n        }, t.prototype.removeTargets = function (t, e, n) {\n          return this.persistence.getQueryCache().removeTargets(t, e, n);\n        }, t.prototype.removeOrphanedDocuments = function (t, e) {\n          var n = this,\n              r = 0,\n              i = this.persistence.getRemoteDocumentCache();\n          return i.forEachDocumentKey(t, function (o) {\n            return n.isPinned(t, o, e).next(function (e) {\n              return e ? ls.resolve() : (r++, i.removeEntry(t, o).next());\n            });\n          }).next(function () {\n            return r;\n          });\n        }, t.prototype.removeMutationReference = function (t, e) {\n          return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), ls.resolve();\n        }, t.prototype.removeTarget = function (t, e) {\n          var n = e.copy({\n            sequenceNumber: t.currentSequenceNumber\n          });\n          return this.persistence.getQueryCache().updateQueryData(t, n);\n        }, t.prototype.addReference = function (t, e) {\n          return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), ls.resolve();\n        }, t.prototype.removeReference = function (t, e) {\n          return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), ls.resolve();\n        }, t.prototype.updateLimboDocument = function (t, e) {\n          return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), ls.resolve();\n        }, t.prototype.documentSize = function (t) {\n          var e,\n              n = this.serializer.toDbRemoteDocument(t);\n          if (n.document) e = n.document;else if (n.unknownDocument) e = n.unknownDocument;else {\n            if (!n.noDocument) throw er(\"Unknown remote document type\");\n            e = n.noDocument;\n          }\n          return JSON.stringify(e).length;\n        }, t.prototype.isPinned = function (t, e, n) {\n          var r = this;\n          return ls.or([function () {\n            return r.persistence.mutationQueuesContainKey(t, e);\n          }, function () {\n            return ls.resolve(r.inMemoryPins.containsKey(e));\n          }, function () {\n            return r.persistence.getQueryCache().containsKey(t, e);\n          }, function () {\n            var t = r.orphanedSequenceNumbers.get(e);\n            return ls.resolve(void 0 !== t && t > n);\n          }]);\n        }, t.prototype.getCacheSize = function (t) {\n          return this.persistence.getRemoteDocumentCache().getSize(t);\n        }, t;\n      }(),\n          Pa = function () {\n        function t(t, e, n, r, i) {\n          this.queue = t, this.timerId = e, this.initialDelayMs = n, this.backoffFactor = r, this.maxDelayMs = i, this.timerPromise = null, this.lastAttemptTime = Date.now(), this.reset();\n        }\n\n        return t.prototype.reset = function () {\n          this.currentBaseMs = 0;\n        }, t.prototype.resetToMax = function () {\n          this.currentBaseMs = this.maxDelayMs;\n        }, t.prototype.backoffAndRun = function (t) {\n          var e = this;\n          this.cancel();\n          var n = Math.floor(this.currentBaseMs + this.jitterDelayMs()),\n              r = Math.max(0, Date.now() - this.lastAttemptTime),\n              i = Math.max(0, n - r);\n          this.currentBaseMs > 0 && Zn(\"ExponentialBackoff\", \"Backing off for \" + i + \" ms (base delay: \" + this.currentBaseMs + \" ms, delay with jitter: \" + n + \" ms, last attempt: \" + r + \" ms ago)\"), this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, i, function () {\n            return e.lastAttemptTime = Date.now(), t();\n          }), this.currentBaseMs *= this.backoffFactor, this.currentBaseMs < this.initialDelayMs && (this.currentBaseMs = this.initialDelayMs), this.currentBaseMs > this.maxDelayMs && (this.currentBaseMs = this.maxDelayMs);\n        }, t.prototype.cancel = function () {\n          null !== this.timerPromise && (this.timerPromise.cancel(), this.timerPromise = null);\n        }, t.prototype.jitterDelayMs = function () {\n          return (Math.random() - .5) * this.currentBaseMs;\n        }, t;\n      }();\n\n      !function (t) {\n        t[t.Initial = 0] = \"Initial\", t[t.Starting = 1] = \"Starting\", t[t.Open = 2] = \"Open\", t[t.Error = 3] = \"Error\", t[t.Backoff = 4] = \"Backoff\";\n      }(Na || (Na = {}));\n\n      var La,\n          xa,\n          qa = 1e3,\n          Fa = 6e4,\n          Ba = 1.5,\n          Ua = function () {\n        function t(t, e, n, r, i, o) {\n          this.queue = t, this.idleTimerId = n, this.connection = r, this.credentialsProvider = i, this.listener = o, this.state = Na.Initial, this.closeCount = 0, this.idleTimer = null, this.stream = null, this.backoff = new Pa(t, e, qa, Ba, Fa);\n        }\n\n        return t.prototype.isStarted = function () {\n          return this.state === Na.Starting || this.state === Na.Open || this.state === Na.Backoff;\n        }, t.prototype.isOpen = function () {\n          return this.state === Na.Open;\n        }, t.prototype.start = function () {\n          this.state !== Na.Error ? (nr(this.state === Na.Initial, \"Already started\"), this.auth()) : this.performBackoff();\n        }, t.prototype.stop = function () {\n          return a(this, void 0, void 0, function () {\n            return u(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.isStarted() ? [4, this.close(Na.Initial)] : [3, 2];\n\n                case 1:\n                  t.sent(), t.label = 2;\n\n                case 2:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.inhibitBackoff = function () {\n          nr(!this.isStarted(), \"Can only inhibit backoff in a stopped state\"), this.state = Na.Initial, this.backoff.reset();\n        }, t.prototype.markIdle = function () {\n          var t = this;\n          this.isOpen() && null === this.idleTimer && (this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, 6e4, function () {\n            return t.handleIdleCloseTimer();\n          }));\n        }, t.prototype.sendRequest = function (t) {\n          this.cancelIdleCheck(), this.stream.send(t);\n        }, t.prototype.handleIdleCloseTimer = function () {\n          return a(this, void 0, void 0, function () {\n            return u(this, function (t) {\n              return this.isOpen() ? [2, this.close(Na.Initial)] : [2];\n            });\n          });\n        }, t.prototype.cancelIdleCheck = function () {\n          this.idleTimer && (this.idleTimer.cancel(), this.idleTimer = null);\n        }, t.prototype.close = function (t, e) {\n          return a(this, void 0, void 0, function () {\n            return u(this, function (n) {\n              switch (n.label) {\n                case 0:\n                  return nr(this.isStarted(), \"Only started streams should be closed.\"), nr(t === Na.Error || Ti(e), \"Can't provide an error when not in an error state.\"), this.cancelIdleCheck(), this.backoff.cancel(), this.closeCount++, t !== Na.Error ? this.backoff.reset() : e && e.code === or.RESOURCE_EXHAUSTED ? ($n(e.toString()), $n(\"Using maximum backoff delay to prevent overloading the backend.\"), this.backoff.resetToMax()) : e && e.code === or.UNAUTHENTICATED && this.credentialsProvider.invalidateToken(), null !== this.stream && (this.tearDown(), this.stream.close(), this.stream = null), this.state = t, [4, this.listener.onClose(e)];\n\n                case 1:\n                  return n.sent(), [2];\n              }\n            });\n          });\n        }, t.prototype.tearDown = function () {}, t.prototype.auth = function () {\n          var t = this;\n          nr(this.state === Na.Initial, \"Must be in initial state to auth\"), this.state = Na.Starting;\n          var e = this.getCloseGuardedDispatcher(this.closeCount),\n              n = this.closeCount;\n          this.credentialsProvider.getToken().then(function (e) {\n            t.closeCount === n && t.startStream(e);\n          }, function (n) {\n            e(function () {\n              var e = new sr(or.UNKNOWN, \"Fetching auth token failed: \" + n.message);\n              return t.handleStreamClose(e);\n            });\n          });\n        }, t.prototype.startStream = function (t) {\n          var e = this;\n          nr(this.state === Na.Starting, \"Trying to start stream in a non-starting state\");\n          var n = this.getCloseGuardedDispatcher(this.closeCount);\n          this.stream = this.startRpc(t), this.stream.onOpen(function () {\n            n(function () {\n              return nr(e.state === Na.Starting, \"Expected stream to be in state Starting, but was \" + e.state), e.state = Na.Open, e.listener.onOpen();\n            });\n          }), this.stream.onClose(function (t) {\n            n(function () {\n              return e.handleStreamClose(t);\n            });\n          }), this.stream.onMessage(function (t) {\n            n(function () {\n              return e.onMessage(t);\n            });\n          });\n        }, t.prototype.performBackoff = function () {\n          var t = this;\n          nr(this.state === Na.Error, \"Should only perform backoff when in Error state\"), this.state = Na.Backoff, this.backoff.backoffAndRun(function () {\n            return a(t, void 0, void 0, function () {\n              return u(this, function (t) {\n                return nr(this.state === Na.Backoff, \"Backoff elapsed but state is now: \" + this.state), this.state = Na.Initial, this.start(), nr(this.isStarted(), \"PersistentStream should have started\"), [2];\n              });\n            });\n          });\n        }, t.prototype.handleStreamClose = function (t) {\n          return nr(this.isStarted(), \"Can't handle server close on non-started stream\"), Zn(\"PersistentStream\", \"close with error: \" + t), this.stream = null, this.close(Na.Error, t);\n        }, t.prototype.getCloseGuardedDispatcher = function (t) {\n          var e = this;\n          return function (n) {\n            e.queue.enqueueAndForget(function () {\n              return e.closeCount === t ? n() : (Zn(\"PersistentStream\", \"stream callback skipped by getCloseGuardedDispatcher.\"), Promise.resolve());\n            });\n          };\n        }, t;\n      }(),\n          Va = function (t) {\n        function e(e, n, r, i, o) {\n          var s = t.call(this, e, Go.ListenStreamConnectionBackoff, Go.ListenStreamIdle, n, r, o) || this;\n          return s.serializer = i, s;\n        }\n\n        return s(e, t), e.prototype.startRpc = function (t) {\n          return this.connection.openStream(\"Listen\", t);\n        }, e.prototype.onMessage = function (t) {\n          this.backoff.reset();\n          var e = this.serializer.fromWatchChange(t),\n              n = this.serializer.versionFromListenResponse(t);\n          return this.listener.onWatchChange(e, n);\n        }, e.prototype.watch = function (t) {\n          var e = {};\n          e.database = this.serializer.encodedDatabaseId, e.addTarget = this.serializer.toTarget(t);\n          var n = this.serializer.toListenRequestLabels(t);\n          n && (e.labels = n), this.sendRequest(e);\n        }, e.prototype.unwatch = function (t) {\n          var e = {};\n          e.database = this.serializer.encodedDatabaseId, e.removeTarget = t, this.sendRequest(e);\n        }, e;\n      }(Ua),\n          Qa = function (t) {\n        function e(e, n, r, i, o) {\n          var s = t.call(this, e, Go.WriteStreamConnectionBackoff, Go.WriteStreamIdle, n, r, o) || this;\n          return s.serializer = i, s.handshakeComplete_ = !1, s;\n        }\n\n        return s(e, t), Object.defineProperty(e.prototype, \"handshakeComplete\", {\n          get: function get() {\n            return this.handshakeComplete_;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.start = function () {\n          this.handshakeComplete_ = !1, t.prototype.start.call(this);\n        }, e.prototype.tearDown = function () {\n          this.handshakeComplete_ && this.writeMutations([]);\n        }, e.prototype.startRpc = function (t) {\n          return this.connection.openStream(\"Write\", t);\n        }, e.prototype.onMessage = function (t) {\n          if (nr(!!t.streamToken, \"Got a write response without a stream token\"), this.lastStreamToken = t.streamToken, this.handshakeComplete_) {\n            this.backoff.reset();\n            var e = this.serializer.fromWriteResults(t.writeResults, t.commitTime),\n                n = this.serializer.fromVersion(t.commitTime);\n            return this.listener.onMutationResult(n, e);\n          }\n\n          return nr(!t.writeResults || 0 === t.writeResults.length, \"Got mutation results for handshake\"), this.handshakeComplete_ = !0, this.listener.onHandshakeComplete();\n        }, e.prototype.writeHandshake = function () {\n          nr(this.isOpen(), \"Writing handshake requires an opened stream\"), nr(!this.handshakeComplete_, \"Handshake already completed\");\n          var t = {};\n          t.database = this.serializer.encodedDatabaseId, this.sendRequest(t);\n        }, e.prototype.writeMutations = function (t) {\n          var e = this;\n          nr(this.isOpen(), \"Writing mutations requires an opened stream\"), nr(this.handshakeComplete_, \"Handshake must be complete before writing mutations\"), nr(this.lastStreamToken.length > 0, \"Trying to write mutation without a token\");\n          var n = {\n            streamToken: this.lastStreamToken,\n            writes: t.map(function (t) {\n              return e.serializer.toMutation(t);\n            })\n          };\n          this.sendRequest(n);\n        }, e;\n      }(Ua),\n          Ka = function () {\n        function t(t, e, n, r) {\n          this.queue = t, this.connection = e, this.credentials = n, this.serializer = r;\n        }\n\n        return t.prototype.newPersistentWriteStream = function (t) {\n          return new Qa(this.queue, this.connection, this.credentials, this.serializer, t);\n        }, t.prototype.newPersistentWatchStream = function (t) {\n          return new Va(this.queue, this.connection, this.credentials, this.serializer, t);\n        }, t.prototype.commit = function (t) {\n          var e = this,\n              n = {\n            database: this.serializer.encodedDatabaseId,\n            writes: t.map(function (t) {\n              return e.serializer.toMutation(t);\n            })\n          };\n          return this.invokeRPC(\"Commit\", n).then(function (t) {\n            return e.serializer.fromWriteResults(t.writeResults, t.commitTime);\n          });\n        }, t.prototype.lookup = function (t) {\n          var e = this,\n              n = {\n            database: this.serializer.encodedDatabaseId,\n            documents: t.map(function (t) {\n              return e.serializer.toName(t);\n            })\n          };\n          return this.invokeStreamingRPC(\"BatchGetDocuments\", n).then(function (n) {\n            var r = so();\n            n.forEach(function (t) {\n              var n = e.serializer.fromMaybeDocument(t);\n              r = r.insert(n.key, n);\n            });\n            var i = [];\n            return t.forEach(function (t) {\n              var e = r.get(t);\n              nr(!!e, \"Missing entity in write response for \" + t), i.push(e);\n            }), i;\n          });\n        }, t.prototype.invokeRPC = function (t, e) {\n          var n = this;\n          return this.credentials.getToken().then(function (r) {\n            return n.connection.invokeRPC(t, e, r);\n          }).catch(function (t) {\n            throw t.code === or.UNAUTHENTICATED && n.credentials.invalidateToken(), t;\n          });\n        }, t.prototype.invokeStreamingRPC = function (t, e) {\n          var n = this;\n          return this.credentials.getToken().then(function (r) {\n            return n.connection.invokeStreamingRPC(t, e, r);\n          }).catch(function (t) {\n            throw t.code === or.UNAUTHENTICATED && n.credentials.invalidateToken(), t;\n          });\n        }, t;\n      }(),\n          Wa = function () {\n        function t(t) {\n          this.datastore = t, this.readVersions = lo(), this.mutations = [], this.committed = !1;\n        }\n\n        return t.prototype.recordVersion = function (t) {\n          var e;\n          if (t instanceof Yr) e = t.version;else {\n            if (!(t instanceof Jr)) throw er(\"Document in a transaction was a \" + t.constructor.name);\n            e = qi.forDeletedDoc();\n          }\n          var n = this.readVersions.get(t.key);\n\n          if (null !== n) {\n            if (!e.isEqual(n)) throw new sr(or.ABORTED, \"Document version changed between two reads.\");\n          } else this.readVersions = this.readVersions.insert(t.key, e);\n        }, t.prototype.lookup = function (t) {\n          var e = this;\n          return this.committed ? Promise.reject(\"Transaction has already completed.\") : this.mutations.length > 0 ? Promise.reject(\"Transactions lookups are invalid after writes.\") : this.datastore.lookup(t).then(function (t) {\n            return t.forEach(function (t) {\n              t instanceof Jr || t instanceof Yr ? e.recordVersion(t) : er(\"Document in a transaction was a \" + t.constructor.name);\n            }), t;\n          });\n        }, t.prototype.write = function (t) {\n          if (this.committed) throw new sr(or.FAILED_PRECONDITION, \"Transaction has already completed.\");\n          this.mutations = this.mutations.concat(t);\n        }, t.prototype.precondition = function (t) {\n          var e = this.readVersions.get(t);\n          return e ? ji.updateTime(e) : ji.NONE;\n        }, t.prototype.preconditionForUpdate = function (t) {\n          var e = this.readVersions.get(t);\n          if (e && e.isEqual(qi.forDeletedDoc())) throw new sr(or.FAILED_PRECONDITION, \"Can't update a document that doesn't exist.\");\n          return e ? ji.updateTime(e) : ji.exists(!0);\n        }, t.prototype.set = function (t, e) {\n          this.write(e.toMutations(t, this.precondition(t)));\n        }, t.prototype.update = function (t, e) {\n          this.write(e.toMutations(t, this.preconditionForUpdate(t)));\n        }, t.prototype.delete = function (t) {\n          this.write([new Yi(t, this.precondition(t))]), this.readVersions = this.readVersions.insert(t, qi.forDeletedDoc());\n        }, t.prototype.commit = function () {\n          var t = this,\n              e = this.readVersions;\n          return this.mutations.forEach(function (t) {\n            e = e.remove(t.key);\n          }), e.isEmpty() ? this.datastore.commit(this.mutations).then(function () {\n            t.committed = !0;\n          }) : Promise.reject(Error(\"Every document read in a transaction must also be written.\"));\n        }, t;\n      }();\n\n      !function (t) {\n        t[t.Unknown = 0] = \"Unknown\", t[t.Online = 1] = \"Online\", t[t.Offline = 2] = \"Offline\";\n      }(La || (La = {})), function (t) {\n        t[t.RemoteStore = 0] = \"RemoteStore\", t[t.SharedClientState = 1] = \"SharedClientState\";\n      }(xa || (xa = {}));\n\n      var ja = function () {\n        function t(t, e) {\n          this.asyncQueue = t, this.onlineStateHandler = e, this.state = La.Unknown, this.watchStreamFailures = 0, this.onlineStateTimer = null, this.shouldWarnClientIsOffline = !0;\n        }\n\n        return t.prototype.handleWatchStreamStart = function () {\n          var t = this;\n          0 === this.watchStreamFailures && (this.setAndBroadcast(La.Unknown), nr(null === this.onlineStateTimer, \"onlineStateTimer shouldn't be started yet\"), this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(Go.OnlineStateTimeout, 1e4, function () {\n            return t.onlineStateTimer = null, nr(t.state === La.Unknown, \"Timer should be canceled if we transitioned to a different state.\"), t.logClientOfflineWarningIfNecessary(\"Backend didn't respond within 10 seconds.\"), t.setAndBroadcast(La.Offline), Promise.resolve();\n          }));\n        }, t.prototype.handleWatchStreamFailure = function (t) {\n          this.state === La.Online ? (this.setAndBroadcast(La.Unknown), nr(0 === this.watchStreamFailures, \"watchStreamFailures must be 0\"), nr(null === this.onlineStateTimer, \"onlineStateTimer must be null\")) : (this.watchStreamFailures++, this.watchStreamFailures >= 1 && (this.clearOnlineStateTimer(), this.logClientOfflineWarningIfNecessary(\"Connection failed 1 times. Most recent error: \" + t.toString()), this.setAndBroadcast(La.Offline)));\n        }, t.prototype.set = function (t) {\n          this.clearOnlineStateTimer(), this.watchStreamFailures = 0, t === La.Online && (this.shouldWarnClientIsOffline = !1), this.setAndBroadcast(t);\n        }, t.prototype.setAndBroadcast = function (t) {\n          t !== this.state && (this.state = t, this.onlineStateHandler(t));\n        }, t.prototype.logClientOfflineWarningIfNecessary = function (t) {\n          var e = \"Could not reach Cloud Firestore backend. \" + t + \"\\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.\";\n          this.shouldWarnClientIsOffline ? ($n(e), this.shouldWarnClientIsOffline = !1) : Zn(\"OnlineStateTracker\", e);\n        }, t.prototype.clearOnlineStateTimer = function () {\n          null !== this.onlineStateTimer && (this.onlineStateTimer.cancel(), this.onlineStateTimer = null);\n        }, t;\n      }(),\n          za = function () {\n        function t(t, e, n, r) {\n          this.localStore = t, this.datastore = e, this.writePipeline = [], this.listenTargets = {}, this.watchChangeAggregator = null, this.networkEnabled = !1, this.isPrimary = !1, this.onlineStateTracker = new ja(n, r), this.watchStream = this.datastore.newPersistentWatchStream({\n            onOpen: this.onWatchStreamOpen.bind(this),\n            onClose: this.onWatchStreamClose.bind(this),\n            onWatchChange: this.onWatchStreamChange.bind(this)\n          }), this.writeStream = this.datastore.newPersistentWriteStream({\n            onOpen: this.onWriteStreamOpen.bind(this),\n            onClose: this.onWriteStreamClose.bind(this),\n            onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),\n            onMutationResult: this.onMutationResult.bind(this)\n          });\n        }\n\n        return t.prototype.start = function () {\n          return this.enableNetwork();\n        }, t.prototype.enableNetwork = function () {\n          return a(this, void 0, void 0, function () {\n            var t;\n            return u(this, function (e) {\n              switch (e.label) {\n                case 0:\n                  return this.networkEnabled = !0, this.canUseNetwork() ? (t = this.writeStream, [4, this.localStore.getLastStreamToken()]) : [3, 3];\n\n                case 1:\n                  return t.lastStreamToken = e.sent(), this.shouldStartWatchStream() ? this.startWatchStream() : this.onlineStateTracker.set(La.Unknown), [4, this.fillWritePipeline()];\n\n                case 2:\n                  e.sent(), e.label = 3;\n\n                case 3:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.disableNetwork = function () {\n          return a(this, void 0, void 0, function () {\n            return u(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.networkEnabled = !1, [4, this.disableNetworkInternal()];\n\n                case 1:\n                  return t.sent(), this.onlineStateTracker.set(La.Offline), [2];\n              }\n            });\n          });\n        }, t.prototype.disableNetworkInternal = function () {\n          return a(this, void 0, void 0, function () {\n            return u(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return [4, this.writeStream.stop()];\n\n                case 1:\n                  return t.sent(), [4, this.watchStream.stop()];\n\n                case 2:\n                  return t.sent(), this.writePipeline.length > 0 && (Zn(\"RemoteStore\", \"Stopping write stream with \" + this.writePipeline.length + \" pending writes\"), this.writePipeline = []), this.cleanUpWatchStreamState(), [2];\n              }\n            });\n          });\n        }, t.prototype.shutdown = function () {\n          return a(this, void 0, void 0, function () {\n            return u(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return Zn(\"RemoteStore\", \"RemoteStore shutting down.\"), this.networkEnabled = !1, [4, this.disableNetworkInternal()];\n\n                case 1:\n                  return t.sent(), this.onlineStateTracker.set(La.Unknown), [2];\n              }\n            });\n          });\n        }, t.prototype.listen = function (t) {\n          nr(!ur(this.listenTargets, t.targetId), \"listen called with duplicate targetId!\"), this.listenTargets[t.targetId] = t, this.shouldStartWatchStream() ? this.startWatchStream() : this.watchStream.isOpen() && this.sendWatchRequest(t);\n        }, t.prototype.unlisten = function (t) {\n          nr(ur(this.listenTargets, t), \"unlisten called without assigned target ID!\"), delete this.listenTargets[t], this.watchStream.isOpen() && this.sendUnwatchRequest(t), fr(this.listenTargets) && (this.watchStream.isOpen() ? this.watchStream.markIdle() : this.canUseNetwork() && this.onlineStateTracker.set(La.Unknown));\n        }, t.prototype.getQueryDataForTarget = function (t) {\n          return this.listenTargets[t] || null;\n        }, t.prototype.getRemoteKeysForTarget = function (t) {\n          return this.syncEngine.getRemoteKeysForTarget(t);\n        }, t.prototype.sendWatchRequest = function (t) {\n          this.watchChangeAggregator.recordPendingTargetRequest(t.targetId), this.watchStream.watch(t);\n        }, t.prototype.sendUnwatchRequest = function (t) {\n          this.watchChangeAggregator.recordPendingTargetRequest(t), this.watchStream.unwatch(t);\n        }, t.prototype.startWatchStream = function () {\n          nr(this.shouldStartWatchStream(), \"startWatchStream() called when shouldStartWatchStream() is false.\"), this.watchChangeAggregator = new ko(this), this.watchStream.start(), this.onlineStateTracker.handleWatchStreamStart();\n        }, t.prototype.shouldStartWatchStream = function () {\n          return this.canUseNetwork() && !this.watchStream.isStarted() && !fr(this.listenTargets);\n        }, t.prototype.canUseNetwork = function () {\n          return this.isPrimary && this.networkEnabled;\n        }, t.prototype.cleanUpWatchStreamState = function () {\n          this.watchChangeAggregator = null;\n        }, t.prototype.onWatchStreamOpen = function () {\n          return a(this, void 0, void 0, function () {\n            var t = this;\n            return u(this, function (e) {\n              return hr(this.listenTargets, function (e, n) {\n                t.sendWatchRequest(n);\n              }), [2];\n            });\n          });\n        }, t.prototype.onWatchStreamClose = function (t) {\n          return a(this, void 0, void 0, function () {\n            return u(this, function (e) {\n              return void 0 === t && nr(!this.shouldStartWatchStream(), \"Watch stream was stopped gracefully while still needed.\"), this.cleanUpWatchStreamState(), this.shouldStartWatchStream() ? (this.onlineStateTracker.handleWatchStreamFailure(t), this.startWatchStream()) : this.onlineStateTracker.set(La.Unknown), [2];\n            });\n          });\n        }, t.prototype.onWatchStreamChange = function (t, e) {\n          return a(this, void 0, void 0, function () {\n            var n;\n            return u(this, function (r) {\n              switch (r.label) {\n                case 0:\n                  return this.onlineStateTracker.set(La.Online), t instanceof No && t.state === wo.Removed && t.cause ? [2, this.handleTargetError(t)] : (t instanceof Co ? this.watchChangeAggregator.handleDocumentChange(t) : t instanceof Do ? this.watchChangeAggregator.handleExistenceFilter(t) : (nr(t instanceof No, \"Expected watchChange to be an instance of WatchTargetChange\"), this.watchChangeAggregator.handleTargetChange(t)), e.isEqual(qi.MIN) ? [3, 3] : [4, this.localStore.getLastRemoteSnapshotVersion()]);\n\n                case 1:\n                  return n = r.sent(), e.compareTo(n) >= 0 ? [4, this.raiseWatchSnapshot(e)] : [3, 3];\n\n                case 2:\n                  r.sent(), r.label = 3;\n\n                case 3:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.raiseWatchSnapshot = function (t) {\n          var e = this;\n          nr(!t.isEqual(qi.MIN), \"Can't raise event for unknown SnapshotVersion\");\n          var n = this.watchChangeAggregator.createRemoteEvent(t);\n          return hr(n.targetChanges, function (n, r) {\n            if (r.resumeToken.length > 0) {\n              var i = e.listenTargets[n];\n              i && (e.listenTargets[n] = i.copy({\n                resumeToken: r.resumeToken,\n                snapshotVersion: t\n              }));\n            }\n          }), n.targetMismatches.forEach(function (t) {\n            var n = e.listenTargets[t];\n\n            if (n) {\n              e.listenTargets[t] = n.copy({\n                resumeToken: ir()\n              }), e.sendUnwatchRequest(t);\n              var r = new Bi(n.query, t, Ci.ExistenceFilterMismatch, n.sequenceNumber);\n              e.sendWatchRequest(r);\n            }\n          }), this.syncEngine.applyRemoteEvent(n);\n        }, t.prototype.handleTargetError = function (t) {\n          var e = this;\n          nr(!!t.cause, \"Handling target error without a cause\");\n          var n = t.cause,\n              r = Promise.resolve();\n          return t.targetIds.forEach(function (t) {\n            r = r.then(function () {\n              return a(e, void 0, void 0, function () {\n                return u(this, function (e) {\n                  return ur(this.listenTargets, t) ? (delete this.listenTargets[t], this.watchChangeAggregator.removeTarget(t), [2, this.syncEngine.rejectListen(t, n)]) : [2];\n                });\n              });\n            });\n          }), r;\n        }, t.prototype.fillWritePipeline = function () {\n          return a(this, void 0, void 0, function () {\n            var t, e;\n            return u(this, function (n) {\n              switch (n.label) {\n                case 0:\n                  return this.canAddToWritePipeline() ? (t = this.writePipeline.length > 0 ? this.writePipeline[this.writePipeline.length - 1].batchId : -1, [4, this.localStore.nextMutationBatch(t)]) : [3, 4];\n\n                case 1:\n                  return null !== (e = n.sent()) ? [3, 2] : (0 === this.writePipeline.length && this.writeStream.markIdle(), [3, 4]);\n\n                case 2:\n                  return this.addToWritePipeline(e), [4, this.fillWritePipeline()];\n\n                case 3:\n                  n.sent(), n.label = 4;\n\n                case 4:\n                  return this.shouldStartWriteStream() && this.startWriteStream(), [2];\n              }\n            });\n          });\n        }, t.prototype.canAddToWritePipeline = function () {\n          return this.canUseNetwork() && this.writePipeline.length < 10;\n        }, t.prototype.outstandingWrites = function () {\n          return this.writePipeline.length;\n        }, t.prototype.addToWritePipeline = function (t) {\n          nr(this.canAddToWritePipeline(), \"addToWritePipeline called when pipeline is full\"), this.writePipeline.push(t), this.writeStream.isOpen() && this.writeStream.handshakeComplete && this.writeStream.writeMutations(t.mutations);\n        }, t.prototype.shouldStartWriteStream = function () {\n          return this.canUseNetwork() && !this.writeStream.isStarted() && this.writePipeline.length > 0;\n        }, t.prototype.startWriteStream = function () {\n          nr(this.shouldStartWriteStream(), \"startWriteStream() called when shouldStartWriteStream() is false.\"), this.writeStream.start();\n        }, t.prototype.onWriteStreamOpen = function () {\n          return a(this, void 0, void 0, function () {\n            return u(this, function (t) {\n              return this.writeStream.writeHandshake(), [2];\n            });\n          });\n        }, t.prototype.onWriteHandshakeComplete = function () {\n          var t = this;\n          return this.localStore.setLastStreamToken(this.writeStream.lastStreamToken).then(function () {\n            for (var e = 0, n = t.writePipeline; e < n.length; e++) {\n              var r = n[e];\n              t.writeStream.writeMutations(r.mutations);\n            }\n          }).catch(ya);\n        }, t.prototype.onMutationResult = function (t, e) {\n          var n = this;\n          nr(this.writePipeline.length > 0, \"Got result for empty write pipeline\");\n          var r = this.writePipeline.shift(),\n              i = us.from(r, t, e, this.writeStream.lastStreamToken);\n          return this.syncEngine.applySuccessfulWrite(i).then(function () {\n            return n.fillWritePipeline();\n          });\n        }, t.prototype.onWriteStreamClose = function (t) {\n          return a(this, void 0, void 0, function () {\n            var e = this;\n            return u(this, function (n) {\n              return void 0 === t && nr(!this.shouldStartWriteStream(), \"Write stream was stopped gracefully while still needed.\"), t && this.writePipeline.length > 0 ? (void 0, [2, (this.writeStream.handshakeComplete ? this.handleWriteError(t) : this.handleHandshakeError(t)).then(function () {\n                e.shouldStartWriteStream() && e.startWriteStream();\n              })]) : [2];\n            });\n          });\n        }, t.prototype.handleHandshakeError = function (t) {\n          return a(this, void 0, void 0, function () {\n            return u(this, function (e) {\n              return ro(t.code) ? (Zn(\"RemoteStore\", \"RemoteStore error before completed handshake; resetting stream token: \", this.writeStream.lastStreamToken), this.writeStream.lastStreamToken = ir(), [2, this.localStore.setLastStreamToken(ir()).catch(ya)]) : [2];\n            });\n          });\n        }, t.prototype.handleWriteError = function (t) {\n          return a(this, void 0, void 0, function () {\n            var e,\n                n = this;\n            return u(this, function (r) {\n              return ro(i = t.code) && i !== or.ABORTED ? (e = this.writePipeline.shift(), this.writeStream.inhibitBackoff(), [2, this.syncEngine.rejectFailedWrite(e.batchId, t).then(function () {\n                return n.fillWritePipeline();\n              })]) : [2];\n              var i;\n            });\n          });\n        }, t.prototype.createTransaction = function () {\n          return new Wa(this.datastore);\n        }, t.prototype.handleCredentialChange = function () {\n          return a(this, void 0, void 0, function () {\n            return u(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.canUseNetwork() ? (Zn(\"RemoteStore\", \"RemoteStore restarting streams for new credential\"), this.networkEnabled = !1, [4, this.disableNetworkInternal()]) : [3, 3];\n\n                case 1:\n                  return t.sent(), this.onlineStateTracker.set(La.Unknown), [4, this.enableNetwork()];\n\n                case 2:\n                  t.sent(), t.label = 3;\n\n                case 3:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.applyPrimaryState = function (t) {\n          return a(this, void 0, void 0, function () {\n            return u(this, function (e) {\n              switch (e.label) {\n                case 0:\n                  return this.isPrimary = t, t && this.networkEnabled ? [4, this.enableNetwork()] : [3, 2];\n\n                case 1:\n                  return e.sent(), [3, 4];\n\n                case 2:\n                  return t ? [3, 4] : [4, this.disableNetworkInternal()];\n\n                case 3:\n                  e.sent(), this.onlineStateTracker.set(La.Unknown), e.label = 4;\n\n                case 4:\n                  return [2];\n              }\n            });\n          });\n        }, t;\n      }(),\n          Ga = function () {\n        return function () {\n          this.listeners = [];\n        };\n      }(),\n          Ha = function () {\n        function t(t) {\n          this.syncEngine = t, this.queries = new Ss(function (t) {\n            return t.canonicalId();\n          }), this.onlineState = La.Unknown, this.syncEngine.subscribe(this);\n        }\n\n        return t.prototype.listen = function (t) {\n          var e = t.query,\n              n = !1,\n              r = this.queries.get(e);\n          return r || (n = !0, r = new Ga(), this.queries.set(e, r)), r.listeners.push(t), t.applyOnlineStateChange(this.onlineState), r.viewSnap && t.onViewSnapshot(r.viewSnap), n ? this.syncEngine.listen(e).then(function (t) {\n            return r.targetId = t, t;\n          }) : Promise.resolve(r.targetId);\n        }, t.prototype.unlisten = function (t) {\n          return a(this, void 0, void 0, function () {\n            var e, n, r, i;\n            return u(this, function (o) {\n              return e = t.query, n = !1, (r = this.queries.get(e)) && (i = r.listeners.indexOf(t)) >= 0 && (r.listeners.splice(i, 1), n = 0 === r.listeners.length), n ? (this.queries.delete(e), [2, this.syncEngine.unlisten(e)]) : [2];\n            });\n          });\n        }, t.prototype.onWatchChange = function (t) {\n          for (var e = 0, n = t; e < n.length; e++) {\n            var r = n[e],\n                i = r.query,\n                o = this.queries.get(i);\n\n            if (o) {\n              for (var s = 0, a = o.listeners; s < a.length; s++) {\n                a[s].onViewSnapshot(r);\n              }\n\n              o.viewSnap = r;\n            }\n          }\n        }, t.prototype.onWatchError = function (t, e) {\n          var n = this.queries.get(t);\n          if (n) for (var r = 0, i = n.listeners; r < i.length; r++) {\n            i[r].onError(e);\n          }\n          this.queries.delete(t);\n        }, t.prototype.onOnlineStateChange = function (t) {\n          this.onlineState = t, this.queries.forEach(function (e, n) {\n            for (var r = 0, i = n.listeners; r < i.length; r++) {\n              i[r].applyOnlineStateChange(t);\n            }\n          });\n        }, t;\n      }(),\n          Xa = function () {\n        function t(t, e, n) {\n          this.query = t, this.queryObserver = e, this.raisedInitialEvent = !1, this.onlineState = La.Unknown, this.options = n || {};\n        }\n\n        return t.prototype.onViewSnapshot = function (t) {\n          if (nr(t.docChanges.length > 0 || t.syncStateChanged, \"We got a new snapshot with no changes?\"), !this.options.includeMetadataChanges) {\n            for (var e = [], n = 0, r = t.docChanges; n < r.length; n++) {\n              var i = r[n];\n              i.type !== go.Metadata && e.push(i);\n            }\n\n            t = new So(t.query, t.docs, t.oldDocs, e, t.mutatedKeys, t.fromCache, t.syncStateChanged, !0);\n          }\n\n          this.raisedInitialEvent ? this.shouldRaiseEvent(t) && this.queryObserver.next(t) : this.shouldRaiseInitialEvent(t, this.onlineState) && this.raiseInitialEvent(t), this.snap = t;\n        }, t.prototype.onError = function (t) {\n          this.queryObserver.error(t);\n        }, t.prototype.applyOnlineStateChange = function (t) {\n          this.onlineState = t, this.snap && !this.raisedInitialEvent && this.shouldRaiseInitialEvent(this.snap, t) && this.raiseInitialEvent(this.snap);\n        }, t.prototype.shouldRaiseInitialEvent = function (t, e) {\n          if (nr(!this.raisedInitialEvent, \"Determining whether to raise first event but already had first event\"), !t.fromCache) return !0;\n          var n = e !== La.Offline;\n          return this.options.waitForSyncWhenOnline && n ? (nr(t.fromCache, \"Waiting for sync, but snapshot is not from cache\"), !1) : !t.docs.isEmpty() || e === La.Offline;\n        }, t.prototype.shouldRaiseEvent = function (t) {\n          if (t.docChanges.length > 0) return !0;\n          var e = this.snap && this.snap.hasPendingWrites !== t.hasPendingWrites;\n          return !(!t.syncStateChanged && !e) && !0 === this.options.includeMetadataChanges;\n        }, t.prototype.raiseInitialEvent = function (t) {\n          nr(!this.raisedInitialEvent, \"Trying to raise initial events for second time\"), t = So.fromInitialDocuments(t.query, t.docs, t.mutatedKeys, t.fromCache), this.raisedInitialEvent = !0, this.queryObserver.next(t);\n        }, t;\n      }(),\n          Ya = function () {\n        function t(t, e, n) {\n          this.targetId = t, this.addedKeys = e, this.removedKeys = n;\n        }\n\n        return t.fromSnapshot = function (e, n) {\n          for (var r = po(), i = po(), o = 0, s = n.docChanges; o < s.length; o++) {\n            var a = s[o];\n\n            switch (a.type) {\n              case go.Added:\n                r = r.add(a.doc.key);\n                break;\n\n              case go.Removed:\n                i = i.add(a.doc.key);\n            }\n          }\n\n          return new t(e, r, i);\n        }, t;\n      }(),\n          Ja = function () {\n        return function (t) {\n          this.key = t;\n        };\n      }(),\n          Za = function () {\n        return function (t) {\n          this.key = t;\n        };\n      }(),\n          $a = function () {\n        function t(t, e) {\n          this.query = t, this._syncedDocuments = e, this.syncState = null, this.current = !1, this.limboDocuments = po(), this.mutatedKeys = po(), this.documentSet = new bo(t.docComparator.bind(t));\n        }\n\n        return Object.defineProperty(t.prototype, \"syncedDocuments\", {\n          get: function get() {\n            return this._syncedDocuments;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.computeDocChanges = function (t, e) {\n          var n = this,\n              r = e ? e.changeSet : new Eo(),\n              i = e ? e.documentSet : this.documentSet,\n              o = e ? e.mutatedKeys : this.mutatedKeys,\n              s = i,\n              a = !1,\n              u = this.query.hasLimit() && i.size === this.query.limit ? i.last() : null;\n          if (t.inorderTraversal(function (t, e) {\n            var c = i.get(t),\n                h = e instanceof Yr ? e : null;\n            h && (nr(t.isEqual(h.key), \"Mismatching keys found in document changes: \" + t + \" != \" + h.key), h = n.query.matches(h) ? h : null);\n            var l = !!c && n.mutatedKeys.has(c.key),\n                f = !!h && (h.hasLocalMutations || n.mutatedKeys.has(h.key) && h.hasCommittedMutations),\n                d = !1;\n            c && h ? c.data.isEqual(h.data) ? l !== f && (r.track({\n              type: go.Metadata,\n              doc: h\n            }), d = !0) : n.shouldWaitForSyncedDocument(c, h) || (r.track({\n              type: go.Modified,\n              doc: h\n            }), d = !0, u && n.query.docComparator(h, u) > 0 && (a = !0)) : !c && h ? (r.track({\n              type: go.Added,\n              doc: h\n            }), d = !0) : c && !h && (r.track({\n              type: go.Removed,\n              doc: c\n            }), d = !0, u && (a = !0));\n            d && (h ? (s = s.add(h), o = f ? o.add(t) : o.delete(t)) : (s = s.delete(t), o = o.delete(t)));\n          }), this.query.hasLimit()) for (; s.size > this.query.limit;) {\n            var c = s.last();\n            s = s.delete(c.key), o = o.delete(c.key), r.track({\n              type: go.Removed,\n              doc: c\n            });\n          }\n          return nr(!a || !e, \"View was refilled using docs that themselves needed refilling.\"), {\n            documentSet: s,\n            changeSet: r,\n            needsRefill: a,\n            mutatedKeys: o\n          };\n        }, t.prototype.shouldWaitForSyncedDocument = function (t, e) {\n          return t.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;\n        }, t.prototype.applyChanges = function (t, e, n) {\n          var r = this;\n          nr(!t.needsRefill, \"Cannot apply changes that need a refill\");\n          var i = this.documentSet;\n          this.documentSet = t.documentSet, this.mutatedKeys = t.mutatedKeys;\n          var o = t.changeSet.getChanges();\n          o.sort(function (t, e) {\n            return function (t, e) {\n              var n = function n(t) {\n                switch (t) {\n                  case go.Added:\n                    return 1;\n\n                  case go.Modified:\n                  case go.Metadata:\n                    return 2;\n\n                  case go.Removed:\n                    return 0;\n\n                  default:\n                    return er(\"Unknown ChangeType: \" + t);\n                }\n              };\n\n              return n(t) - n(e);\n            }(t.type, e.type) || r.query.docComparator(t.doc, e.doc);\n          }), this.applyTargetChange(n);\n          var s = e ? this.updateLimboDocuments() : [],\n              a = 0 === this.limboDocuments.size && this.current ? vo.Synced : vo.Local,\n              u = a !== this.syncState;\n          return this.syncState = a, 0 !== o.length || u ? {\n            snapshot: new So(this.query, t.documentSet, i, o, t.mutatedKeys, a === vo.Local, u, !1),\n            limboChanges: s\n          } : {\n            limboChanges: s\n          };\n        }, t.prototype.applyOnlineStateChange = function (t) {\n          return this.current && t === La.Offline ? (this.current = !1, this.applyChanges({\n            documentSet: this.documentSet,\n            changeSet: new Eo(),\n            mutatedKeys: this.mutatedKeys,\n            needsRefill: !1\n          }, !1)) : {\n            limboChanges: []\n          };\n        }, t.prototype.shouldBeInLimbo = function (t) {\n          return !this._syncedDocuments.has(t) && !!this.documentSet.has(t) && !this.documentSet.get(t).hasLocalMutations;\n        }, t.prototype.applyTargetChange = function (t) {\n          var e = this;\n          t && (t.addedDocuments.forEach(function (t) {\n            return e._syncedDocuments = e._syncedDocuments.add(t);\n          }), t.modifiedDocuments.forEach(function (t) {\n            return nr(e._syncedDocuments.has(t), \"Modified document \" + t + \" not found in view.\");\n          }), t.removedDocuments.forEach(function (t) {\n            return e._syncedDocuments = e._syncedDocuments.delete(t);\n          }), this.current = t.current);\n        }, t.prototype.updateLimboDocuments = function () {\n          var t = this;\n          if (!this.current) return [];\n          var e = this.limboDocuments;\n          this.limboDocuments = po(), this.documentSet.forEach(function (e) {\n            t.shouldBeInLimbo(e.key) && (t.limboDocuments = t.limboDocuments.add(e.key));\n          });\n          var n = [];\n          return e.forEach(function (e) {\n            t.limboDocuments.has(e) || n.push(new Za(e));\n          }), this.limboDocuments.forEach(function (t) {\n            e.has(t) || n.push(new Ja(t));\n          }), n;\n        }, t.prototype.synchronizeWithPersistedState = function (t, e) {\n          this._syncedDocuments = e, this.limboDocuments = po();\n          var n = this.computeDocChanges(t);\n          return this.applyChanges(n, !0);\n        }, t.prototype.computeInitialSnapshot = function () {\n          return So.fromInitialDocuments(this.query, this.documentSet, this.mutatedKeys, this.syncState === vo.Local);\n        }, t;\n      }();\n\n      var tu = function () {\n        return function (t, e, n) {\n          this.query = t, this.targetId = e, this.view = n;\n        };\n      }(),\n          eu = function () {\n        return function (t) {\n          this.key = t;\n        };\n      }(),\n          nu = function () {\n        function t(t, e, n, r) {\n          this.localStore = t, this.remoteStore = e, this.sharedClientState = n, this.currentUser = r, this.syncEngineListener = null, this.queryViewsByQuery = new Ss(function (t) {\n            return t.canonicalId();\n          }), this.queryViewsByTarget = {}, this.limboTargetsByKey = new $r(Hr.comparator), this.limboResolutionsByTarget = {}, this.limboDocumentRefs = new Sa(), this.mutationUserCallbacks = {}, this.limboTargetIdGenerator = hs.forSyncEngine(), this.isPrimary = void 0, this.onlineState = La.Unknown;\n        }\n\n        return Object.defineProperty(t.prototype, \"isPrimaryClient\", {\n          get: function get() {\n            return !0 === this.isPrimary;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.subscribe = function (t) {\n          nr(null !== t, \"SyncEngine listener cannot be null\"), nr(null === this.syncEngineListener, \"SyncEngine already has a subscriber.\"), this.syncEngineListener = t;\n        }, t.prototype.listen = function (t) {\n          return a(this, void 0, void 0, function () {\n            var e, n, r, i, o;\n            return u(this, function (s) {\n              switch (s.label) {\n                case 0:\n                  return this.assertSubscribed(\"listen()\"), (r = this.queryViewsByQuery.get(t)) ? (e = r.targetId, this.sharedClientState.addLocalQueryTarget(e), n = r.view.computeInitialSnapshot(), [3, 4]) : [3, 1];\n\n                case 1:\n                  return [4, this.localStore.allocateQuery(t)];\n\n                case 2:\n                  return i = s.sent(), o = this.sharedClientState.addLocalQueryTarget(i.targetId), e = i.targetId, [4, this.initializeViewAndComputeSnapshot(i, \"current\" === o)];\n\n                case 3:\n                  n = s.sent(), this.isPrimary && this.remoteStore.listen(i), s.label = 4;\n\n                case 4:\n                  return this.syncEngineListener.onWatchChange([n]), [2, e];\n              }\n            });\n          });\n        }, t.prototype.initializeViewAndComputeSnapshot = function (t, e) {\n          var n = this,\n              r = t.query;\n          return this.localStore.executeQuery(r).then(function (i) {\n            return n.localStore.remoteDocumentKeys(t.targetId).then(function (o) {\n              var s = new $a(r, o),\n                  a = s.computeDocChanges(i),\n                  u = Io.createSynthesizedTargetChangeForCurrentChange(t.targetId, e && n.onlineState !== La.Offline),\n                  c = s.applyChanges(a, !0 === n.isPrimary, u);\n              nr(0 === c.limboChanges.length, \"View returned limbo docs before target ack from the server.\"), nr(!!c.snapshot, \"applyChanges for new view should always return a snapshot\");\n              var h = new tu(r, t.targetId, s);\n              return n.queryViewsByQuery.set(r, h), n.queryViewsByTarget[t.targetId] = h, c.snapshot;\n            });\n          });\n        }, t.prototype.synchronizeViewAndComputeSnapshot = function (t) {\n          var e = this;\n          return this.localStore.executeQuery(t.query).then(function (n) {\n            return e.localStore.remoteDocumentKeys(t.targetId).then(function (r) {\n              return a(e, void 0, void 0, function () {\n                var e;\n                return u(this, function (i) {\n                  return e = t.view.synchronizeWithPersistedState(n, r), this.isPrimary && this.updateTrackedLimbos(t.targetId, e.limboChanges), [2, e];\n                });\n              });\n            });\n          });\n        }, t.prototype.unlisten = function (t) {\n          return a(this, void 0, void 0, function () {\n            var e,\n                n = this;\n            return u(this, function (r) {\n              switch (r.label) {\n                case 0:\n                  return this.assertSubscribed(\"unlisten()\"), nr(!!(e = this.queryViewsByQuery.get(t)), \"Trying to unlisten on query not found:\" + t), this.isPrimary ? (this.sharedClientState.removeLocalQueryTarget(e.targetId), this.sharedClientState.isActiveQueryTarget(e.targetId) ? [3, 2] : [4, this.localStore.releaseQuery(t, !1).then(function () {\n                    n.sharedClientState.clearQueryState(e.targetId), n.remoteStore.unlisten(e.targetId), n.removeAndCleanupQuery(e);\n                  }).catch(ya)]) : [3, 3];\n\n                case 1:\n                  r.sent(), r.label = 2;\n\n                case 2:\n                  return [3, 5];\n\n                case 3:\n                  return this.removeAndCleanupQuery(e), [4, this.localStore.releaseQuery(t, !0)];\n\n                case 4:\n                  r.sent(), r.label = 5;\n\n                case 5:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.write = function (t, e) {\n          var n = this;\n          return this.assertSubscribed(\"write()\"), this.localStore.localWrite(t).then(function (t) {\n            return n.sharedClientState.addPendingMutation(t.batchId), n.addMutationCallback(t.batchId, e), n.emitNewSnapsAndNotifyLocalStore(t.changes);\n          }).then(function () {\n            return n.remoteStore.fillWritePipeline();\n          });\n        }, t.prototype.wrapUpdateFunctionError = function (t) {\n          return t;\n        }, t.prototype.runTransaction = function (t, e) {\n          var n = this;\n          void 0 === e && (e = 5), nr(e >= 0, \"Got negative number of retries for transaction.\");\n          var r = this.remoteStore.createTransaction();\n          return function () {\n            try {\n              var e = t(r);\n              return !Ti(e) && e.catch && e.then ? e.catch(function (t) {\n                return Promise.reject(n.wrapUpdateFunctionError(t));\n              }) : Promise.reject(Error(\"Transaction callback must return a Promise\"));\n            } catch (t) {\n              return Promise.reject(n.wrapUpdateFunctionError(t));\n            }\n          }().then(function (i) {\n            return r.commit().then(function () {\n              return i;\n            }).catch(function (r) {\n              return 0 === e ? Promise.reject(r) : n.runTransaction(t, e - 1);\n            });\n          });\n        }, t.prototype.applyRemoteEvent = function (t) {\n          var e = this;\n          return this.assertSubscribed(\"applyRemoteEvent()\"), this.localStore.applyRemoteEvent(t).then(function (n) {\n            return lr(t.targetChanges, function (t, n) {\n              var r = e.limboResolutionsByTarget[t];\n              r && (nr(n.addedDocuments.size + n.modifiedDocuments.size + n.removedDocuments.size <= 1, \"Limbo resolution for single document contains multiple changes.\"), n.addedDocuments.size > 0 ? r.receivedDocument = !0 : n.modifiedDocuments.size > 0 ? nr(r.receivedDocument, \"Received change for limbo target document without add.\") : n.removedDocuments.size > 0 && (nr(r.receivedDocument, \"Received remove for limbo target document without add.\"), r.receivedDocument = !1));\n            }), e.emitNewSnapsAndNotifyLocalStore(n, t);\n          }).catch(ya);\n        }, t.prototype.applyOnlineStateChange = function (t, e) {\n          if (this.isPrimary && e === xa.RemoteStore || !this.isPrimary && e === xa.SharedClientState) {\n            var n = [];\n            this.queryViewsByQuery.forEach(function (e, r) {\n              var i = r.view.applyOnlineStateChange(t);\n              nr(0 === i.limboChanges.length, \"OnlineState should not affect limbo documents.\"), i.snapshot && n.push(i.snapshot);\n            }), this.syncEngineListener.onOnlineStateChange(t), this.syncEngineListener.onWatchChange(n), this.onlineState = t, this.isPrimary && this.sharedClientState.setOnlineState(t);\n          }\n        }, t.prototype.rejectListen = function (t, e) {\n          return a(this, void 0, void 0, function () {\n            var n,\n                r,\n                i,\n                o,\n                s,\n                a,\n                c = this;\n            return u(this, function (u) {\n              switch (u.label) {\n                case 0:\n                  return this.assertSubscribed(\"rejectListens()\"), this.sharedClientState.updateQueryState(t, \"rejected\", e), n = this.limboResolutionsByTarget[t], (r = n && n.key) ? (this.limboTargetsByKey = this.limboTargetsByKey.remove(r), delete this.limboResolutionsByTarget[t], i = (i = new $r(Hr.comparator)).insert(r, new Jr(r, qi.forDeletedDoc())), o = po().add(r), s = new To(qi.MIN, {}, new Ui(Mr), i, o), [2, this.applyRemoteEvent(s)]) : [3, 1];\n\n                case 1:\n                  return nr(!!(a = this.queryViewsByTarget[t]), \"Unknown targetId: \" + t), [4, this.localStore.releaseQuery(a.query, !1).then(function () {\n                    return c.removeAndCleanupQuery(a);\n                  }).catch(ya)];\n\n                case 2:\n                  u.sent(), this.syncEngineListener.onWatchError(a.query, e), u.label = 3;\n\n                case 3:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.applyBatchState = function (t, e, n) {\n          return a(this, void 0, void 0, function () {\n            var r;\n            return u(this, function (i) {\n              switch (i.label) {\n                case 0:\n                  return this.assertSubscribed(\"applyBatchState()\"), [4, this.localStore.lookupMutationDocuments(t)];\n\n                case 1:\n                  return null === (r = i.sent()) ? (Zn(\"SyncEngine\", \"Cannot apply mutation batch with id: \" + t), [2]) : \"pending\" !== e ? [3, 3] : [4, this.remoteStore.fillWritePipeline()];\n\n                case 2:\n                  return i.sent(), [3, 4];\n\n                case 3:\n                  \"acknowledged\" === e || \"rejected\" === e ? (this.processUserCallback(t, n || null), this.localStore.removeCachedMutationBatchMetadata(t)) : er(\"Unknown batchState: \" + e), i.label = 4;\n\n                case 4:\n                  return [4, this.emitNewSnapsAndNotifyLocalStore(r)];\n\n                case 5:\n                  return i.sent(), [2];\n              }\n            });\n          });\n        }, t.prototype.applySuccessfulWrite = function (t) {\n          var e = this;\n          this.assertSubscribed(\"applySuccessfulWrite()\");\n          var n = t.batch.batchId;\n          return this.processUserCallback(n, null), this.localStore.acknowledgeBatch(t).then(function (t) {\n            return e.sharedClientState.updateMutationState(n, \"acknowledged\"), e.emitNewSnapsAndNotifyLocalStore(t);\n          }).catch(ya);\n        }, t.prototype.rejectFailedWrite = function (t, e) {\n          var n = this;\n          return this.assertSubscribed(\"rejectFailedWrite()\"), this.processUserCallback(t, e), this.localStore.rejectBatch(t).then(function (r) {\n            return n.sharedClientState.updateMutationState(t, \"rejected\", e), n.emitNewSnapsAndNotifyLocalStore(r);\n          }).catch(ya);\n        }, t.prototype.addMutationCallback = function (t, e) {\n          var n = this.mutationUserCallbacks[this.currentUser.toKey()];\n          n || (n = new $r(Mr)), n = n.insert(t, e), this.mutationUserCallbacks[this.currentUser.toKey()] = n;\n        }, t.prototype.processUserCallback = function (t, e) {\n          var n = this.mutationUserCallbacks[this.currentUser.toKey()];\n\n          if (n) {\n            var r = n.get(t);\n            r && (nr(t === n.minKey(), \"Mutation callbacks processed out-of-order?\"), e ? r.reject(e) : r.resolve(), n = n.remove(t)), this.mutationUserCallbacks[this.currentUser.toKey()] = n;\n          }\n        }, t.prototype.removeAndCleanupQuery = function (t) {\n          var e = this;\n\n          if (this.sharedClientState.removeLocalQueryTarget(t.targetId), this.queryViewsByQuery.delete(t.query), delete this.queryViewsByTarget[t.targetId], this.isPrimary) {\n            var n = this.limboDocumentRefs.referencesForId(t.targetId);\n            this.limboDocumentRefs.removeReferencesForId(t.targetId), n.forEach(function (t) {\n              e.limboDocumentRefs.containsKey(t) || e.removeLimboTarget(t);\n            });\n          }\n        }, t.prototype.removeLimboTarget = function (t) {\n          var e = this.limboTargetsByKey.get(t);\n          null !== e && (this.remoteStore.unlisten(e), this.limboTargetsByKey = this.limboTargetsByKey.remove(t), delete this.limboResolutionsByTarget[e]);\n        }, t.prototype.updateTrackedLimbos = function (t, e) {\n          for (var n = 0, r = e; n < r.length; n++) {\n            var i = r[n];\n            if (i instanceof Ja) this.limboDocumentRefs.addReference(i.key, t), this.trackLimboChange(i);else if (i instanceof Za) {\n              Zn(\"SyncEngine\", \"Document no longer in limbo: \" + i.key), this.limboDocumentRefs.removeReference(i.key, t), this.limboDocumentRefs.containsKey(i.key) || this.removeLimboTarget(i.key);\n            } else er(\"Unknown limbo change: \" + JSON.stringify(i));\n          }\n        }, t.prototype.trackLimboChange = function (t) {\n          var e = t.key;\n\n          if (!this.limboTargetsByKey.get(e)) {\n            Zn(\"SyncEngine\", \"New document in limbo: \" + e);\n            var n = this.limboTargetIdGenerator.next(),\n                r = Di.atPath(e.path);\n            this.limboResolutionsByTarget[n] = new eu(e), this.remoteStore.listen(new Bi(r, n, Ci.LimboResolution, Ho.INVALID)), this.limboTargetsByKey = this.limboTargetsByKey.insert(e, n);\n          }\n        }, t.prototype.currentLimboDocs = function () {\n          return this.limboTargetsByKey;\n        }, t.prototype.emitNewSnapsAndNotifyLocalStore = function (t, e) {\n          return a(this, void 0, void 0, function () {\n            var n,\n                r,\n                i,\n                o = this;\n            return u(this, function (s) {\n              switch (s.label) {\n                case 0:\n                  return n = [], r = [], i = [], this.queryViewsByQuery.forEach(function (s, a) {\n                    i.push(Promise.resolve().then(function () {\n                      var e = a.view.computeDocChanges(t);\n                      return e.needsRefill ? o.localStore.executeQuery(a.query).then(function (t) {\n                        return a.view.computeDocChanges(t, e);\n                      }) : e;\n                    }).then(function (t) {\n                      var i = e && e.targetChanges[a.targetId],\n                          s = a.view.applyChanges(t, !0 === o.isPrimary, i);\n\n                      if (o.updateTrackedLimbos(a.targetId, s.limboChanges), s.snapshot) {\n                        o.isPrimary && o.sharedClientState.updateQueryState(a.targetId, s.snapshot.fromCache ? \"not-current\" : \"current\"), n.push(s.snapshot);\n                        var u = Ya.fromSnapshot(a.targetId, s.snapshot);\n                        r.push(u);\n                      }\n                    }));\n                  }), [4, Promise.all(i)];\n\n                case 1:\n                  return s.sent(), this.syncEngineListener.onWatchChange(n), [4, this.localStore.notifyLocalViewChanges(r)];\n\n                case 2:\n                  return s.sent(), [2];\n              }\n            });\n          });\n        }, t.prototype.assertSubscribed = function (t) {\n          nr(null !== this.syncEngineListener, \"Trying to call \" + t + \" before calling subscribe().\");\n        }, t.prototype.handleCredentialChange = function (t) {\n          return a(this, void 0, void 0, function () {\n            var e, n;\n            return u(this, function (r) {\n              switch (r.label) {\n                case 0:\n                  return e = !this.currentUser.isEqual(t), this.currentUser = t, e ? [4, this.localStore.handleUserChange(t)] : [3, 3];\n\n                case 1:\n                  return n = r.sent(), this.sharedClientState.handleUserChange(t, n.removedBatchIds, n.addedBatchIds), [4, this.emitNewSnapsAndNotifyLocalStore(n.affectedDocuments)];\n\n                case 2:\n                  r.sent(), r.label = 3;\n\n                case 3:\n                  return [4, this.remoteStore.handleCredentialChange()];\n\n                case 4:\n                  return r.sent(), [2];\n              }\n            });\n          });\n        }, t.prototype.applyPrimaryState = function (t) {\n          return a(this, void 0, void 0, function () {\n            var e,\n                n,\n                r,\n                i,\n                o,\n                s,\n                a,\n                c = this;\n            return u(this, function (u) {\n              switch (u.label) {\n                case 0:\n                  return !0 !== t || !0 === this.isPrimary ? [3, 3] : (this.isPrimary = !0, [4, this.remoteStore.applyPrimaryState(!0)]);\n\n                case 1:\n                  return u.sent(), e = this.sharedClientState.getAllActiveQueryTargets(), [4, this.synchronizeQueryViewsAndRaiseSnapshots(e.toArray())];\n\n                case 2:\n                  for (n = u.sent(), r = 0, i = n; r < i.length; r++) {\n                    o = i[r], this.remoteStore.listen(o);\n                  }\n\n                  return [3, 7];\n\n                case 3:\n                  return !1 !== t || !1 === this.isPrimary ? [3, 7] : (this.isPrimary = !1, s = [], a = Promise.resolve(), hr(this.queryViewsByTarget, function (t, e) {\n                    c.sharedClientState.isLocalQueryTarget(t) ? s.push(t) : a = a.then(function () {\n                      return c.unlisten(e.query);\n                    }), c.remoteStore.unlisten(e.targetId);\n                  }), [4, a]);\n\n                case 4:\n                  return u.sent(), [4, this.synchronizeQueryViewsAndRaiseSnapshots(s)];\n\n                case 5:\n                  return u.sent(), this.resetLimboDocuments(), [4, this.remoteStore.applyPrimaryState(!1)];\n\n                case 6:\n                  u.sent(), u.label = 7;\n\n                case 7:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.resetLimboDocuments = function () {\n          var t = this;\n          hr(this.limboResolutionsByTarget, function (e) {\n            t.remoteStore.unlisten(e);\n          }), this.limboDocumentRefs.removeAllReferences(), this.limboResolutionsByTarget = [], this.limboTargetsByKey = new $r(Hr.comparator);\n        }, t.prototype.synchronizeQueryViewsAndRaiseSnapshots = function (t) {\n          for (var e = this, n = Promise.resolve(), r = [], i = [], o = function o(t) {\n            n = n.then(function () {\n              return a(e, void 0, void 0, function () {\n                var e, n, o, s;\n                return u(this, function (a) {\n                  switch (a.label) {\n                    case 0:\n                      return (n = this.queryViewsByTarget[t]) ? [4, this.localStore.releaseQuery(n.query, !0)] : [3, 4];\n\n                    case 1:\n                      return a.sent(), [4, this.localStore.allocateQuery(n.query)];\n\n                    case 2:\n                      return e = a.sent(), [4, this.synchronizeViewAndComputeSnapshot(n)];\n\n                    case 3:\n                      return (o = a.sent()).snapshot && i.push(o.snapshot), [3, 8];\n\n                    case 4:\n                      return nr(!0 === this.isPrimary, \"A secondary tab should never have an active query without an active view.\"), [4, this.localStore.getQueryForTarget(t)];\n\n                    case 5:\n                      return nr(!!(s = a.sent()), \"Query data for target \" + t + \" not found\"), [4, this.localStore.allocateQuery(s)];\n\n                    case 6:\n                      return e = a.sent(), [4, this.initializeViewAndComputeSnapshot(e, !1)];\n\n                    case 7:\n                      a.sent(), a.label = 8;\n\n                    case 8:\n                      return r.push(e), [2];\n                  }\n                });\n              });\n            });\n          }, s = 0, c = t; s < c.length; s++) {\n            o(c[s]);\n          }\n\n          return n.then(function () {\n            return e.syncEngineListener.onWatchChange(i), r;\n          });\n        }, t.prototype.getActiveClients = function () {\n          return this.localStore.getActiveClients();\n        }, t.prototype.applyTargetState = function (t, e, n) {\n          return a(this, void 0, void 0, function () {\n            var r,\n                i = this;\n            return u(this, function (o) {\n              switch (o.label) {\n                case 0:\n                  if (this.isPrimary) return Zn(\"SyncEngine\", \"Ignoring unexpected query state notification.\"), [2];\n                  if (!this.queryViewsByTarget[t]) return [3, 5];\n\n                  switch (e) {\n                    case \"current\":\n                    case \"not-current\":\n                      return [3, 1];\n\n                    case \"rejected\":\n                      return [3, 2];\n                  }\n\n                  return [3, 4];\n\n                case 1:\n                  return [2, this.localStore.getNewDocumentChanges().then(function (n) {\n                    return a(i, void 0, void 0, function () {\n                      var r;\n                      return u(this, function (i) {\n                        switch (i.label) {\n                          case 0:\n                            return r = To.createSynthesizedRemoteEventForCurrentChange(t, \"current\" === e), [4, this.emitNewSnapsAndNotifyLocalStore(n, r)];\n\n                          case 1:\n                            return i.sent(), [2];\n                        }\n                      });\n                    });\n                  }, function (t) {\n                    return a(i, void 0, void 0, function () {\n                      var e;\n                      return u(this, function (n) {\n                        switch (n.label) {\n                          case 0:\n                            return function (t) {\n                              return t.code === or.DATA_LOSS && t.message === Is;\n                            }(t) ? (e = [], hr(this.queryViewsByTarget, function (t) {\n                              return e.push(t);\n                            }), [4, this.synchronizeQueryViewsAndRaiseSnapshots(e)]) : [3, 2];\n\n                          case 1:\n                            return n.sent(), [3, 3];\n\n                          case 2:\n                            throw t;\n\n                          case 3:\n                            return [2];\n                        }\n                      });\n                    });\n                  })];\n\n                case 2:\n                  return r = this.queryViewsByTarget[t], this.removeAndCleanupQuery(r), [4, this.localStore.releaseQuery(r.query, !0)];\n\n                case 3:\n                  return o.sent(), this.syncEngineListener.onWatchError(r.query, n), [3, 5];\n\n                case 4:\n                  er(\"Unexpected target state: \" + e), o.label = 5;\n\n                case 5:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.applyActiveTargetsChange = function (t, e) {\n          return a(this, void 0, void 0, function () {\n            var n,\n                r,\n                i,\n                o,\n                s,\n                a,\n                c,\n                h,\n                l,\n                f = this;\n            return u(this, function (d) {\n              switch (d.label) {\n                case 0:\n                  if (!this.isPrimary) return [2];\n                  n = 0, r = t, d.label = 1;\n\n                case 1:\n                  return n < r.length ? (l = r[n], nr(!this.queryViewsByTarget[l], \"Trying to add an already active target\"), [4, this.localStore.getQueryForTarget(l)]) : [3, 6];\n\n                case 2:\n                  return nr(!!(i = d.sent()), \"Query data for active target \" + l + \" not found\"), [4, this.localStore.allocateQuery(i)];\n\n                case 3:\n                  return o = d.sent(), [4, this.initializeViewAndComputeSnapshot(o, !1)];\n\n                case 4:\n                  d.sent(), this.remoteStore.listen(o), d.label = 5;\n\n                case 5:\n                  return n++, [3, 1];\n\n                case 6:\n                  s = function s(t) {\n                    var e;\n                    return u(this, function (n) {\n                      switch (n.label) {\n                        case 0:\n                          return (e = a.queryViewsByTarget[t]) ? [4, a.localStore.releaseQuery(e.query, !1).then(function () {\n                            f.remoteStore.unlisten(t), f.removeAndCleanupQuery(e);\n                          }).catch(ya)] : [3, 2];\n\n                        case 1:\n                          n.sent(), n.label = 2;\n\n                        case 2:\n                          return [2];\n                      }\n                    });\n                  }, a = this, c = 0, h = e, d.label = 7;\n\n                case 7:\n                  return c < h.length ? (l = h[c], [5, s(l)]) : [3, 10];\n\n                case 8:\n                  d.sent(), d.label = 9;\n\n                case 9:\n                  return c++, [3, 7];\n\n                case 10:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.enableNetwork = function () {\n          return this.localStore.setNetworkEnabled(!0), this.remoteStore.enableNetwork();\n        }, t.prototype.disableNetwork = function () {\n          return this.localStore.setNetworkEnabled(!1), this.remoteStore.disableNetwork();\n        }, t.prototype.getRemoteKeysForTarget = function (t) {\n          var e = this.limboResolutionsByTarget[t];\n          return e && e.receivedDocument ? po().add(e.key) : this.queryViewsByTarget[t] ? this.queryViewsByTarget[t].view.syncedDocuments : po();\n        }, t;\n      }(),\n          ru = function () {\n        function t(t) {\n          this.uid = t;\n        }\n\n        return t.prototype.isAuthenticated = function () {\n          return null != this.uid;\n        }, t.prototype.toKey = function () {\n          return this.isAuthenticated() ? \"uid:\" + this.uid : \"anonymous-user\";\n        }, t.prototype.isEqual = function (t) {\n          return t.uid === this.uid;\n        }, t.UNAUTHENTICATED = new t(null), t.GOOGLE_CREDENTIALS = new t(\"google-credentials-uid\"), t.FIRST_PARTY = new t(\"first-party-uid\"), t;\n      }(),\n          iu = \"SharedClientState\",\n          ou = \"firestore_clients\",\n          su = \"firestore_mutations\",\n          au = \"firestore_targets\",\n          uu = \"firestore_online_state\",\n          cu = \"firestore_sequence_number\",\n          hu = function () {\n        function t(t, e, n, r) {\n          this.user = t, this.batchId = e, this.state = n, this.error = r, nr(void 0 !== r == (\"rejected\" === n), \"MutationMetadata must contain an error iff state is 'rejected'\");\n        }\n\n        return t.fromWebStorageEntry = function (e, n, r) {\n          var i = JSON.parse(r),\n              o = \"object\" == typeof i && -1 !== [\"pending\", \"acknowledged\", \"rejected\"].indexOf(i.state) && (void 0 === i.error || \"object\" == typeof i.error),\n              s = void 0;\n          return o && i.error && (o = \"string\" == typeof i.error.message && \"string\" == typeof i.error.code) && (s = new sr(i.error.code, i.error.message)), o ? new t(e, n, i.state, s) : ($n(iu, \"Failed to parse mutation state for ID '\" + n + \"': \" + r), null);\n        }, t.prototype.toWebStorageJSON = function () {\n          var t = {\n            state: this.state,\n            updateTimeMs: Date.now()\n          };\n          return this.error && (t.error = {\n            code: this.error.code,\n            message: this.error.message\n          }), JSON.stringify(t);\n        }, t;\n      }(),\n          lu = function () {\n        function t(t, e, n) {\n          this.targetId = t, this.state = e, this.error = n, nr(void 0 !== n == (\"rejected\" === e), \"QueryTargetMetadata must contain an error iff state is 'rejected'\");\n        }\n\n        return t.fromWebStorageEntry = function (e, n) {\n          var r = JSON.parse(n),\n              i = \"object\" == typeof r && -1 !== [\"not-current\", \"current\", \"rejected\"].indexOf(r.state) && (void 0 === r.error || \"object\" == typeof r.error),\n              o = void 0;\n          return i && r.error && (i = \"string\" == typeof r.error.message && \"string\" == typeof r.error.code) && (o = new sr(r.error.code, r.error.message)), i ? new t(e, r.state, o) : ($n(iu, \"Failed to parse target state for ID '\" + e + \"': \" + n), null);\n        }, t.prototype.toWebStorageJSON = function () {\n          var t = {\n            state: this.state,\n            updateTimeMs: Date.now()\n          };\n          return this.error && (t.error = {\n            code: this.error.code,\n            message: this.error.message\n          }), JSON.stringify(t);\n        }, t;\n      }(),\n          fu = function () {\n        function t(t, e) {\n          this.clientId = t, this.activeTargetIds = e;\n        }\n\n        return t.fromWebStorageEntry = function (e, n) {\n          for (var r = JSON.parse(n), i = \"object\" == typeof r && r.activeTargetIds instanceof Array, o = yo(), s = 0; i && s < r.activeTargetIds.length; ++s) {\n            i = Ii(r.activeTargetIds[s]), o = o.add(r.activeTargetIds[s]);\n          }\n\n          return i ? new t(e, o) : ($n(iu, \"Failed to parse client data for instance '\" + e + \"': \" + n), null);\n        }, t;\n      }(),\n          du = function () {\n        function t(t, e) {\n          this.clientId = t, this.onlineState = e;\n        }\n\n        return t.fromWebStorageEntry = function (e) {\n          var n = JSON.parse(e);\n          return \"object\" == typeof n && void 0 !== La[n.onlineState] && \"string\" == typeof n.clientId ? new t(n.clientId, La[n.onlineState]) : ($n(iu, \"Failed to parse online state: \" + e), null);\n        }, t;\n      }(),\n          pu = function () {\n        function t() {\n          this.activeTargetIds = yo();\n        }\n\n        return t.prototype.addQueryTarget = function (t) {\n          nr(!this.activeTargetIds.has(t), \"Target with ID '\" + t + \"' already active.\"), this.activeTargetIds = this.activeTargetIds.add(t);\n        }, t.prototype.removeQueryTarget = function (t) {\n          this.activeTargetIds = this.activeTargetIds.delete(t);\n        }, t.prototype.toWebStorageJSON = function () {\n          var t = {\n            activeTargetIds: this.activeTargetIds.toArray(),\n            updateTimeMs: Date.now()\n          };\n          return JSON.stringify(t);\n        }, t;\n      }(),\n          mu = function () {\n        function t(e, n, r, i, o) {\n          if (this.queue = e, this.platform = n, this.persistenceKey = r, this.localClientId = i, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.activeClients = {}, this.storageListener = this.handleWebStorageEvent.bind(this), this.started = !1, this.earlyEvents = [], !t.isAvailable(this.platform)) throw new sr(or.UNIMPLEMENTED, \"LocalStorage is not available on this platform.\");\n          var s = r.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n          this.storage = this.platform.window.localStorage, this.currentUser = o, this.localClientStorageKey = this.toWebStorageClientStateKey(this.localClientId), this.sequenceNumberKey = cu + \"_\" + r, this.activeClients[this.localClientId] = new pu(), this.clientStateKeyRe = new RegExp(\"^\" + ou + \"_\" + s + \"_([^_]*)$\"), this.mutationBatchKeyRe = new RegExp(\"^\" + su + \"_\" + s + \"_(\\\\d+)(?:_(.*))?$\"), this.queryTargetKeyRe = new RegExp(\"^\" + au + \"_\" + s + \"_(\\\\d+)$\"), this.onlineStateKey = uu + \"_\" + r, this.platform.window.addEventListener(\"storage\", this.storageListener);\n        }\n\n        return t.isAvailable = function (t) {\n          return !(!t.window || null == t.window.localStorage);\n        }, t.prototype.start = function () {\n          return a(this, void 0, void 0, function () {\n            var t,\n                e,\n                n,\n                r,\n                i,\n                o,\n                s,\n                a,\n                c,\n                h,\n                l,\n                f = this;\n            return u(this, function (u) {\n              switch (u.label) {\n                case 0:\n                  return nr(!this.started, \"WebStorageSharedClientState already started\"), nr(null !== this.syncEngine, \"syncEngine property must be set before calling start()\"), nr(null !== this.onlineStateHandler, \"onlineStateHandler property must be set before calling start()\"), [4, this.syncEngine.getActiveClients()];\n\n                case 1:\n                  for (t = u.sent(), e = 0, n = t; e < n.length; e++) {\n                    (r = n[e]) !== this.localClientId && (i = this.getItem(this.toWebStorageClientStateKey(r))) && (o = fu.fromWebStorageEntry(r, i)) && (this.activeClients[o.clientId] = o);\n                  }\n\n                  for (this.persistClientState(), (s = this.storage.getItem(this.onlineStateKey)) && (a = this.fromWebStorageOnlineState(s)) && this.handleOnlineStateEvent(a), c = 0, h = this.earlyEvents; c < h.length; c++) {\n                    l = h[c], this.handleWebStorageEvent(l);\n                  }\n\n                  return this.earlyEvents = [], this.platform.window.addEventListener(\"unload\", function () {\n                    return f.shutdown();\n                  }), this.started = !0, [2];\n              }\n            });\n          });\n        }, t.prototype.writeSequenceNumber = function (t) {\n          this.setItem(this.sequenceNumberKey, JSON.stringify(t));\n        }, t.prototype.getAllActiveQueryTargets = function () {\n          var t = yo();\n          return lr(this.activeClients, function (e, n) {\n            t = t.unionWith(n.activeTargetIds);\n          }), t;\n        }, t.prototype.isActiveQueryTarget = function (t) {\n          for (var e in this.activeClients) {\n            if (this.activeClients.hasOwnProperty(e) && this.activeClients[e].activeTargetIds.has(t)) return !0;\n          }\n\n          return !1;\n        }, t.prototype.addPendingMutation = function (t) {\n          this.persistMutationState(t, \"pending\");\n        }, t.prototype.updateMutationState = function (t, e, n) {\n          this.persistMutationState(t, e, n), this.removeMutationState(t);\n        }, t.prototype.addLocalQueryTarget = function (t) {\n          var e = \"not-current\";\n\n          if (this.isActiveQueryTarget(t)) {\n            var n = this.storage.getItem(this.toWebStorageQueryTargetMetadataKey(t));\n\n            if (n) {\n              var r = lu.fromWebStorageEntry(t, n);\n              r && (e = r.state);\n            }\n          }\n\n          return this.localClientState.addQueryTarget(t), this.persistClientState(), e;\n        }, t.prototype.removeLocalQueryTarget = function (t) {\n          this.localClientState.removeQueryTarget(t), this.persistClientState();\n        }, t.prototype.isLocalQueryTarget = function (t) {\n          return this.localClientState.activeTargetIds.has(t);\n        }, t.prototype.clearQueryState = function (t) {\n          this.removeItem(this.toWebStorageQueryTargetMetadataKey(t));\n        }, t.prototype.updateQueryState = function (t, e, n) {\n          this.persistQueryTargetState(t, e, n);\n        }, t.prototype.handleUserChange = function (t, e, n) {\n          var r = this;\n          e.forEach(function (t) {\n            r.removeMutationState(t);\n          }), this.currentUser = t, n.forEach(function (t) {\n            r.addPendingMutation(t);\n          });\n        }, t.prototype.setOnlineState = function (t) {\n          this.persistOnlineState(t);\n        }, t.prototype.shutdown = function () {\n          this.started && (this.platform.window.removeEventListener(\"storage\", this.storageListener), this.removeItem(this.localClientStorageKey), this.started = !1);\n        }, t.prototype.getItem = function (t) {\n          var e = this.storage.getItem(t);\n          return Zn(iu, \"READ\", t, e), e;\n        }, t.prototype.setItem = function (t, e) {\n          Zn(iu, \"SET\", t, e), this.storage.setItem(t, e);\n        }, t.prototype.removeItem = function (t) {\n          Zn(iu, \"REMOVE\", t), this.storage.removeItem(t);\n        }, t.prototype.handleWebStorageEvent = function (t) {\n          var e = this;\n\n          if (t.storageArea === this.storage) {\n            if (Zn(iu, \"EVENT\", t.key, t.newValue), t.key === this.localClientStorageKey) return void $n(\"Received WebStorage notification for local change. Another client might have garbage-collected our state\");\n            this.queue.enqueueAndForget(function () {\n              return a(e, void 0, void 0, function () {\n                var e, n, r, i, o, s;\n                return u(this, function (a) {\n                  if (!this.started) return this.earlyEvents.push(t), [2];\n                  if (null === t.key) return [2];\n\n                  if (this.clientStateKeyRe.test(t.key)) {\n                    if (null == t.newValue) return n = this.fromWebStorageClientStateKey(t.key), [2, this.handleClientStateEvent(n, null)];\n                    if (e = this.fromWebStorageClientState(t.key, t.newValue)) return [2, this.handleClientStateEvent(e.clientId, e)];\n                  } else if (this.mutationBatchKeyRe.test(t.key)) {\n                    if (null !== t.newValue && (r = this.fromWebStorageMutationMetadata(t.key, t.newValue))) return [2, this.handleMutationBatchEvent(r)];\n                  } else if (this.queryTargetKeyRe.test(t.key)) {\n                    if (null !== t.newValue && (i = this.fromWebStorageQueryTargetMetadata(t.key, t.newValue))) return [2, this.handleQueryTargetEvent(i)];\n                  } else if (t.key === this.onlineStateKey) {\n                    if (null !== t.newValue && (o = this.fromWebStorageOnlineState(t.newValue))) return [2, this.handleOnlineStateEvent(o)];\n                  } else t.key === this.sequenceNumberKey && (nr(!!this.sequenceNumberHandler, \"Missing sequenceNumberHandler\"), (s = function (t) {\n                    var e = Ho.INVALID;\n                    if (null != t) try {\n                      var n = JSON.parse(t);\n                      nr(\"number\" == typeof n, \"Found non-numeric sequence number\"), e = n;\n                    } catch (t) {\n                      $n(iu, \"Failed to read sequence number from WebStorage\", t);\n                    }\n                    return e;\n                  }(t.newValue)) !== Ho.INVALID && this.sequenceNumberHandler(s));\n\n                  return [2];\n                });\n              });\n            });\n          }\n        }, Object.defineProperty(t.prototype, \"localClientState\", {\n          get: function get() {\n            return this.activeClients[this.localClientId];\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.persistClientState = function () {\n          this.setItem(this.localClientStorageKey, this.localClientState.toWebStorageJSON());\n        }, t.prototype.persistMutationState = function (t, e, n) {\n          var r = new hu(this.currentUser, t, e, n),\n              i = this.toWebStorageMutationBatchKey(t);\n          this.setItem(i, r.toWebStorageJSON());\n        }, t.prototype.removeMutationState = function (t) {\n          var e = this.toWebStorageMutationBatchKey(t);\n          this.removeItem(e);\n        }, t.prototype.persistOnlineState = function (t) {\n          var e = {\n            clientId: this.localClientId,\n            onlineState: La[t]\n          };\n          this.storage.setItem(this.onlineStateKey, JSON.stringify(e));\n        }, t.prototype.persistQueryTargetState = function (t, e, n) {\n          var r = this.toWebStorageQueryTargetMetadataKey(t),\n              i = new lu(t, e, n);\n          this.setItem(r, i.toWebStorageJSON());\n        }, t.prototype.toWebStorageClientStateKey = function (t) {\n          return nr(-1 === t.indexOf(\"_\"), \"Client key cannot contain '_', but was '\" + t + \"'\"), ou + \"_\" + this.persistenceKey + \"_\" + t;\n        }, t.prototype.toWebStorageQueryTargetMetadataKey = function (t) {\n          return au + \"_\" + this.persistenceKey + \"_\" + t;\n        }, t.prototype.toWebStorageMutationBatchKey = function (t) {\n          var e = su + \"_\" + this.persistenceKey + \"_\" + t;\n          return this.currentUser.isAuthenticated() && (e += \"_\" + this.currentUser.uid), e;\n        }, t.prototype.fromWebStorageClientStateKey = function (t) {\n          var e = this.clientStateKeyRe.exec(t);\n          return e ? e[1] : null;\n        }, t.prototype.fromWebStorageClientState = function (t, e) {\n          var n = this.fromWebStorageClientStateKey(t);\n          return nr(null !== n, \"Cannot parse client state key '\" + t + \"'\"), fu.fromWebStorageEntry(n, e);\n        }, t.prototype.fromWebStorageMutationMetadata = function (t, e) {\n          var n = this.mutationBatchKeyRe.exec(t);\n          nr(null !== n, \"Cannot parse mutation batch key '\" + t + \"'\");\n          var r = Number(n[1]),\n              i = void 0 !== n[2] ? n[2] : null;\n          return hu.fromWebStorageEntry(new ru(i), r, e);\n        }, t.prototype.fromWebStorageQueryTargetMetadata = function (t, e) {\n          var n = this.queryTargetKeyRe.exec(t);\n          nr(null !== n, \"Cannot parse query target key '\" + t + \"'\");\n          var r = Number(n[1]);\n          return lu.fromWebStorageEntry(r, e);\n        }, t.prototype.fromWebStorageOnlineState = function (t) {\n          return du.fromWebStorageEntry(t);\n        }, t.prototype.handleMutationBatchEvent = function (t) {\n          return a(this, void 0, void 0, function () {\n            return u(this, function (e) {\n              return t.user.uid !== this.currentUser.uid ? (Zn(iu, \"Ignoring mutation for non-active user \" + t.user.uid), [2]) : [2, this.syncEngine.applyBatchState(t.batchId, t.state, t.error)];\n            });\n          });\n        }, t.prototype.handleQueryTargetEvent = function (t) {\n          return this.syncEngine.applyTargetState(t.targetId, t.state, t.error);\n        }, t.prototype.handleClientStateEvent = function (t, e) {\n          var n = this,\n              r = this.getAllActiveQueryTargets();\n          e ? this.activeClients[t] = e : delete this.activeClients[t];\n          var i = this.getAllActiveQueryTargets(),\n              o = [],\n              s = [];\n          return i.forEach(function (t) {\n            return a(n, void 0, void 0, function () {\n              return u(this, function (e) {\n                return r.has(t) || o.push(t), [2];\n              });\n            });\n          }), r.forEach(function (t) {\n            return a(n, void 0, void 0, function () {\n              return u(this, function (e) {\n                return i.has(t) || s.push(t), [2];\n              });\n            });\n          }), this.syncEngine.applyActiveTargetsChange(o, s);\n        }, t.prototype.handleOnlineStateEvent = function (t) {\n          this.activeClients[t.clientId] && this.onlineStateHandler(t.onlineState);\n        }, t;\n      }();\n\n      var yu = function () {\n        function t() {\n          this.localState = new pu(), this.queryState = {}, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null;\n        }\n\n        return t.prototype.addPendingMutation = function (t) {}, t.prototype.updateMutationState = function (t, e, n) {}, t.prototype.addLocalQueryTarget = function (t) {\n          return this.localState.addQueryTarget(t), this.queryState[t] || \"not-current\";\n        }, t.prototype.updateQueryState = function (t, e, n) {\n          this.queryState[t] = e;\n        }, t.prototype.removeLocalQueryTarget = function (t) {\n          this.localState.removeQueryTarget(t);\n        }, t.prototype.isLocalQueryTarget = function (t) {\n          return this.localState.activeTargetIds.has(t);\n        }, t.prototype.clearQueryState = function (t) {\n          delete this.queryState[t];\n        }, t.prototype.getAllActiveQueryTargets = function () {\n          return this.localState.activeTargetIds;\n        }, t.prototype.isActiveQueryTarget = function (t) {\n          return this.localState.activeTargetIds.has(t);\n        }, t.prototype.start = function () {\n          return this.localState = new pu(), Promise.resolve();\n        }, t.prototype.handleUserChange = function (t, e, n) {}, t.prototype.setOnlineState = function (t) {}, t.prototype.shutdown = function () {}, t.prototype.writeSequenceNumber = function (t) {}, t;\n      }(),\n          gu = function () {\n        function t(t, e) {\n          this.cacheSizeBytes = t, this.experimentalTabSynchronization = e;\n        }\n\n        return t.prototype.lruParams = function () {\n          return aa.withCacheSize(this.cacheSizeBytes);\n        }, t;\n      }(),\n          vu = function () {\n        return function () {};\n      }(),\n          bu = function () {\n        function t(t, e, n, r) {\n          this.platform = t, this.databaseInfo = e, this.credentials = n, this.asyncQueue = r, this.clientId = Rr.newId();\n        }\n\n        return t.prototype.start = function (t) {\n          var e = this,\n              n = new Xo(),\n              r = new Xo(),\n              i = !1;\n          return this.credentials.setChangeListener(function (o) {\n            i ? e.asyncQueue.enqueueAndForget(function () {\n              return e.handleCredentialChange(o);\n            }) : (i = !0, e.initializePersistence(t, r, o).then(function (t) {\n              return e.initializeRest(o, t);\n            }).then(n.resolve, n.reject));\n          }), this.asyncQueue.enqueueAndForget(function () {\n            return n.promise;\n          }), r.promise;\n        }, t.prototype.enableNetwork = function () {\n          var t = this;\n          return this.asyncQueue.enqueue(function () {\n            return t.syncEngine.enableNetwork();\n          });\n        }, t.prototype.initializePersistence = function (t, e, n) {\n          var r = this;\n          return t instanceof gu ? this.startIndexedDbPersistence(n, t).then(function (t) {\n            return e.resolve(), t;\n          }).catch(function (t) {\n            if (e.reject(t), !r.canFallback(t)) throw t;\n            return console.warn(\"Error enabling offline storage. Falling back to storage disabled: \" + t), r.startMemoryPersistence();\n          }) : (e.resolve(), this.startMemoryPersistence());\n        }, t.prototype.canFallback = function (t) {\n          return t instanceof sr ? t.code === or.FAILED_PRECONDITION || t.code === or.UNIMPLEMENTED : !(\"undefined\" != typeof DOMException && t instanceof DOMException) || 22 === t.code || 20 === t.code;\n        }, t.prototype.startIndexedDbPersistence = function (t, e) {\n          var n = this,\n              r = ma.buildStoragePrefix(this.databaseInfo),\n              i = new Bo(this.databaseInfo.databaseId, {\n            useProto3Json: !0\n          });\n          return Promise.resolve().then(function () {\n            return a(n, void 0, void 0, function () {\n              var n, o;\n              return u(this, function (s) {\n                switch (s.label) {\n                  case 0:\n                    if (e.experimentalTabSynchronization && !mu.isAvailable(this.platform)) throw new sr(or.UNIMPLEMENTED, \"IndexedDB persistence is only available on platforms that support LocalStorage.\");\n                    return o = e.lruParams(), e.experimentalTabSynchronization ? (this.sharedClientState = new mu(this.asyncQueue, this.platform, r, this.clientId, t), [4, ma.createMultiClientIndexedDbPersistence(r, this.clientId, this.platform, this.asyncQueue, i, o, {\n                      sequenceNumberSyncer: this.sharedClientState\n                    })]) : [3, 2];\n\n                  case 1:\n                    return n = s.sent(), [3, 4];\n\n                  case 2:\n                    return this.sharedClientState = new yu(), [4, ma.createIndexedDbPersistence(r, this.clientId, this.platform, this.asyncQueue, i, o)];\n\n                  case 3:\n                    n = s.sent(), s.label = 4;\n\n                  case 4:\n                    return this.persistence = n, [2, n.referenceDelegate.garbageCollector];\n                }\n              });\n            });\n          });\n        }, t.prototype.startMemoryPersistence = function () {\n          return this.persistence = Ra.createEagerPersistence(this.clientId), this.sharedClientState = new yu(), Promise.resolve(null);\n        }, t.prototype.initializeRest = function (t, e) {\n          var n = this;\n          return Zn(\"FirestoreClient\", \"Initializing. user=\", t.uid), this.platform.loadConnection(this.databaseInfo).then(function (r) {\n            return a(n, void 0, void 0, function () {\n              var n,\n                  i,\n                  o,\n                  s,\n                  c = this;\n              return u(this, function (h) {\n                switch (h.label) {\n                  case 0:\n                    return this.localStore = new Ia(this.persistence, t), e && (this.lruScheduler = new ua(e, this.asyncQueue, this.localStore)), n = this.platform.newSerializer(this.databaseInfo.databaseId), i = new Ka(this.asyncQueue, r, this.credentials, n), o = function o(t) {\n                      return c.syncEngine.applyOnlineStateChange(t, xa.RemoteStore);\n                    }, s = function s(t) {\n                      return c.syncEngine.applyOnlineStateChange(t, xa.SharedClientState);\n                    }, this.remoteStore = new za(this.localStore, i, this.asyncQueue, o), this.syncEngine = new nu(this.localStore, this.remoteStore, this.sharedClientState, t), this.sharedClientState.onlineStateHandler = s, this.remoteStore.syncEngine = this.syncEngine, this.sharedClientState.syncEngine = this.syncEngine, this.eventMgr = new Ha(this.syncEngine), [4, this.sharedClientState.start()];\n\n                  case 1:\n                    return h.sent(), [4, this.remoteStore.start()];\n\n                  case 2:\n                    return h.sent(), [4, this.persistence.setPrimaryStateListener(function (t) {\n                      return a(c, void 0, void 0, function () {\n                        return u(this, function (e) {\n                          switch (e.label) {\n                            case 0:\n                              return [4, this.syncEngine.applyPrimaryState(t)];\n\n                            case 1:\n                              return e.sent(), this.lruScheduler && (t && !this.lruScheduler.started ? this.lruScheduler.start() : t || this.lruScheduler.stop()), [2];\n                          }\n                        });\n                      });\n                    })];\n\n                  case 3:\n                    return h.sent(), [2];\n                }\n              });\n            });\n          });\n        }, t.prototype.handleCredentialChange = function (t) {\n          return this.asyncQueue.verifyOperationInProgress(), Zn(\"FirestoreClient\", \"Credential Changed. Current user: \" + t.uid), this.syncEngine.handleCredentialChange(t);\n        }, t.prototype.disableNetwork = function () {\n          var t = this;\n          return this.asyncQueue.enqueue(function () {\n            return t.syncEngine.disableNetwork();\n          });\n        }, t.prototype.shutdown = function (t) {\n          var e = this;\n          return this.asyncQueue.enqueue(function () {\n            return a(e, void 0, void 0, function () {\n              return u(this, function (e) {\n                switch (e.label) {\n                  case 0:\n                    return this.lruScheduler && this.lruScheduler.stop(), [4, this.remoteStore.shutdown()];\n\n                  case 1:\n                    return e.sent(), [4, this.sharedClientState.shutdown()];\n\n                  case 2:\n                    return e.sent(), [4, this.persistence.shutdown(t && t.purgePersistenceWithDataLoss)];\n\n                  case 3:\n                    return e.sent(), this.credentials.removeChangeListener(), [2];\n                }\n              });\n            });\n          });\n        }, t.prototype.listen = function (t, e, n) {\n          var r = this,\n              i = new Xa(t, e, n);\n          return this.asyncQueue.enqueueAndForget(function () {\n            return r.eventMgr.listen(i);\n          }), i;\n        }, t.prototype.unlisten = function (t) {\n          var e = this;\n          this.asyncQueue.enqueueAndForget(function () {\n            return e.eventMgr.unlisten(t);\n          });\n        }, t.prototype.getDocumentFromLocalCache = function (t) {\n          var e = this;\n          return this.asyncQueue.enqueue(function () {\n            return e.localStore.readDocument(t);\n          }).then(function (t) {\n            if (t instanceof Yr) return t;\n            if (t instanceof Jr) return null;\n            throw new sr(or.UNAVAILABLE, \"Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)\");\n          });\n        }, t.prototype.getDocumentsFromLocalCache = function (t) {\n          var e = this;\n          return this.asyncQueue.enqueue(function () {\n            return e.localStore.executeQuery(t);\n          }).then(function (e) {\n            var n = po(),\n                r = new $a(t, n),\n                i = r.computeDocChanges(e);\n            return r.applyChanges(i, !1).snapshot;\n          });\n        }, t.prototype.write = function (t) {\n          var e = this,\n              n = new Xo();\n          return this.asyncQueue.enqueueAndForget(function () {\n            return e.syncEngine.write(t, n);\n          }), n.promise;\n        }, t.prototype.databaseId = function () {\n          return this.databaseInfo.databaseId;\n        }, t.prototype.transaction = function (t) {\n          var e = this;\n          return this.asyncQueue.enqueue(function () {\n            return a(e, void 0, void 0, function () {\n              return u(this, function (t) {\n                return [2];\n              });\n            });\n          }).then(function () {\n            return e.syncEngine.runTransaction(t);\n          });\n        }, t;\n      }(),\n          wu = function () {\n        function t(t) {\n          this.observer = t, this.muted = !1;\n        }\n\n        return t.prototype.next = function (t) {\n          this.scheduleEvent(this.observer.next, t);\n        }, t.prototype.error = function (t) {\n          this.scheduleEvent(this.observer.error, t);\n        }, t.prototype.mute = function () {\n          this.muted = !0;\n        }, t.prototype.scheduleEvent = function (t, e) {\n          var n = this;\n          this.muted || setTimeout(function () {\n            n.muted || t(e);\n          }, 0);\n        }, t;\n      }(),\n          Eu = function () {\n        function t() {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          !function (t, e, n, r) {\n            if (!(e instanceof Array) || e.length < r) throw new sr(or.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + n + \" argument to be an array with at least \" + kr(r, \"element\") + \".\");\n          }(\"FieldPath\", t, \"fieldNames\", 1);\n\n          for (var n = 0; n < t.length; ++n) {\n            if (yr(\"FieldPath\", \"string\", n, t[n]), 0 === t[n].length) throw new sr(or.INVALID_ARGUMENT, \"Invalid field name at argument $(i + 1). Field names must not be empty.\");\n          }\n\n          this._internalPath = new Gr(t);\n        }\n\n        return t.documentId = function () {\n          return t._DOCUMENT_ID;\n        }, t.prototype.isEqual = function (e) {\n          if (!(e instanceof t)) throw Nr(\"isEqual\", \"FieldPath\", 1, e);\n          return this._internalPath.isEqual(e._internalPath);\n        }, t._DOCUMENT_ID = new t(Gr.keyField().canonicalString()), t;\n      }(),\n          Su = new RegExp(\"[~\\\\*/\\\\[\\\\]]\");\n\n      var Tu = function () {\n        return function (t, e) {\n          this.user = e, this.type = \"OAuth\", this.authHeaders = {\n            Authorization: \"Bearer \" + t\n          };\n        };\n      }(),\n          Iu = function () {\n        function t() {\n          this.changeListener = null;\n        }\n\n        return t.prototype.getToken = function () {\n          return Promise.resolve(null);\n        }, t.prototype.invalidateToken = function () {}, t.prototype.setChangeListener = function (t) {\n          nr(!this.changeListener, \"Can only call setChangeListener() once.\"), this.changeListener = t, t(ru.UNAUTHENTICATED);\n        }, t.prototype.removeChangeListener = function () {\n          nr(null !== this.changeListener, \"removeChangeListener() when no listener registered\"), this.changeListener = null;\n        }, t;\n      }(),\n          Cu = function () {\n        function t(t) {\n          var e = this;\n          this.app = t, this.tokenListener = null, this.tokenCounter = 0, this.changeListener = null, this.forceRefresh = !1, this.tokenListener = function () {\n            e.tokenCounter++, e.currentUser = e.getUser(), e.changeListener && e.changeListener(e.currentUser);\n          }, this.tokenCounter = 0, this.app.INTERNAL.addAuthTokenListener(this.tokenListener);\n        }\n\n        return t.prototype.getToken = function () {\n          var t = this;\n          nr(null != this.tokenListener, \"getToken cannot be called after listener removed.\");\n          var e = this.tokenCounter,\n              n = this.forceRefresh;\n          return this.forceRefresh = !1, this.app.INTERNAL.getToken(n).then(function (n) {\n            if (t.tokenCounter !== e) throw new sr(or.ABORTED, \"getToken aborted due to token change.\");\n            return n ? (nr(\"string\" == typeof n.accessToken, \"Invalid tokenData returned from getToken():\" + n), new Tu(n.accessToken, t.currentUser)) : null;\n          });\n        }, t.prototype.invalidateToken = function () {\n          this.forceRefresh = !0;\n        }, t.prototype.setChangeListener = function (t) {\n          nr(!this.changeListener, \"Can only call setChangeListener() once.\"), this.changeListener = t, this.currentUser && t(this.currentUser);\n        }, t.prototype.removeChangeListener = function () {\n          nr(null != this.tokenListener, \"removeChangeListener() called twice\"), nr(null !== this.changeListener, \"removeChangeListener() called when no listener registered\"), this.app.INTERNAL.removeAuthTokenListener(this.tokenListener), this.tokenListener = null, this.changeListener = null;\n        }, t.prototype.getUser = function () {\n          var t = this.app.INTERNAL.getUid();\n          return nr(null === t || \"string\" == typeof t, \"Received invalid UID: \" + t), new ru(t);\n        }, t;\n      }(),\n          Du = function () {\n        function t(t, e) {\n          this.gapi = t, this.sessionIndex = e, this.type = \"FirstParty\", this.user = ru.FIRST_PARTY, nr(this.gapi && this.gapi.auth && this.gapi.auth.getAuthHeaderValueForFirstParty, \"unexpected gapi interface\");\n        }\n\n        return Object.defineProperty(t.prototype, \"authHeaders\", {\n          get: function get() {\n            return {\n              Authorization: this.gapi.auth.getAuthHeaderValueForFirstParty([]),\n              \"X-Goog-AuthUser\": this.sessionIndex\n            };\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t;\n      }(),\n          Nu = function () {\n        function t(t, e) {\n          this.gapi = t, this.sessionIndex = e, nr(this.gapi && this.gapi.auth && this.gapi.auth.getAuthHeaderValueForFirstParty, \"unexpected gapi interface\");\n        }\n\n        return t.prototype.getToken = function () {\n          return Promise.resolve(new Du(this.gapi, this.sessionIndex));\n        }, t.prototype.setChangeListener = function (t) {\n          t(ru.FIRST_PARTY);\n        }, t.prototype.removeChangeListener = function () {}, t.prototype.invalidateToken = function () {}, t;\n      }();\n\n      function Au(t) {\n        return function (t, e) {\n          if (\"object\" != typeof t || null === t) return !1;\n\n          for (var n = t, r = 0, i = e; r < i.length; r++) {\n            var o = i[r];\n            if (o in n && \"function\" == typeof n[o]) return !0;\n          }\n\n          return !1;\n        }(t, [\"next\", \"error\", \"complete\"]);\n      }\n\n      var ku,\n          Ru = function () {\n        function t(t) {\n          this._methodName = t;\n        }\n\n        return t.delete = function () {\n          return Mu.instance;\n        }, t.serverTimestamp = function () {\n          return Ou.instance;\n        }, t.arrayUnion = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          return pr(\"FieldValue.arrayUnion\", arguments, 1), new _u(t);\n        }, t.arrayRemove = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          return pr(\"FieldValue.arrayRemove\", arguments, 1), new Pu(t);\n        }, t.prototype.isEqual = function (t) {\n          return this === t;\n        }, t;\n      }(),\n          Mu = function (t) {\n        function e() {\n          return t.call(this, \"FieldValue.delete\") || this;\n        }\n\n        return s(e, t), e.instance = new e(), e;\n      }(Ru),\n          Ou = function (t) {\n        function e() {\n          return t.call(this, \"FieldValue.serverTimestamp\") || this;\n        }\n\n        return s(e, t), e.instance = new e(), e;\n      }(Ru),\n          _u = function (t) {\n        function e(e) {\n          var n = t.call(this, \"FieldValue.arrayUnion\") || this;\n          return n._elements = e, n;\n        }\n\n        return s(e, t), e;\n      }(Ru),\n          Pu = function (t) {\n        function e(e) {\n          var n = t.call(this, \"FieldValue.arrayRemove\") || this;\n          return n._elements = e, n;\n        }\n\n        return s(e, t), e;\n      }(Ru),\n          Lu = ar(Ru, \"Use FieldValue.<field>() instead.\"),\n          xu = /^__.*__$/,\n          qu = function () {\n        function t(t, e, n) {\n          this.data = t, this.fieldMask = e, this.fieldTransforms = n;\n        }\n\n        return t.prototype.toMutations = function (t, e) {\n          var n = [];\n          return null !== this.fieldMask ? n.push(new Hi(t, this.data, this.fieldMask, e)) : n.push(new Gi(t, this.data, e)), this.fieldTransforms.length > 0 && n.push(new Xi(t, this.fieldTransforms)), n;\n        }, t;\n      }(),\n          Fu = function () {\n        function t(t, e, n) {\n          this.data = t, this.fieldMask = e, this.fieldTransforms = n;\n        }\n\n        return t.prototype.toMutations = function (t, e) {\n          var n = [new Hi(t, this.data, this.fieldMask, e)];\n          return this.fieldTransforms.length > 0 && n.push(new Xi(t, this.fieldTransforms)), n;\n        }, t;\n      }();\n\n      function Bu(t) {\n        switch (t) {\n          case ku.Set:\n          case ku.MergeSet:\n          case ku.Update:\n            return !0;\n\n          case ku.Argument:\n            return !1;\n\n          default:\n            throw er(\"Unexpected case for UserDataSource: \" + t);\n        }\n      }\n\n      !function (t) {\n        t[t.Set = 0] = \"Set\", t[t.Update = 1] = \"Update\", t[t.MergeSet = 2] = \"MergeSet\", t[t.Argument = 3] = \"Argument\";\n      }(ku || (ku = {}));\n\n      var Uu = function () {\n        function t(t, e, n, r, i, o) {\n          this.dataSource = t, this.methodName = e, this.path = n, this.arrayElement = r, void 0 === i && this.validatePath(), this.arrayElement = void 0 !== r && r, this.fieldTransforms = i || [], this.fieldMask = o || [];\n        }\n\n        return t.prototype.childContextForField = function (e) {\n          var n = null == this.path ? null : this.path.child(e),\n              r = new t(this.dataSource, this.methodName, n, !1, this.fieldTransforms, this.fieldMask);\n          return r.validatePathSegment(e), r;\n        }, t.prototype.childContextForFieldPath = function (e) {\n          var n = null == this.path ? null : this.path.child(e),\n              r = new t(this.dataSource, this.methodName, n, !1, this.fieldTransforms, this.fieldMask);\n          return r.validatePath(), r;\n        }, t.prototype.childContextForArray = function (e) {\n          return new t(this.dataSource, this.methodName, null, !0, this.fieldTransforms, this.fieldMask);\n        }, t.prototype.createError = function (t) {\n          var e = null === this.path || this.path.isEmpty() ? \"\" : \" (found in field \" + this.path.toString() + \")\";\n          return new sr(or.INVALID_ARGUMENT, \"Function \" + this.methodName + \"() called with invalid data. \" + t + e);\n        }, t.prototype.contains = function (t) {\n          return void 0 !== this.fieldMask.find(function (e) {\n            return t.isPrefixOf(e);\n          }) || void 0 !== this.fieldTransforms.find(function (e) {\n            return t.isPrefixOf(e.field);\n          });\n        }, t.prototype.validatePath = function () {\n          if (null !== this.path) for (var t = 0; t < this.path.length; t++) {\n            this.validatePathSegment(this.path.get(t));\n          }\n        }, t.prototype.validatePathSegment = function (t) {\n          if (Bu(this.dataSource) && xu.test(t)) throw this.createError(\"Document fields cannot begin and end with __\");\n        }, t;\n      }(),\n          Vu = function () {\n        return function (t, e) {\n          this.databaseId = t, this.key = e;\n        };\n      }(),\n          Qu = function () {\n        function t(t) {\n          this.preConverter = t;\n        }\n\n        return t.prototype.parseSetData = function (t, e) {\n          var n = new Uu(ku.Set, t, Gr.EMPTY_PATH);\n          Wu(\"Data must be an object, but it was:\", n, e);\n          var r = this.parseData(e, n);\n          return new qu(r, null, n.fieldTransforms);\n        }, t.prototype.parseMergeData = function (t, e, n) {\n          var r = new Uu(ku.MergeSet, t, Gr.EMPTY_PATH);\n          Wu(\"Data must be an object, but it was:\", r, e);\n          var i,\n              o,\n              s = this.parseData(e, r);\n\n          if (n) {\n            for (var a = new Ui(Gr.comparator), u = 0, c = n; u < c.length; u++) {\n              var h = c[u],\n                  l = void 0;\n              if (h instanceof Eu) l = h._internalPath;else {\n                if (\"string\" != typeof h) throw er(\"Expected stringOrFieldPath to be a string or a FieldPath\");\n                l = zu(t, h);\n              }\n              if (!r.contains(l)) throw new sr(or.INVALID_ARGUMENT, \"Field '\" + l + \"' is specified in your field mask but missing from your input data.\");\n              a = a.add(l);\n            }\n\n            i = Qi.fromSet(a), o = r.fieldTransforms.filter(function (t) {\n              return i.covers(t.field);\n            });\n          } else i = Qi.fromArray(r.fieldMask), o = r.fieldTransforms;\n\n          return new qu(s, i, o);\n        }, t.prototype.parseUpdateData = function (t, e) {\n          var n = this,\n              r = new Uu(ku.Update, t, Gr.EMPTY_PATH);\n          Wu(\"Data must be an object, but it was:\", r, e);\n          var i = new Ui(Gr.comparator),\n              o = gi.EMPTY;\n          lr(e, function (e, s) {\n            var a = zu(t, e),\n                u = r.childContextForFieldPath(a);\n            if ((s = n.runPreConverter(s, u)) instanceof Mu) i = i.add(a);else {\n              var c = n.parseData(s, u);\n              null != c && (i = i.add(a), o = o.set(a, c));\n            }\n          });\n          var s = Qi.fromSet(i);\n          return new Fu(o, s, r.fieldTransforms);\n        }, t.prototype.parseUpdateVarargs = function (t, e, n, r) {\n          var i = new Uu(ku.Update, t, Gr.EMPTY_PATH),\n              o = [ju(t, e)],\n              s = [n];\n          if (r.length % 2 != 0) throw new sr(or.INVALID_ARGUMENT, \"Function \" + t + \"() needs to be called with an even number of arguments that alternate between field names and values.\");\n\n          for (var a = 0; a < r.length; a += 2) {\n            o.push(ju(t, r[a])), s.push(r[a + 1]);\n          }\n\n          var u = new Ui(Gr.comparator),\n              c = gi.EMPTY;\n\n          for (a = 0; a < o.length; ++a) {\n            var h = o[a],\n                l = i.childContextForFieldPath(h),\n                f = this.runPreConverter(s[a], l);\n            if (f instanceof Mu) u = u.add(h);else {\n              var d = this.parseData(f, l);\n              null != d && (u = u.add(h), c = c.set(h, d));\n            }\n          }\n\n          var p = Qi.fromSet(u);\n          return new Fu(c, p, i.fieldTransforms);\n        }, t.prototype.parseQueryValue = function (t, e) {\n          var n = new Uu(ku.Argument, t, Gr.EMPTY_PATH),\n              r = this.parseData(e, n);\n          return nr(null != r, \"Parsed data should not be null.\"), nr(0 === n.fieldTransforms.length, \"Field transforms should have been disallowed.\"), r;\n        }, t.prototype.runPreConverter = function (t, e) {\n          try {\n            return this.preConverter(t);\n          } catch (t) {\n            var n = Gu(t);\n            throw e.createError(n);\n          }\n        }, t.prototype.parseData = function (t, e) {\n          if (Ku(t = this.runPreConverter(t, e))) return Wu(\"Unsupported field value:\", e, t), this.parseObject(t, e);\n          if (t instanceof Ru) return this.parseSentinelFieldValue(t, e), null;\n\n          if (e.path && e.fieldMask.push(e.path), t instanceof Array) {\n            if (e.arrayElement) throw e.createError(\"Nested arrays are not supported\");\n            return this.parseArray(t, e);\n          }\n\n          return this.parseScalarValue(t, e);\n        }, t.prototype.parseObject = function (t, e) {\n          var n = this,\n              r = new $r(Mr);\n          return fr(t) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : lr(t, function (t, i) {\n            var o = n.parseData(i, e.childContextForField(t));\n            null != o && (r = r.insert(t, o));\n          }), new gi(r);\n        }, t.prototype.parseArray = function (t, e) {\n          for (var n = [], r = 0, i = 0, o = t; i < o.length; i++) {\n            var s = o[i],\n                a = this.parseData(s, e.childContextForArray(r));\n            null == a && (a = oi.INSTANCE), n.push(a), r++;\n          }\n\n          return new vi(n);\n        }, t.prototype.parseSentinelFieldValue = function (t, e) {\n          if (!Bu(e.dataSource)) throw e.createError(t._methodName + \"() can only be used with update() and set()\");\n          if (null === e.path) throw e.createError(t._methodName + \"() is not currently supported inside arrays\");\n\n          if (t instanceof Mu) {\n            if (e.dataSource !== ku.MergeSet) throw e.dataSource === ku.Update ? (nr(e.path.length > 0, \"FieldValue.delete() at the top level should have already been handled.\"), e.createError(\"FieldValue.delete() can only appear at the top level of your update data\")) : e.createError(\"FieldValue.delete() cannot be used with set() unless you pass {merge:true}\");\n            e.fieldMask.push(e.path);\n          } else if (t instanceof Ou) e.fieldTransforms.push(new Ki(e.path, Ji.instance));else if (t instanceof _u) {\n            var n = this.parseArrayTransformElements(t._methodName, t._elements),\n                r = new Zi(n);\n            e.fieldTransforms.push(new Ki(e.path, r));\n          } else if (t instanceof Pu) {\n            n = this.parseArrayTransformElements(t._methodName, t._elements);\n            var i = new $i(n);\n            e.fieldTransforms.push(new Ki(e.path, i));\n          } else er(\"Unknown FieldValue type: \" + t);\n        }, t.prototype.parseScalarValue = function (t, e) {\n          if (null === t) return oi.INSTANCE;\n          if (\"number\" == typeof t) return Ii(t) ? new ci(t) : new hi(t);\n          if (\"boolean\" == typeof t) return si.of(t);\n          if (\"string\" == typeof t) return new li(t);\n          if (t instanceof Date) return new fi(Ur.fromDate(t));\n          if (t instanceof Ur) return new fi(new Ur(t.seconds, 1e3 * Math.floor(t.nanoseconds / 1e3)));\n          if (t instanceof Br) return new yi(t);\n          if (t instanceof qr) return new pi(t);\n          if (t instanceof Vu) return new mi(t.databaseId, t.key);\n          throw e.createError(\"Unsupported field value: \" + Ir(t));\n        }, t.prototype.parseArrayTransformElements = function (t, e) {\n          var n = this;\n          return e.map(function (e, r) {\n            var i = new Uu(ku.Argument, t, Gr.EMPTY_PATH);\n            return n.parseData(e, i.childContextForArray(r));\n          });\n        }, t;\n      }();\n\n      function Ku(t) {\n        return !(\"object\" != typeof t || null === t || t instanceof Array || t instanceof Date || t instanceof Ur || t instanceof Br || t instanceof qr || t instanceof Vu || t instanceof Ru);\n      }\n\n      function Wu(t, e, n) {\n        if (!Ku(n) || !Tr(n)) {\n          var r = Ir(n);\n          throw \"an object\" === r ? e.createError(t + \" a custom object\") : e.createError(t + \" \" + r);\n        }\n      }\n\n      function ju(t, e) {\n        if (e instanceof Eu) return e._internalPath;\n        if (\"string\" == typeof e) return zu(t, e);\n        throw new sr(or.INVALID_ARGUMENT, \"Function \" + t + \"() called with invalid data. Field path arguments must be of type string or FieldPath.\");\n      }\n\n      function zu(t, e) {\n        try {\n          return function (t) {\n            if (t.search(Su) >= 0) throw new sr(or.INVALID_ARGUMENT, \"Invalid field path (\" + t + \"). Paths must not contain '~', '*', '/', '[', or ']'\");\n\n            try {\n              return new (Eu.bind.apply(Eu, [void 0].concat(t.split(\".\"))))();\n            } catch (e) {\n              throw new sr(or.INVALID_ARGUMENT, \"Invalid field path (\" + t + \"). Paths must not be empty, begin with '.', end with '.', or contain '..'\");\n            }\n          }(e)._internalPath;\n        } catch (e) {\n          var n = Gu(e);\n          throw new sr(or.INVALID_ARGUMENT, \"Function \" + t + \"() called with invalid data. \" + n);\n        }\n      }\n\n      function Gu(t) {\n        return t instanceof Error ? t.message : t.toString();\n      }\n\n      var Hu = \"firestore.googleapis.com\",\n          Xu = !0,\n          Yu = !0,\n          Ju = aa.COLLECTION_DISABLED,\n          Zu = function () {\n        function t(t) {\n          if (void 0 === t.host) {\n            if (void 0 !== t.ssl) throw new sr(or.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\n            this.host = Hu, this.ssl = Xu;\n          } else vr(\"settings\", \"non-empty string\", \"host\", t.host), this.host = t.host, br(\"settings\", \"boolean\", \"ssl\", t.ssl), this.ssl = cr(t.ssl, Xu);\n\n          if (Dr(\"settings\", t, [\"host\", \"ssl\", \"credentials\", \"timestampsInSnapshots\", \"cacheSizeBytes\"]), br(\"settings\", \"object\", \"credentials\", t.credentials), this.credentials = t.credentials, br(\"settings\", \"boolean\", \"timestampsInSnapshots\", t.timestampsInSnapshots), !0 === t.timestampsInSnapshots ? $n(\"\\n  The timestampsInSnapshots setting now defaults to true and you no\\n  longer need to explicitly set it. In a future release, the setting\\n  will be removed entirely and so it is recommended that you remove it\\n  from your firestore.settings() call now.\") : !1 === t.timestampsInSnapshots && $n(\"\\n  The timestampsInSnapshots setting will soon be removed. YOU MUST UPDATE\\n  YOUR CODE.\\n\\n  To hide this warning, stop using the timestampsInSnapshots setting in your\\n  firestore.settings({ ... }) call.\\n\\n  Once you remove the setting, Timestamps stored in Cloud Firestore will be\\n  read back as Firebase Timestamp objects instead of as system Date objects.\\n  So you will also need to update code expecting a Date to instead expect a\\n  Timestamp. For example:\\n\\n  // Old:\\n  const date = snapshot.get('created_at');\\n  // New:\\n  const timestamp = snapshot.get('created_at'); const date =\\n  timestamp.toDate();\\n\\n  Please audit all existing usages of Date when you enable the new\\n  behavior.\"), this.timestampsInSnapshots = cr(t.timestampsInSnapshots, Yu), br(\"settings\", \"number\", \"cacheSizeBytes\", t.cacheSizeBytes), void 0 === t.cacheSizeBytes) this.cacheSizeBytes = aa.DEFAULT_CACHE_SIZE_BYTES;else {\n            if (t.cacheSizeBytes !== Ju && t.cacheSizeBytes < aa.MINIMUM_CACHE_SIZE_BYTES) throw new sr(or.INVALID_ARGUMENT, \"cacheSizeBytes must be at least \" + aa.MINIMUM_CACHE_SIZE_BYTES);\n            this.cacheSizeBytes = t.cacheSizeBytes;\n          }\n        }\n\n        return t.prototype.isEqual = function (t) {\n          return this.host === t.host && this.ssl === t.ssl && this.timestampsInSnapshots === t.timestampsInSnapshots && this.credentials === t.credentials && this.cacheSizeBytes === t.cacheSizeBytes;\n        }, t;\n      }(),\n          $u = function () {\n        return function () {};\n      }(),\n          tc = function () {\n        function t(e) {\n          var n = this;\n          this._queue = new Jo(), this.INTERNAL = {\n            delete: function _delete(t) {\n              return a(n, void 0, void 0, function () {\n                return u(this, function (e) {\n                  return this._firestoreClient ? [2, this._firestoreClient.shutdown(t)] : [2];\n                });\n              });\n            }\n          };\n          var r = new $u();\n\n          if (\"object\" == typeof e.options) {\n            var i = e;\n            r.firebaseApp = i, r.databaseId = t.databaseIdFromApp(i), r.persistenceKey = r.firebaseApp.name, r.credentials = new Cu(i);\n          } else {\n            var o = e;\n            if (!o.projectId) throw new sr(or.INVALID_ARGUMENT, \"Must provide projectId\");\n            r.databaseId = new Kr(o.projectId, o.database), r.persistenceKey = \"[DEFAULT]\", r.credentials = new Iu();\n          }\n\n          r.settings = new Zu({}), this._config = r, this._databaseId = r.databaseId;\n        }\n\n        return t.prototype.settings = function (t) {\n          if (dr(\"Firestore.settings\", arguments, 1), yr(\"Firestore.settings\", \"object\", 1, t), ur(t, \"persistence\")) throw new sr(or.INVALID_ARGUMENT, '\"persistence\" is now specified with a separate call to firestore.enablePersistence().');\n          var e = new Zu(t);\n          if (this._firestoreClient && !this._config.settings.isEqual(e)) throw new sr(or.FAILED_PRECONDITION, \"Firestore has already been started and its settings can no longer be changed. You can only call settings() before calling any other methods on a Firestore object.\");\n          this._config.settings = e, void 0 !== e.credentials && (this._config.credentials = function (t) {\n            if (!t) return new Iu();\n\n            switch (t.type) {\n              case \"gapi\":\n                return new Nu(t.client, t.sessionIndex || \"0\");\n\n              case \"provider\":\n                return t.client;\n\n              default:\n                throw new sr(or.INVALID_ARGUMENT, \"makeCredentialsProvider failed due to invalid credential type\");\n            }\n          }(e.credentials));\n        }, t.prototype.enableNetwork = function () {\n          return this.ensureClientConfigured(), this._firestoreClient.enableNetwork();\n        }, t.prototype.disableNetwork = function () {\n          return this.ensureClientConfigured(), this._firestoreClient.disableNetwork();\n        }, t.prototype.enablePersistence = function (t) {\n          if (this._firestoreClient) throw new sr(or.FAILED_PRECONDITION, \"Firestore has already been started and persistence can no longer be enabled. You can only call enablePersistence() before calling any other methods on a Firestore object.\");\n          return this.configureClient(new gu(this._config.settings.cacheSizeBytes, void 0 !== t && cr(t.experimentalTabSynchronization, !1)));\n        }, t.prototype.ensureClientConfigured = function () {\n          return this._firestoreClient || this.configureClient(new vu()), this._firestoreClient;\n        }, t.prototype.configureClient = function (t) {\n          var e = this;\n          nr(!!this._config.settings.host, \"FirestoreSettings.host cannot be falsey\"), nr(!this._firestoreClient, \"configureClient() called multiple times\");\n          var n = new Vr(this._config.databaseId, this._config.persistenceKey, this._config.settings.host, this._config.settings.ssl);\n          return this._dataConverter = new Qu(function (t) {\n            if (t instanceof rc) {\n              var n = e._config.databaseId,\n                  r = t.firestore._config.databaseId;\n              if (!r.isEqual(n)) throw new sr(or.INVALID_ARGUMENT, \"Document reference is for database \" + r.projectId + \"/\" + r.database + \" but should be for database \" + n.projectId + \"/\" + n.database);\n              return new Vu(e._config.databaseId, t._key);\n            }\n\n            return t;\n          }), this._firestoreClient = new bu(rr.getPlatform(), n, this._config.credentials, this._queue), this._firestoreClient.start(t);\n        }, t.databaseIdFromApp = function (t) {\n          var e = t.options;\n          if (!ur(e, \"projectId\")) throw new sr(or.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\n          var n = e.projectId;\n          if (!n || \"string\" != typeof n) throw new sr(or.INVALID_ARGUMENT, \"projectId must be a string in FirebaseApp.options\");\n          return new Kr(n);\n        }, Object.defineProperty(t.prototype, \"app\", {\n          get: function get() {\n            if (!this._config.firebaseApp) throw new sr(or.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is not available\");\n            return this._config.firebaseApp;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.collection = function (t) {\n          if (dr(\"Firestore.collection\", arguments, 1), yr(\"Firestore.collection\", \"non-empty string\", 1, t), !t) throw new sr(or.INVALID_ARGUMENT, \"Must provide a non-empty collection path to collection()\");\n          return this.ensureClientConfigured(), new cc(jr.fromString(t), this);\n        }, t.prototype.doc = function (t) {\n          if (dr(\"Firestore.doc\", arguments, 1), yr(\"Firestore.doc\", \"non-empty string\", 1, t), !t) throw new sr(or.INVALID_ARGUMENT, \"Must provide a non-empty document path to doc()\");\n          return this.ensureClientConfigured(), rc.forPath(jr.fromString(t), this);\n        }, t.prototype.runTransaction = function (t) {\n          var e = this;\n          return dr(\"Firestore.runTransaction\", arguments, 1), yr(\"Firestore.runTransaction\", \"function\", 1, t), this.ensureClientConfigured().transaction(function (n) {\n            return t(new ec(e, n));\n          });\n        }, t.prototype.batch = function () {\n          return this.ensureClientConfigured(), new nc(this);\n        }, Object.defineProperty(t, \"logLevel\", {\n          get: function get() {\n            switch (Yn()) {\n              case jn.DEBUG:\n                return \"debug\";\n\n              case jn.ERROR:\n                return \"error\";\n\n              case jn.SILENT:\n                return \"silent\";\n\n              default:\n                return er(\"Unknown log level: \" + Yn());\n            }\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.setLogLevel = function (t) {\n          switch (dr(\"Firestore.setLogLevel\", arguments, 1), yr(\"Firestore.setLogLevel\", \"non-empty string\", 1, t), t) {\n            case \"debug\":\n              Jn(jn.DEBUG);\n              break;\n\n            case \"error\":\n              Jn(jn.ERROR);\n              break;\n\n            case \"silent\":\n              Jn(jn.SILENT);\n              break;\n\n            default:\n              throw new sr(or.INVALID_ARGUMENT, \"Invalid log level: \" + t);\n          }\n        }, t.prototype._areTimestampsInSnapshotsEnabled = function () {\n          return this._config.settings.timestampsInSnapshots;\n        }, t;\n      }(),\n          ec = function () {\n        function t(t, e) {\n          this._firestore = t, this._transaction = e;\n        }\n\n        return t.prototype.get = function (t) {\n          var e = this;\n          dr(\"Transaction.get\", arguments, 1);\n          var n = dc(\"Transaction.get\", t, this._firestore);\n          return this._transaction.lookup([n._key]).then(function (t) {\n            if (!t || 1 !== t.length) return er(\"Mismatch in docs returned from document lookup.\");\n            var r = t[0];\n            if (r instanceof Jr) return new oc(e._firestore, n._key, null, !1, !1);\n            if (r instanceof Yr) return new oc(e._firestore, n._key, r, !1, !1);\n            throw er(\"BatchGetDocumentsRequest returned unexpected document type: \" + r.constructor.name);\n          });\n        }, t.prototype.set = function (t, e, n) {\n          mr(\"Transaction.set\", arguments, 2, 3);\n          var r = dc(\"Transaction.set\", t, this._firestore),\n              i = (n = hc(\"Transaction.set\", n)).merge || n.mergeFields ? this._firestore._dataConverter.parseMergeData(\"Transaction.set\", e, n.mergeFields) : this._firestore._dataConverter.parseSetData(\"Transaction.set\", e);\n          return this._transaction.set(r._key, i), this;\n        }, t.prototype.update = function (t, e, n) {\n          for (var r, i, o = [], s = 3; s < arguments.length; s++) {\n            o[s - 3] = arguments[s];\n          }\n\n          return \"string\" == typeof e || e instanceof Eu ? (pr(\"Transaction.update\", arguments, 3), r = dc(\"Transaction.update\", t, this._firestore), i = this._firestore._dataConverter.parseUpdateVarargs(\"Transaction.update\", e, n, o)) : (dr(\"Transaction.update\", arguments, 2), r = dc(\"Transaction.update\", t, this._firestore), i = this._firestore._dataConverter.parseUpdateData(\"Transaction.update\", e)), this._transaction.update(r._key, i), this;\n        }, t.prototype.delete = function (t) {\n          dr(\"Transaction.delete\", arguments, 1);\n          var e = dc(\"Transaction.delete\", t, this._firestore);\n          return this._transaction.delete(e._key), this;\n        }, t;\n      }(),\n          nc = function () {\n        function t(t) {\n          this._firestore = t, this._mutations = [], this._committed = !1;\n        }\n\n        return t.prototype.set = function (t, e, n) {\n          mr(\"WriteBatch.set\", arguments, 2, 3), this.verifyNotCommitted();\n          var r = dc(\"WriteBatch.set\", t, this._firestore),\n              i = (n = hc(\"WriteBatch.set\", n)).merge || n.mergeFields ? this._firestore._dataConverter.parseMergeData(\"WriteBatch.set\", e, n.mergeFields) : this._firestore._dataConverter.parseSetData(\"WriteBatch.set\", e);\n          return this._mutations = this._mutations.concat(i.toMutations(r._key, ji.NONE)), this;\n        }, t.prototype.update = function (t, e, n) {\n          for (var r, i, o = [], s = 3; s < arguments.length; s++) {\n            o[s - 3] = arguments[s];\n          }\n\n          return this.verifyNotCommitted(), \"string\" == typeof e || e instanceof Eu ? (pr(\"WriteBatch.update\", arguments, 3), r = dc(\"WriteBatch.update\", t, this._firestore), i = this._firestore._dataConverter.parseUpdateVarargs(\"WriteBatch.update\", e, n, o)) : (dr(\"WriteBatch.update\", arguments, 2), r = dc(\"WriteBatch.update\", t, this._firestore), i = this._firestore._dataConverter.parseUpdateData(\"WriteBatch.update\", e)), this._mutations = this._mutations.concat(i.toMutations(r._key, ji.exists(!0))), this;\n        }, t.prototype.delete = function (t) {\n          dr(\"WriteBatch.delete\", arguments, 1), this.verifyNotCommitted();\n          var e = dc(\"WriteBatch.delete\", t, this._firestore);\n          return this._mutations = this._mutations.concat(new Yi(e._key, ji.NONE)), this;\n        }, t.prototype.commit = function () {\n          return a(this, void 0, void 0, function () {\n            return u(this, function (t) {\n              return this.verifyNotCommitted(), this._committed = !0, this._mutations.length > 0 ? [2, this._firestore.ensureClientConfigured().write(this._mutations)] : [2];\n            });\n          });\n        }, t.prototype.verifyNotCommitted = function () {\n          if (this._committed) throw new sr(or.FAILED_PRECONDITION, \"A write batch can no longer be used after commit() has been called.\");\n        }, t;\n      }(),\n          rc = function () {\n        function t(t, e) {\n          this._key = t, this.firestore = e, this._firestoreClient = this.firestore.ensureClientConfigured();\n        }\n\n        return t.forPath = function (e, n) {\n          if (e.length % 2 != 0) throw new sr(or.INVALID_ARGUMENT, \"Invalid document reference. Document references must have an even number of segments, but \" + e.canonicalString() + \" has \" + e.length);\n          return new t(new Hr(e), n);\n        }, Object.defineProperty(t.prototype, \"id\", {\n          get: function get() {\n            return this._key.path.lastSegment();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"parent\", {\n          get: function get() {\n            return new cc(this._key.path.popLast(), this.firestore);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"path\", {\n          get: function get() {\n            return this._key.path.canonicalString();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.collection = function (t) {\n          if (dr(\"DocumentReference.collection\", arguments, 1), yr(\"DocumentReference.collection\", \"non-empty string\", 1, t), !t) throw new sr(or.INVALID_ARGUMENT, \"Must provide a non-empty collection name to collection()\");\n          var e = jr.fromString(t);\n          return new cc(this._key.path.child(e), this.firestore);\n        }, t.prototype.isEqual = function (e) {\n          if (!(e instanceof t)) throw Nr(\"isEqual\", \"DocumentReference\", 1, e);\n          return this.firestore === e.firestore && this._key.isEqual(e._key);\n        }, t.prototype.set = function (t, e) {\n          mr(\"DocumentReference.set\", arguments, 1, 2);\n          var n = (e = hc(\"DocumentReference.set\", e)).merge || e.mergeFields ? this.firestore._dataConverter.parseMergeData(\"DocumentReference.set\", t, e.mergeFields) : this.firestore._dataConverter.parseSetData(\"DocumentReference.set\", t);\n          return this._firestoreClient.write(n.toMutations(this._key, ji.NONE));\n        }, t.prototype.update = function (t, e) {\n          for (var n, r = [], i = 2; i < arguments.length; i++) {\n            r[i - 2] = arguments[i];\n          }\n\n          return \"string\" == typeof t || t instanceof Eu ? (pr(\"DocumentReference.update\", arguments, 2), n = this.firestore._dataConverter.parseUpdateVarargs(\"DocumentReference.update\", t, e, r)) : (dr(\"DocumentReference.update\", arguments, 1), n = this.firestore._dataConverter.parseUpdateData(\"DocumentReference.update\", t)), this._firestoreClient.write(n.toMutations(this._key, ji.exists(!0)));\n        }, t.prototype.delete = function () {\n          return dr(\"DocumentReference.delete\", arguments, 0), this._firestoreClient.write([new Yi(this._key, ji.NONE)]);\n        }, t.prototype.onSnapshot = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          mr(\"DocumentReference.onSnapshot\", arguments, 1, 4);\n          var n,\n              r = {\n            includeMetadataChanges: !1\n          },\n              i = 0;\n          \"object\" != typeof t[i] || Au(t[i]) || (Dr(\"DocumentReference.onSnapshot\", r = t[i], [\"includeMetadataChanges\"]), br(\"DocumentReference.onSnapshot\", \"boolean\", \"includeMetadataChanges\", r.includeMetadataChanges), i++);\n          var o = {\n            includeMetadataChanges: r.includeMetadataChanges\n          };\n          return Au(t[i]) ? n = t[i] : (yr(\"DocumentReference.onSnapshot\", \"function\", i, t[i]), gr(\"DocumentReference.onSnapshot\", \"function\", i + 1, t[i + 1]), gr(\"DocumentReference.onSnapshot\", \"function\", i + 2, t[i + 2]), n = {\n            next: t[i],\n            error: t[i + 1],\n            complete: t[i + 2]\n          }), this.onSnapshotInternal(o, n);\n        }, t.prototype.onSnapshotInternal = function (t, e) {\n          var n = this,\n              r = function r(t) {\n            console.error(\"Uncaught Error in onSnapshot:\", t);\n          };\n\n          e.error && (r = e.error.bind(e));\n\n          var i = new wu({\n            next: function next(t) {\n              if (e.next) {\n                nr(t.docs.size <= 1, \"Too many documents returned on a document query\");\n                var r = t.docs.get(n._key);\n                e.next(new oc(n.firestore, n._key, r, t.fromCache, t.hasPendingWrites));\n              }\n            },\n            error: r\n          }),\n              o = this._firestoreClient.listen(Di.atPath(this._key.path), i, t);\n\n          return function () {\n            i.mute(), n._firestoreClient.unlisten(o);\n          };\n        }, t.prototype.get = function (t) {\n          var e = this;\n          return mr(\"DocumentReference.get\", arguments, 0, 1), fc(\"DocumentReference.get\", t), new Promise(function (n, r) {\n            t && \"cache\" === t.source ? e.firestore.ensureClientConfigured().getDocumentFromLocalCache(e._key).then(function (t) {\n              n(new oc(e.firestore, e._key, t, !0, t instanceof Yr && t.hasLocalMutations));\n            }, r) : e.getViaSnapshotListener(n, r, t);\n          });\n        }, t.prototype.getViaSnapshotListener = function (t, e, n) {\n          var r = this.onSnapshotInternal({\n            includeMetadataChanges: !0,\n            waitForSyncWhenOnline: !0\n          }, {\n            next: function next(i) {\n              r(), !i.exists && i.metadata.fromCache ? e(new sr(or.UNAVAILABLE, \"Failed to get document because the client is offline.\")) : i.exists && i.metadata.fromCache && n && \"server\" === n.source ? e(new sr(or.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to \"server\" to retrieve the cached document.)')) : t(i);\n            },\n            error: e\n          });\n        }, t;\n      }(),\n          ic = function () {\n        function t(t, e) {\n          this.hasPendingWrites = t, this.fromCache = e;\n        }\n\n        return t.prototype.isEqual = function (t) {\n          return this.hasPendingWrites === t.hasPendingWrites && this.fromCache === t.fromCache;\n        }, t;\n      }(),\n          oc = function () {\n        function t(t, e, n, r, i) {\n          this._firestore = t, this._key = e, this._document = n, this._fromCache = r, this._hasPendingWrites = i;\n        }\n\n        return t.prototype.data = function (t) {\n          return mr(\"DocumentSnapshot.data\", arguments, 0, 1), t = lc(\"DocumentSnapshot.data\", t), this._document ? this.convertObject(this._document.data, ri.fromSnapshotOptions(t, this._firestore._areTimestampsInSnapshotsEnabled())) : void 0;\n        }, t.prototype.get = function (t, e) {\n          if (mr(\"DocumentSnapshot.get\", arguments, 1, 2), e = lc(\"DocumentSnapshot.get\", e), this._document) {\n            var n = this._document.data.field(ju(\"DocumentSnapshot.get\", t));\n\n            if (void 0 !== n) return this.convertValue(n, ri.fromSnapshotOptions(e, this._firestore._areTimestampsInSnapshotsEnabled()));\n          }\n        }, Object.defineProperty(t.prototype, \"id\", {\n          get: function get() {\n            return this._key.path.lastSegment();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"ref\", {\n          get: function get() {\n            return new rc(this._key, this._firestore);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"exists\", {\n          get: function get() {\n            return null !== this._document;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"metadata\", {\n          get: function get() {\n            return new ic(this._hasPendingWrites, this._fromCache);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.isEqual = function (e) {\n          if (!(e instanceof t)) throw Nr(\"isEqual\", \"DocumentSnapshot\", 1, e);\n          return this._firestore === e._firestore && this._fromCache === e._fromCache && this._key.isEqual(e._key) && (null === this._document ? null === e._document : this._document.isEqual(e._document));\n        }, t.prototype.convertObject = function (t, e) {\n          var n = this,\n              r = {};\n          return t.forEach(function (t, i) {\n            r[t] = n.convertValue(i, e);\n          }), r;\n        }, t.prototype.convertValue = function (t, e) {\n          if (t instanceof gi) return this.convertObject(t, e);\n          if (t instanceof vi) return this.convertArray(t, e);\n\n          if (t instanceof mi) {\n            var n = t.value(e),\n                r = this._firestore.ensureClientConfigured().databaseId();\n\n            return t.databaseId.isEqual(r) || $n(\"Document \" + this._key.path + \" contains a document reference within a different database (\" + t.databaseId.projectId + \"/\" + t.databaseId.database + \") which is not supported. It will be treated as a reference in the current database (\" + r.projectId + \"/\" + r.database + \") instead.\"), new rc(n, this._firestore);\n          }\n\n          return t.value(e);\n        }, t.prototype.convertArray = function (t, e) {\n          var n = this;\n          return t.internalValue.map(function (t) {\n            return n.convertValue(t, e);\n          });\n        }, t;\n      }(),\n          sc = function (t) {\n        function e(e, n, r, i, o) {\n          return t.call(this, e, n, r, i, o) || this;\n        }\n\n        return s(e, t), e.prototype.data = function (e) {\n          var n = t.prototype.data.call(this, e);\n          return nr(\"object\" == typeof n, \"Document in a QueryDocumentSnapshot should exist\"), n;\n        }, e;\n      }(oc),\n          ac = function () {\n        function t(t, e) {\n          this._query = t, this.firestore = e;\n        }\n\n        return t.prototype.where = function (e, n, r) {\n          var i;\n          dr(\"Query.where\", arguments, 3), yr(\"Query.where\", \"non-empty string\", 2, n), Cr(\"Query.where\", 3, r);\n          var o = ju(\"Query.where\", e),\n              s = Ai.fromString(n);\n\n          if (o.isKeyField()) {\n            if (s === Ai.ARRAY_CONTAINS) throw new sr(or.INVALID_ARGUMENT, \"Invalid Query. You can't perform array-contains queries on FieldPath.documentId() since document IDs are not arrays.\");\n\n            if (\"string\" == typeof r) {\n              if (-1 !== r.indexOf(\"/\")) throw new sr(or.INVALID_ARGUMENT, \"Function Query.where() requires its third parameter to be a valid document ID if the first parameter is FieldPath.documentId(), but it contains a slash.\");\n              if (\"\" === r) throw new sr(or.INVALID_ARGUMENT, \"Function Query.where() requires its third parameter to be a valid document ID if the first parameter is FieldPath.documentId(), but it was an empty string.\");\n\n              var a = this._query.path.child(new jr([r]));\n\n              nr(a.length % 2 == 0, \"Path should be a document key\"), i = new mi(this.firestore._databaseId, new Hr(a));\n            } else {\n              if (!(r instanceof rc)) throw new sr(or.INVALID_ARGUMENT, \"Function Query.where() requires its third parameter to be a string or a DocumentReference if the first parameter is FieldPath.documentId(), but it was: \" + Ir(r) + \".\");\n              var u = r;\n              i = new mi(this.firestore._databaseId, u._key);\n            }\n          } else i = this.firestore._dataConverter.parseQueryValue(\"Query.where\", r);\n\n          var c = Ni.create(o, s, i);\n          return this.validateNewFilter(c), new t(this._query.addFilter(c), this.firestore);\n        }, t.prototype.orderBy = function (e, n) {\n          var r;\n          if (mr(\"Query.orderBy\", arguments, 1, 2), gr(\"Query.orderBy\", \"non-empty string\", 2, n), void 0 === n || \"asc\" === n) r = Oi.ASCENDING;else {\n            if (\"desc\" !== n) throw new sr(or.INVALID_ARGUMENT, \"Function Query.orderBy() has unknown direction '\" + n + \"', expected 'asc' or 'desc'.\");\n            r = Oi.DESCENDING;\n          }\n          if (null !== this._query.startAt) throw new sr(or.INVALID_ARGUMENT, \"Invalid query. You must not call Query.startAt() or Query.startAfter() before calling Query.orderBy().\");\n          if (null !== this._query.endAt) throw new sr(or.INVALID_ARGUMENT, \"Invalid query. You must not call Query.endAt() or Query.endBefore() before calling Query.orderBy().\");\n          var i = ju(\"Query.orderBy\", e),\n              o = new Pi(i, r);\n          return this.validateNewOrderBy(o), new t(this._query.addOrderBy(o), this.firestore);\n        }, t.prototype.limit = function (e) {\n          if (dr(\"Query.limit\", arguments, 1), yr(\"Query.limit\", \"number\", 1, e), e <= 0) throw new sr(or.INVALID_ARGUMENT, \"Invalid Query. Query limit (\" + e + \") is invalid. Limit must be positive.\");\n          return new t(this._query.withLimit(e), this.firestore);\n        }, t.prototype.startAt = function (e) {\n          for (var n = [], r = 1; r < arguments.length; r++) {\n            n[r - 1] = arguments[r];\n          }\n\n          pr(\"Query.startAt\", arguments, 1);\n          var i = this.boundFromDocOrFields(\"Query.startAt\", e, n, !0);\n          return new t(this._query.withStartAt(i), this.firestore);\n        }, t.prototype.startAfter = function (e) {\n          for (var n = [], r = 1; r < arguments.length; r++) {\n            n[r - 1] = arguments[r];\n          }\n\n          pr(\"Query.startAfter\", arguments, 1);\n          var i = this.boundFromDocOrFields(\"Query.startAfter\", e, n, !1);\n          return new t(this._query.withStartAt(i), this.firestore);\n        }, t.prototype.endBefore = function (e) {\n          for (var n = [], r = 1; r < arguments.length; r++) {\n            n[r - 1] = arguments[r];\n          }\n\n          pr(\"Query.endBefore\", arguments, 1);\n          var i = this.boundFromDocOrFields(\"Query.endBefore\", e, n, !0);\n          return new t(this._query.withEndAt(i), this.firestore);\n        }, t.prototype.endAt = function (e) {\n          for (var n = [], r = 1; r < arguments.length; r++) {\n            n[r - 1] = arguments[r];\n          }\n\n          pr(\"Query.endAt\", arguments, 1);\n          var i = this.boundFromDocOrFields(\"Query.endAt\", e, n, !1);\n          return new t(this._query.withEndAt(i), this.firestore);\n        }, t.prototype.isEqual = function (e) {\n          if (!(e instanceof t)) throw Nr(\"isEqual\", \"Query\", 1, e);\n          return this.firestore === e.firestore && this._query.isEqual(e._query);\n        }, t.prototype.boundFromDocOrFields = function (t, e, n, r) {\n          if (Cr(t, 1, e), e instanceof oc) {\n            if (n.length > 0) throw new sr(or.INVALID_ARGUMENT, \"Too many arguments provided to \" + t + \"().\");\n            var i = e;\n            if (!i.exists) throw new sr(or.NOT_FOUND, \"Can't use a DocumentSnapshot that doesn't exist for \" + t + \"().\");\n            return this.boundFromDocument(t, i._document, r);\n          }\n\n          var o = [e].concat(n);\n          return this.boundFromFields(t, o, r);\n        }, t.prototype.boundFromDocument = function (t, e, n) {\n          for (var r = [], i = 0, o = this._query.orderBy; i < o.length; i++) {\n            var s = o[i];\n            if (s.field.isKeyField()) r.push(new mi(this.firestore._databaseId, e.key));else {\n              var a = e.field(s.field);\n\n              if (void 0 === a) {\n                var u = s.field.canonicalString();\n                throw new sr(or.INVALID_ARGUMENT, \"Invalid query. You are trying to start or end a query using a document for which the field '\" + u + \"' (used as the orderBy) does not exist.\");\n              }\n\n              r.push(a);\n            }\n          }\n\n          return new _i(r, n);\n        }, t.prototype.boundFromFields = function (t, e, n) {\n          var r = this._query.explicitOrderBy;\n          if (e.length > r.length) throw new sr(or.INVALID_ARGUMENT, \"Too many arguments provided to \" + t + \"(). The number of arguments must be less than or equal to the number of Query.orderBy() clauses\");\n\n          for (var i = [], o = 0; o < e.length; o++) {\n            var s = e[o];\n\n            if (r[o].field.isKeyField()) {\n              if (\"string\" != typeof s) throw new sr(or.INVALID_ARGUMENT, \"Invalid query. Expected a string for document ID in \" + t + \"(), but got a \" + typeof s);\n              if (-1 !== s.indexOf(\"/\")) throw new sr(or.INVALID_ARGUMENT, \"Invalid query. Document ID '\" + s + \"' contains a slash in \" + t + \"()\");\n              var a = new Hr(this._query.path.child(s));\n              i.push(new mi(this.firestore._databaseId, a));\n            } else {\n              var u = this.firestore._dataConverter.parseQueryValue(t, s);\n\n              i.push(u);\n            }\n          }\n\n          return new _i(i, n);\n        }, t.prototype.onSnapshot = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          mr(\"Query.onSnapshot\", arguments, 1, 4);\n          var n,\n              r = {},\n              i = 0;\n          return \"object\" != typeof t[i] || Au(t[i]) || (Dr(\"Query.onSnapshot\", r = t[i], [\"includeMetadataChanges\"]), br(\"Query.onSnapshot\", \"boolean\", \"includeMetadataChanges\", r.includeMetadataChanges), i++), Au(t[i]) ? n = t[i] : (yr(\"Query.onSnapshot\", \"function\", i, t[i]), gr(\"Query.onSnapshot\", \"function\", i + 1, t[i + 1]), gr(\"Query.onSnapshot\", \"function\", i + 2, t[i + 2]), n = {\n            next: t[i],\n            error: t[i + 1],\n            complete: t[i + 2]\n          }), this.onSnapshotInternal(r, n);\n        }, t.prototype.onSnapshotInternal = function (t, e) {\n          var n = this,\n              r = function r(t) {\n            console.error(\"Uncaught Error in onSnapshot:\", t);\n          };\n\n          e.error && (r = e.error.bind(e));\n          var i = new wu({\n            next: function next(t) {\n              e.next && e.next(new uc(n.firestore, n._query, t));\n            },\n            error: r\n          }),\n              o = this.firestore.ensureClientConfigured(),\n              s = o.listen(this._query, i, t);\n          return function () {\n            i.mute(), o.unlisten(s);\n          };\n        }, t.prototype.get = function (t) {\n          var e = this;\n          return mr(\"Query.get\", arguments, 0, 1), fc(\"Query.get\", t), new Promise(function (n, r) {\n            t && \"cache\" === t.source ? e.firestore.ensureClientConfigured().getDocumentsFromLocalCache(e._query).then(function (t) {\n              n(new uc(e.firestore, e._query, t));\n            }, r) : e.getViaSnapshotListener(n, r, t);\n          });\n        }, t.prototype.getViaSnapshotListener = function (t, e, n) {\n          var r = this.onSnapshotInternal({\n            includeMetadataChanges: !0,\n            waitForSyncWhenOnline: !0\n          }, {\n            next: function next(i) {\n              r(), i.metadata.fromCache && n && \"server\" === n.source ? e(new sr(or.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to \"server\" to retrieve the cached documents.)')) : t(i);\n            },\n            error: e\n          });\n        }, t.prototype.validateNewFilter = function (t) {\n          if (t instanceof ki) if (t.isInequality()) {\n            var e = this._query.getInequalityFilterField();\n\n            if (null !== e && !e.isEqual(t.field)) throw new sr(or.INVALID_ARGUMENT, \"Invalid query. All where filters with an inequality (<, <=, >, or >=) must be on the same field. But you have inequality filters on '\" + e.toString() + \"' and '\" + t.field.toString() + \"'\");\n\n            var n = this._query.getFirstOrderByField();\n\n            null !== n && this.validateOrderByAndInequalityMatch(t.field, n);\n          } else if (t.op === Ai.ARRAY_CONTAINS && this._query.hasArrayContainsFilter()) throw new sr(or.INVALID_ARGUMENT, \"Invalid query. Queries only support a single array-contains filter.\");\n        }, t.prototype.validateNewOrderBy = function (t) {\n          if (null === this._query.getFirstOrderByField()) {\n            var e = this._query.getInequalityFilterField();\n\n            null !== e && this.validateOrderByAndInequalityMatch(e, t.field);\n          }\n        }, t.prototype.validateOrderByAndInequalityMatch = function (t, e) {\n          if (!e.isEqual(t)) throw new sr(or.INVALID_ARGUMENT, \"Invalid query. You have a where filter with an inequality (<, <=, >, or >=) on field '\" + t.toString() + \"' and so you must also use '\" + t.toString() + \"' as your first Query.orderBy(), but your first Query.orderBy() is on field '\" + e.toString() + \"' instead.\");\n        }, t;\n      }(),\n          uc = function () {\n        function t(t, e, n) {\n          this._firestore = t, this._originalQuery = e, this._snapshot = n, this._cachedChanges = null, this._cachedChangesIncludeMetadataChanges = null, this.metadata = new ic(n.hasPendingWrites, n.fromCache);\n        }\n\n        return Object.defineProperty(t.prototype, \"docs\", {\n          get: function get() {\n            var t = [];\n            return this.forEach(function (e) {\n              return t.push(e);\n            }), t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"empty\", {\n          get: function get() {\n            return this._snapshot.docs.isEmpty();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"size\", {\n          get: function get() {\n            return this._snapshot.docs.size;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.forEach = function (t, e) {\n          var n = this;\n          mr(\"QuerySnapshot.forEach\", arguments, 1, 2), yr(\"QuerySnapshot.forEach\", \"function\", 1, t), this._snapshot.docs.forEach(function (r) {\n            t.call(e, n.convertToDocumentImpl(r));\n          });\n        }, Object.defineProperty(t.prototype, \"query\", {\n          get: function get() {\n            return new ac(this._originalQuery, this._firestore);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.docChanges = function (t) {\n          t && (Dr(\"QuerySnapshot.docChanges\", t, [\"includeMetadataChanges\"]), br(\"QuerySnapshot.docChanges\", \"boolean\", \"includeMetadataChanges\", t.includeMetadataChanges));\n          var e = !(!t || !t.includeMetadataChanges);\n          if (e && this._snapshot.excludesMetadataChanges) throw new sr(or.INVALID_ARGUMENT, \"To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().\");\n          return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function (t, e, n) {\n            if (n.oldDocs.isEmpty()) {\n              var r,\n                  i = 0;\n              return n.docChanges.map(function (e) {\n                var o = new sc(t, e.doc.key, e.doc, n.fromCache, n.mutatedKeys.has(e.doc.key));\n                return nr(e.type === go.Added, \"Invalid event type for first snapshot\"), nr(!r || n.query.docComparator(r, e.doc) < 0, \"Got added events in wrong order\"), r = e.doc, {\n                  type: \"added\",\n                  doc: o,\n                  oldIndex: -1,\n                  newIndex: i++\n                };\n              });\n            }\n\n            var o = n.oldDocs;\n            return n.docChanges.filter(function (t) {\n              return e || t.type !== go.Metadata;\n            }).map(function (e) {\n              var r = new sc(t, e.doc.key, e.doc, n.fromCache, n.mutatedKeys.has(e.doc.key)),\n                  i = -1,\n                  s = -1;\n              return e.type !== go.Added && (nr((i = o.indexOf(e.doc.key)) >= 0, \"Index for document not found\"), o = o.delete(e.doc.key)), e.type !== go.Removed && (o = o.add(e.doc), s = o.indexOf(e.doc.key)), {\n                type: function (t) {\n                  switch (t) {\n                    case go.Added:\n                      return \"added\";\n\n                    case go.Modified:\n                    case go.Metadata:\n                      return \"modified\";\n\n                    case go.Removed:\n                      return \"removed\";\n\n                    default:\n                      return er(\"Unknown change type: \" + t);\n                  }\n                }(e.type),\n                doc: r,\n                oldIndex: i,\n                newIndex: s\n              };\n            });\n          }(this._firestore, e, this._snapshot), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;\n        }, t.prototype.isEqual = function (e) {\n          if (!(e instanceof t)) throw Nr(\"isEqual\", \"QuerySnapshot\", 1, e);\n          return this._firestore === e._firestore && this._originalQuery.isEqual(e._originalQuery) && this._snapshot.isEqual(e._snapshot);\n        }, t.prototype.convertToDocumentImpl = function (t) {\n          return new sc(this._firestore, t.key, t, this.metadata.fromCache, this._snapshot.mutatedKeys.has(t.key));\n        }, t;\n      }();\n\n      [\"length\", \"forEach\", \"map\"].concat(\"undefined\" != typeof Symbol ? [Symbol.iterator] : []).forEach(function (t) {\n        try {\n          Object.defineProperty(uc.prototype.docChanges, t, {\n            get: function get() {\n              return function () {\n                throw new sr(or.INVALID_ARGUMENT, 'QuerySnapshot.docChanges has been changed from a property into a method, so usages like \"querySnapshot.docChanges\" should become \"querySnapshot.docChanges()\"');\n              }();\n            }\n          });\n        } catch (t) {}\n      });\n\n      var cc = function (t) {\n        function e(e, n) {\n          var r = t.call(this, Di.atPath(e), n) || this;\n          if (e.length % 2 != 1) throw new sr(or.INVALID_ARGUMENT, \"Invalid collection reference. Collection references must have an odd number of segments, but \" + e.canonicalString() + \" has \" + e.length);\n          return r;\n        }\n\n        return s(e, t), Object.defineProperty(e.prototype, \"id\", {\n          get: function get() {\n            return this._query.path.lastSegment();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"parent\", {\n          get: function get() {\n            var t = this._query.path.popLast();\n\n            return t.isEmpty() ? null : new rc(new Hr(t), this.firestore);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"path\", {\n          get: function get() {\n            return this._query.path.canonicalString();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.doc = function (t) {\n          if (mr(\"CollectionReference.doc\", arguments, 0, 1), 0 === arguments.length && (t = Rr.newId()), yr(\"CollectionReference.doc\", \"non-empty string\", 1, t), \"\" === t) throw new sr(or.INVALID_ARGUMENT, \"Document path must be a non-empty string\");\n          var e = jr.fromString(t);\n          return rc.forPath(this._query.path.child(e), this.firestore);\n        }, e.prototype.add = function (t) {\n          dr(\"CollectionReference.add\", arguments, 1), yr(\"CollectionReference.add\", \"object\", 1, t);\n          var e = this.doc();\n          return e.set(t).then(function () {\n            return e;\n          });\n        }, e;\n      }(ac);\n\n      function hc(t, e) {\n        if (void 0 === e) return {\n          merge: !1\n        };\n        if (Dr(t, e, [\"merge\", \"mergeFields\"]), br(t, \"boolean\", \"merge\", e.merge), wr(t, \"mergeFields\", \"a string or a FieldPath\", e.mergeFields, function (t) {\n          return \"string\" == typeof t || t instanceof Eu;\n        }), void 0 !== e.mergeFields && void 0 !== e.merge) throw new sr(or.INVALID_ARGUMENT, \"Invalid options passed to function \" + t + '(): You cannot specify both \"merge\" and \"mergeFields\".');\n        return e;\n      }\n\n      function lc(t, e) {\n        return void 0 === e ? {} : (Dr(t, e, [\"serverTimestamps\"]), Er(t, 0, \"serverTimestamps\", e.serverTimestamps, [\"estimate\", \"previous\", \"none\"]), e);\n      }\n\n      function fc(t, e) {\n        gr(t, \"object\", 1, e), e && (Dr(t, e, [\"source\"]), Er(t, 0, \"source\", e.source, [\"default\", \"server\", \"cache\"]));\n      }\n\n      function dc(t, e, n) {\n        if (e instanceof rc) {\n          if (e.firestore !== n) throw new sr(or.INVALID_ARGUMENT, \"Provided document reference is from a different Firestore instance.\");\n          return e;\n        }\n\n        throw Nr(t, \"DocumentReference\", 1, e);\n      }\n\n      var pc = ar(tc, \"Use firebase.firestore() instead.\"),\n          mc = ar(ec, \"Use firebase.firestore().runTransaction() instead.\"),\n          yc = ar(nc, \"Use firebase.firestore().batch() instead.\"),\n          gc = ar(rc, \"Use firebase.firestore().doc() instead.\"),\n          vc = ar(oc),\n          bc = ar(sc),\n          wc = ar(ac),\n          Ec = ar(uc),\n          Sc = ar(cc, \"Use firebase.firestore().collection() instead.\"),\n          Tc = {\n        Firestore: pc,\n        GeoPoint: Br,\n        Timestamp: Ur,\n        Blob: Fr,\n        Transaction: mc,\n        WriteBatch: yc,\n        DocumentReference: gc,\n        DocumentSnapshot: vc,\n        Query: wc,\n        QueryDocumentSnapshot: bc,\n        QuerySnapshot: Ec,\n        CollectionReference: Sc,\n        FieldPath: Eu,\n        FieldValue: Lu,\n        setLogLevel: tc.setLogLevel,\n        CACHE_SIZE_UNLIMITED: Ju\n      };\n\n      function Ic(t) {\n        t.INTERNAL.registerService(\"firestore\", function (t) {\n          return new tc(t);\n        }, function (t) {\n          nr(t && \"object\" == typeof t, \"shallowCopy() expects object parameter.\");\n          var e = {};\n\n          for (var n in t) {\n            Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n          }\n\n          return e;\n        }(Tc));\n      }\n\n      Ic(t);\n    }).apply(this, arguments);\n  } catch (t) {\n    throw console.error(t), new Error(\"Cannot instantiate firebase-firestore - be sure to load firebase-app.js first.\");\n  }\n});","map":null,"metadata":{},"sourceType":"script"}